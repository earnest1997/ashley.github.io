{"meta":{"title":"Ashley's blog","subtitle":null,"description":null,"author":"Ashley","url":"https://earnest1997.github.io/ashley271017.github.io","root":"/ashley271017.github.io/"},"pages":[{"title":"","date":"2023-04-15T14:19:04.358Z","updated":"2023-04-15T14:19:04.358Z","comments":true,"path":"404.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/404.html","excerpt":"","text":"404 Not Found | Material X function setLoadingBarProgress(num) { document.getElementById('loading-bar').style.width=num+\"%\"; } Ashley's blog &nbsp;博文 &nbsp;收藏 &nbsp;关于 Material X &nbsp;示例 &nbsp;分类 &nbsp;标签 &nbsp;近期文章 &nbsp;我的友链 setLoadingBarProgress(40); 404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除 &nbsp;Comments &nbsp;&nbsp;站内导航 近期文章 我的友链 &nbsp;&nbsp;Hot Tags BOM css css hooks es6 eslint - eslint git git sass hooks,react-router js技巧 node进程 node进程通信 模块化 动态引入 pm2 react hooks react-router react-router useeffect react-transition-group react状态管理 sass css scss ts webpack 前端工具 基础技能 效率提升配置 模块化 正则表达式 移动端适配 面经 项目搭建 Ashley © 2018- 鄂ICP备17030443号 总访问量为 次 . setLoadingBarProgress(80); setLoadingBarProgress(60); var GOOGLE_CUSTOM_SEARCH_API_KEY = \"\"; var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = \"\"; var ALGOLIA_API_KEY = \"\"; var ALGOLIA_APP_ID = \"\"; var ALGOLIA_INDEX_NAME = \"\"; var AZURE_SERVICE_NAME = \"\"; var AZURE_INDEX_NAME = \"\"; var AZURE_QUERY_KEY = \"\"; var BAIDU_API_ID = \"\"; var SEARCH_SERVICE = \"hexo\" || \"hexo\"; var ROOT = \"/\"||\"/\"; if(!ROOT.endsWith('/'))ROOT += '/'; $(function() { const $reveal = $('.reveal'); if ($reveal.length === 0) return; const sr = ScrollReveal({ distance: 0 }); sr.reveal('.reveal'); const year=$('.year-now') const yearVal=new Date().getFullYear() year.text(yearVal) }); $(function() { Waves.attach('.flat-btn', ['waves-button']); Waves.attach('.float-btn', ['waves-button', 'waves-float']); Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']); Waves.attach('.flat-box', ['waves-block']); Waves.attach('.float-box', ['waves-block', 'waves-float']); Waves.attach('.waves-image'); Waves.init(); }); $(function(){ if ('.cover') { $('.cover').backstretch( [\"/ashley271017.github.io/images/bg.jpg\"], { duration: \"6000\", fade: \"2500\" }); } else { $.backstretch( [\"/ashley271017.github.io/images/bg.jpg\"], { duration: \"6000\", fade: \"2500\" }); } }); var GUEST_INFO = ['nick','mail','link']; var guest_info = 'nick,mail,link'.split(',').filter(function(item){ return GUEST_INFO.indexOf(item) > -1 }); var notify = 'true' == true; var verify = 'true' == true; var valine = new Valine(); valine.init({ el: '#valine_container', notify: notify, verify: verify, guest_info: guest_info, path: \"/404.html\", appId: \"vu5VJ9hGtTUPkCsBP1ItVzg9-gzGzoHsz\", appKey: \"HfSu2jw0KjCyYYMydHTCArO2\", placeholder: \"请留言告诉我您要访问哪个页面找不到了\", pageSize:'10', avatar:'mp', lang:'zh-cn', highlight:'true' }) let COPY_SUCCESS = \"Copied\"; let COPY_FAILURE = \"Copy failed\"; /*页面载入完成后，创建复制按钮*/ !function (e, t, a) { /* code */ var initCopyCode = function(){ var copyHtml = ''; copyHtml += ''; copyHtml += ' Copy'; copyHtml += ''; $(\".highlight .code pre\").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', { target: function(trigger) { return trigger.nextElementSibling; } }); clipboard.on('success', function(e) { //您可以加入成功提示 console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); success_prompt(COPY_SUCCESS); e.clearSelection(); }); clipboard.on('error', function(e) { //您可以加入失败提示 console.error('Action:', e.action); console.error('Trigger:', e.trigger); fail_prompt(COPY_FAILURE); }); } initCopyCode(); }(window, document); /** * 弹出式提示框，默认1.5秒自动消失 * @param message 提示信息 * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info * @param time 消失时间 */ var prompt = function (message, style, time) { style = (style === undefined) ? 'alert-success' : style; time = (time === undefined) ? 1500 : time*1000; $('') .appendTo('body') .addClass('alert ' + style) .html(message) .show() .delay(time) .fadeOut(); }; // 成功提示 var success_prompt = function(message, time) { prompt(message, 'alert-success', time); }; // 失败提示 var fail_prompt = function(message, time) { prompt(message, 'alert-danger', time); }; // 提醒 var warning_prompt = function(message, time) { prompt(message, 'alert-warning', time); }; // 信息提示 var info_prompt = function(message, time) { prompt(message, 'alert-info', time); }; let LAZY_LOAD_IMAGE = \"\"; $(\".article-entry\").find(\"fancybox\").find(\"img\").each(function () { var element = document.createElement(\"a\"); $(element).attr(\"data-fancybox\", \"gallery\"); $(element).attr(\"href\", $(this).attr(\"src\")); /* 图片采用懒加载处理时, * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original, * 那么此处将原本的属性名src替换为对应属性名data-original, * 修改如下 */ if (LAZY_LOAD_IMAGE) { $(element).attr(\"href\", $(this).attr(\"data-original\")); } $(this).wrap(element); }); setLoadingBarProgress(100); if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js?t=1682305223893') .then(function () {console.log('ServiceWorker Register Successfully.')}) .catch(function (e) {console.error(e)}); }"},{"title":"","date":"2023-04-02T14:00:30.303Z","updated":"2023-04-02T14:00:30.303Z","comments":true,"path":"manifest.json","permalink":"https://earnest1997.github.io/ashley271017.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ashley's Blog\",\"short_name\":\"blog\",\"theme_color\":\"#2196f3\",\"background_color\":\"#2196f3\",\"display\":\"fullscreen\",\"orientation\":\"portrait\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-04-02T14:00:30.286Z","updated":"2023-04-02T14:00:30.285Z","comments":true,"path":"archive/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/archive/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2023-04-02T14:00:30.305Z","updated":"2023-04-02T14:00:30.305Z","comments":true,"path":"404/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/404/index.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2023-04-02T14:00:30.301Z","updated":"2023-04-02T14:00:30.301Z","comments":true,"path":"about/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/about/index.html","excerpt":"","text":"关于本站 主要用于记录日常开发中的收获与学到的新技能～～之前是与朋友一起维护一个叫做frontnote的github仓库 但是发现记的太乱冲突太多了。。 已升级https,支持PWA~ 下一步:接入百度统计 优化seo… Day Day up~"},{"title":"我的朋友们","date":"2023-04-02T14:00:30.304Z","updated":"2023-04-02T14:00:30.304Z","comments":true,"path":"friends/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-02T14:00:30.303Z","updated":"2023-04-02T14:00:30.303Z","comments":true,"path":"private/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/private/index.html","excerpt":"","text":"前端配置本地代理方法总结 https://juejin.im/post/5c0a6be4f265da616f6fc79c123456789101112131415161718192021devServer: &#123; proxy: &#123; '/api': &#123; // 需要直接代理到线上环境的接口 target: 'http://ad.server.com', changeOrigin: true, headers: &#123; // 后端要校验请求源，那改下 host 或者 origin 不就美滋滋了？ Host: 'ad.server.com', Origin: 'ad.server.com' &#125;, &#125;, '/apitest': &#123; // 需要与后端联调的接口 target: '10.8.0.1:9909',// 后端本地开发环境 &#125;, '/iframe': &#123; target: 'http://localhost:8085', &#125; // 另外还有 iframe 里的 api 调用指向线上环境 &#125; &#125; 然而，后端接口残酷地给跳转到登陆接口去了 😭。猜想一下可能后端的接口是通过 cookie 来判断当前登陆域的，从 localhost 过去的请求不带 cookie。后来尝试发现在 proxy的headers里再增加 cookie 即可破跳转，但是请求过去返回结果还是在报错，后端表示仍然是认证失败 作者：表示很不蛋定链接：https://juejin.im/post/5c0a6be4f265da616f6fc79c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 解读 Redux 中间件的原理 https://juejin.im/post/59dc7e43f265da4332268906"},{"title":"collect","date":"2019-09-01T06:48:25.000Z","updated":"2023-04-02T14:00:30.285Z","comments":true,"path":"collect/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/collect/index.html","excerpt":"","text":"node 从零开发一个node命令行工具 node进程 你可能想知道的 Node 子进程模块 你应该知道的Node.js子进程 Node.js 子进程：你需要知道的一切 Node JS后端项目开发与生产环境总结 node流 Node.js 流: 你需要知道的一切 webpack webpack 4 Code Splitting 的 splitChunks 配置探索 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客 webpack多入口文件 要点 glob.sync docker 命令说明 · Docker —— 从入门到实践 flutter (1) Flutter 状态管理之 Scoped Model &amp; Redux - 掘金 Flutter · 语雀 面试必备计算机基础 http2 pwa service worker介绍 生成manifest.json service worker生命周期 service worker离线缓存 常见问题 跨域问题 SEO 作为前端，你不得不知道的搜索引擎优化 前端性能监控 前端错误监控与收集探究 如何分析网页性能瓶颈"},{"title":"所有分类","date":"2023-04-02T14:00:30.302Z","updated":"2023-04-02T14:00:30.302Z","comments":true,"path":"blog/category/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/blog/category/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-04-02T14:00:30.302Z","updated":"2023-04-02T14:00:30.302Z","comments":true,"path":"blog/tags/index.html","permalink":"https://earnest1997.github.io/ashley271017.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常见webpack报错（线上）","slug":"常见webpack报错（线上）","date":"2023-04-21T09:14:06.000Z","updated":"2023-04-21T11:29:56.319Z","comments":true,"path":"2023/04/21/常见webpack报错（线上）/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/21/常见webpack报错（线上）/","excerpt":"","text":"ChunkLoadError: Loading chunk X failed.原因：代码分割导致：复现场景场景一：进入index.html, 一会会在需要的时候加载aaa.js，然后服务器上的aaa变成了bbb,再去加载aaa,报错场景二：index.html被强缓存，依旧请求aaa 按需加载的原理12345678910111213141516171819202122232425262728var promise = new Promise(function(resolve, reject) &#123;// installedChunks这个数组使用来记录模块加载情况,installedChunks[chunkId]的值可能有：// undefined 未加载// null 已经预加载// promise 正在加载// 0 已经加载 installedChunkData = installedChunks[chunkId] = [resolve, reject];&#125;);var script = document.createElement('script');var onScriptComplete;script.src = jsonpScriptSrc(chunkId);onScriptComplete = function (event) &#123; var chunk = installedChunks[chunkId]; if(chunk !== 0) &#123; if(chunk) &#123; var errorType = event &amp;&amp; (event.type === 'load' ? 'missing' : event.type); var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src; var error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')'); error.type = errorType; error.request = realSrc; chunk[1](error); &#125; installedChunks[chunkId] = undefined; &#125;&#125;;script.onerror = script.onload = onScriptComplete;document.head.appendChild(script); 标记installedChunks[chunkId] = [resolve, reject]为正在加载； 创建script标签，从服务器加载分片； 加载完分片代码后立即执行webpackJsonpCallback修改installedChunks[chunkId] = 0，并且执行installedChunks[chunkId][0]的resolve； 执行完分片代买后，执行script的onload回调函数。判断是否加载成功，如果installedChunks[chunkId] === 0则加载成功，如果installedChunks[chunkId] === [resolve, reject]则加载失败，报错loading chunk x failed.(missing http://xxxx.xx.xx/xxx.js) 如果报错是”error”:从代码上来看就是脚本加载失败，要么是网络原因，要么是服务器没有这个脚本，或者执行报错如果是”missing”:就是代码加载了但是没执行 参考 webpack chunk error","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"状态管理（react）","slug":"状态管理（react）","date":"2023-04-20T09:01:04.000Z","updated":"2023-04-20T09:03:35.951Z","comments":true,"path":"2023/04/20/状态管理（react）/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/20/状态管理（react）/","excerpt":"","text":"redux原理:发布订阅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* provider 组件代码 */function Provider(&#123; store, context, children &#125;) &#123; /* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store */ const contextValue = useMemo(() =&gt; &#123; /* 创建了一个根 Subscription 订阅器 */ const subscription = new Subscription(store) /* subscription 的 notifyNestedSubs 方法 ，赋值给 onStateChange方法 */ subscription.onStateChange = subscription.notifyNestedSubs return &#123; store, subscription &#125; /* store 改变创建新的contextValue */ &#125;, [store]) /* 获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染 */ const previousState = useMemo(() =&gt; store.getState(), [store]) useEffect(() =&gt; &#123; const &#123; subscription &#125; = contextValue /* 组件订阅，创建listens state变化的时候会触发更新😈😈 */ subscription.trySubscribe() if (previousState !== store.getState()) &#123; /* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法 */ subscription.notifyNestedSubs() // 更新组件 &#125; /* */ return () =&gt; &#123; subscription.tryUnsubscribe() //卸载更新 subscription.onStateChange = null &#125; /* contextValue state改变出发新的effect */ &#125;, [contextValue, previousState]) const Context = context || ReactReduxContext /* context 存在用跟元素传进来的context ，如果不存在 createContext创建一个context ，这里的ReactReduxContext就是由createContext创建出的context */ return &lt;Context.Provider value=&#123;contextValue&#125;&gt;&#123;children&#125;&lt;/Context.Provider&gt;&#125;/* 发布订阅者模式 */export default class Subscription &#123; constructor(store, parentSub) &#123; this.store = store this.parentSub = parentSub this.unsubscribe = null this.listeners = nullListeners this.handleChangeWrapper = this.handleChangeWrapper.bind(this) &#125; /* 负责检测是否该组件订阅，然后添加订阅者也就是listener */ addNestedSub(listener) &#123; this.trySubscribe() return this.listeners.subscribe(listener) &#125; /* 向listeners发布通知 */ notifyNestedSubs() &#123; this.listeners.notify() &#125; /* 这个就是添加的订阅着listener ，处理由redux，state而订阅的回调函数 */ handleChangeWrapper() &#123; if (this.onStateChange) &#123; this.onStateChange() &#125; &#125; /* 判断有没有开启订阅 */ isSubscribed() &#123; return Boolean(this.unsubscribe) &#125; /* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 */ trySubscribe() &#123; /* parentSub 即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription */ if (!this.unsubscribe) &#123; this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) /* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe */ : this.store.subscribe(this.handleChangeWrapper) this.listeners = createListenerCollection() &#125; &#125; /* 取消订阅 */ tryUnsubscribe() &#123; if (this.unsubscribe) &#123; this.unsubscribe() this.unsubscribe = null this.listeners.clear() this.listeners = nullListeners &#125; &#125;&#125; 流程： state更改 -&gt; store.subscribe -&gt; 触发父级Subscription的handleChangeWrapper 也就是notifyNestedSubs -&gt; 通知listeners.notify()-&gt;通知每个被connect容器组件的更新-&gt;callback执行-&gt;触发子Subscription的handleChangeWrapper-&gt;触发子Subscription的onstatechange（可以提前透漏一下,onstatechange保存了更新组件的函数） 设计思想单一数据源整个应用的 state 被储存在一棵 object tree 中 好处： 由于是单一的 state tree ，调试也变得非常容易State 是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行使用纯函数来执行修改 什么是纯函数不会改变传入的参数或者产生副作用的函数非纯函数如下 123function addElement(arr, element) &#123; arr.push(element);&#125; 副作用是啥？在JavaScript中，纯函数中的副作用是指函数在执行过程中产生了外部可观察变化。例如，发起HTTP请求、操作DOM、修改外部数据、console.log()打印数据、调用Date.now()或者Math.random()等 纯函数的好处它们只是接受先前的状态和操作，然后返回下一个状态的纯函数。这使得它们更容易测试、调试和理解。此外，由于它们不会修改先前的状态，因此可以更轻松地实现时间旅行和撤消/重做1 如何回溯？Redux提供了一个叫做时间旅行的功能，它允许您回溯和前进状态的历史记录。这是通过使用Redux DevTools来实现的，它可以让您轻松地查看应用程序状态的历史记录，并在需要时回溯或前进。您可以在Redux DevTools中查看应用程序状态的历史记录，并在需要时回溯或前进。此外，您还可以使用Redux Undo等库来实现撤销和重做功能 优化redux状态变化会重新渲染整个组件树吗？当Redux状态发生变化时，只有与状态相关的组件才会重新渲染。这是因为Redux使用了一种称为“浅比较”的技术，它可以检测到状态是否已更改。如果状态没有更改，则不会重新渲染组件。这可以提高应用程序的性能，并减少不必要的重新渲染 缺点 样板代码多context缺点 context不提供集中状态管理（我不可能把所有的state都放在一个provider里面，因为value变化会重新渲染所有的内层组件）难以追踪 、调试 context变化会让所有用到这个context的地方全都重新渲染，而不能细粒度的更新，比如我只用到了context中的A，只有当A变化的时候再重新渲染，怎么解决？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// providerconst Provider = (&#123; children &#125;) =&gt; &#123; const [store, dispatch] = useReducer(reducer, initState); const storeRef = useRef(null); storeRef.current = store; // 订阅所有子组件更新的回调函数 const subscribeRef = useRef([]); // store变化的时候执行所有的监听函数 useEffect(() =&gt; &#123; subscribeRef.current.forEach((sub) =&gt; sub()); &#125;, [store]); // 缓存value 利用ref拿到最新的状态 const value = useMemo( () =&gt; (&#123; dispatch, subscribe: (cb) =&gt; &#123; subscribeRef.current.push(cb); // return unsubscribe return () =&gt; &#123; subscribeRef.current = subscribeRef.current.filter( (item) =&gt; item !== cb ); &#125;; &#125;, getState: () =&gt; storeRef.current, &#125;), [] ); // value此后都不会变化了 只有store变化 store变化的时候通知所有的消费者 return &lt;MyContext.Provider value=&#123;value&#125; children=&#123;children&#125; /&gt;;&#125;;// useSelectorexport const useSelector = (selector) =&gt; &#123; const [, forceRender] = useReducer((s) =&gt; s + 1, 0); const store = useContext(Mycontext); // 获取state const selectedStateRef = useRef(null); selectedStateRef.current = selector(store.getState()); // 更新回调 对比更新后的state const checkUpdates = useCallback(() =&gt; &#123; const newState = selector(store.getState()); if (newState !== selectedStateRef.current) &#123; forceRender(); &#125; &#125;, []); // mounted的时候订阅store useEffect(() =&gt; &#123; const unsubscribe = store.subscribe(checkUpdates); // 卸载的时候取消订阅 return unsubscribe; &#125;, [store, checkUpdates]); // 返回最新的state return selectedStateRef.current;&#125;;export const useDispatch=()=&gt;&#123; const store=useContext(MyContext) return store.dispatch&#125; 核心点：包装一下provider提供的value,将其变成一个不可变对象，也就绕过了context自身的这一套更新流程，然后我们自己实现一套发布订阅的流程去做，我们提供给子组件的value中分发一个context自带的dispatch函数让用户去更改store，同时分发一个subscribe订阅函数，用于添加订阅者，以及一个getState获取最新store对象的函数，订阅以及获取最新state的步骤我们都放到useSelector里面，useSelector做的事情：挂载的时候订阅store,该方法还是像之前一样接收一个selector函数用于从store中过滤出组件所需要的东西，监听store变化，store变化的时候，每次变化的时候会重置当前的state（组件所需要的那部分）的值，每次变化的时候会将当前的state与旧的做一个浅层比较（每次更新的时候都是返回一个全新的饮用），如果有变化就强制更新，并且useSelector返回组件所需要selectedState","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/react/"}]},{"title":"巨石项目改造探究.md","slug":"巨石项目改造方案探究","date":"2023-04-17T09:06:15.000Z","updated":"2023-04-18T06:44:34.841Z","comments":true,"path":"2023/04/17/巨石项目改造方案探究/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/17/巨石项目改造方案探究/","excerpt":"","text":"背景公司有一个历史悠久、体积庞大的老项目，除了传统老旧项目存在的特点，该项目强依赖后端模板，且每一个页面都对应一个模板，启动依托于docker，随着项目不断更新迭代，项目结构越来越复杂，维护成本越来越高，进而引发一系列的问题… 巨石应用存在的问题 项目体积过大，clone时间长 结构混乱，高度耦合，难以维护 需要解决构建时间长的问题，需要维护复杂的webpack配置 多人开发同一个项目，发布部署容易混乱 技术栈迭代成本高昂 如何拆分？既然是巨石应用，很容易想到的改造方案就是拆分成多个子应用，分而治之，通常来说有以下几种拆分方案： 按技术拆分 按照业务或者页面拆分 按照权限拆分 按照变更的频率拆分我们的项目不存在权限限制以及技术栈不统一的问题,显然这两种拆分方式都不合适，在我们的业务场景中，一个项目是由多个页面组成的，每个页面之前的状态相互独立，显而易见的直接按照业务拆分即可，这里推荐madge工具，它可根据你指定的入口自动为你找到入口的依赖，并将其从主项目中剥离出来，拆分完成之后，又该采用哪种架构方式呢？ 传统解决方案muti repo也就是直接将其拆分成多个仓库，简单粗暴但存在不少问题： 管理、调试困难多个 git 仓库管理起来天然是麻烦的。对于功能类似的模块，如果拆成了多个仓库，无论对于多人协作还是独立开发，都需要打开多个仓库。虽然 vscode 通过 Workspaces 解决多仓库管理的问题，但在多人协作的场景下，无法保证每个人的环境配置一致。 分支管理混乱假如一个仓库提供给 A、B 两个项目用，而 B 项目优先开发了功能 b，无法与 A 项目兼容，此时就要在这个仓库开一个 feature/b 的分支支持这个功能，并且在未来合并到主干同步到项目 A。一旦需要开分支的组件变多了，且之间出来依赖关联，分支管理复杂度就会呈指数上升。 依赖关系复杂独立仓库间组件版本号的维护需要手动操作，因为源代码不在一起，所以没有办法整体分析依赖，自动化管理版本号的依赖。三方依赖版本可能不一致:一个独立的包拥有一套独立的开发环境，难以保证子模块的版本和主项目完全一直，就存在运行结果不一致的风险。 占用总空间大正常情况下，一个公司的业务项目只有一个主干，多 git repo 的方式浪费了大量存储空间重复安装比如 React 等大型模块，时间久了可能会占用几十 GB 的额外空间，对于没有外接硬盘的同学来说，定期清理不用的项目下 node_modules 也是一件麻烦事。 不利于团队协作一个大项目可能会用到数百个二方包，不同二方包的维护频率不同，权限不同，仓库位置也不同，主仓库对它们的依赖方式也不同。一旦其中一个包进行了非正常改动，就会影响到整个项目，而我们精力有限，只盯着主仓库，往往会栽在不起眼的二方包发布上。 代码无法复用之前我们说过我们的项目强依赖于后端，如果直接了当的拆分成多个项目的话，后端代码也会存在于多个仓库，但是由于整个的改造我们仅仅只想针对于前端，需要对后端同学是无感知的，显然这种方式无法做到 现代化解决方案monorepo是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo。 优势： 多个项目一套配置但是可以分批构建分开发布 开发阶段不用来回切换项目 可以共用代码 同时不用发布即可本地调试公共包 简化的依赖管理，无需为依赖项指定版本号，因为所有项目只有一个通用版本号。 依赖可复用 劣势： 仓库体积较大 提交记录容易混乱 因为是一个仓库，不好对子项目做单独的权限处理 不适合做自动化发布 多个项目一般都是独立的发布不好统一 需要自己管理依赖关系 提交历史容易混乱，需要自己管理 适用场景：适合内聚性比较强的工具类、框架类工程，例如react相关、 Angular相关，一般发布会有一系列的依赖同步更新；同时这种工程发展是可控的，不会随意膨胀，所以库的体积也是可控的。 不适用场景： 体积不可控的项目 需要做权限管理的项目 不适用子项目技术栈差异大的场景 回到我们的业务场景，由于各个子应用之间的构建存在差异没必要共用一套构建配置，且存在项目体积不可控、目前只支持全量发布等因素，因此未采用改方案 git submodules + muti repo什么是git submodules?允许您将 Git 存储库保留为另一个 Git 存储库的子目录，这使您可以将另一个存储库克隆到您的项目中，并将您的提交分开，子仓库包含了一整个完整的git仓库,甚至包含了.git目录。我司采用的也是该方案，在我们的场景中可以将巨石项目中的各个页面拆分成一个独立的项目，然后将所有页面都依赖的底层服务以及公共组件、公共方法等抽离出来作为子仓库，修改子仓库的时候无需切换项目只需cd ${子仓库目录}即可。 优势 代码可复用，调试成本低：拆分出子模块之后，也能做到可以共用一套公共代码而无需安装npm包并且可以直接本地调试 可以直接在拆出来的项目中，运行submodule的代码：因此可以在submodule中放一些公共服务，适用于依赖于docker或者是前后端未完全分离之类的项目，比如在我们的业务中，只需子仓库维护一套后端模板与docker配置，运行子仓库的宿主仓库的时候只需cd ${子仓库目录}运行容器，然后将宿主仓库的端口代理到容器运行的8083端口即可，在发挥了多仓库优势的同时保证了基础服务（后端代码）的唯一性 劣势 clone的时候需要额外clone一下子项目，如果子仓库体积过大就会造成clone时间过长 修改子项目的时候需要切换到子项目的仓库 相比npm包的形式，只要修改了submodule中的代码就会牵一发而动全身，存在风险 只是对复用代码提供了解决方案，其他传统多仓库的问题还是存在 webpack5模块联邦（Module Federation）也是一种提取公共模块的方案， 每个子应用单独构建，主应用在运行时通过容器加载远程模块即子应用的构建。主应用自动使用子应用当前版本的最新资源，一句话概括就是：它能允许一个线上部署的项目在运行时加载其他线上部署项目中的组件。 基本原理设想一下，在 webpack 中可以将一些后续加载的模块打成 chunk 包，然后在使用到这个模块的时候再懒加载，这种情形一般是在同一个项目中进行。那么我们是否也可以在 A 项目中把一个组件及其依赖打包成 chunk 包，而在 B 项目中按约定的地址异步 import 刚才那个 A 项目的 chunk 包，并运行使用呢？答案就是 Module Federation。 基本概念 远程组件提供方称为 remote 端，远程组件使用方称为 host 端。 一个项目既可以为 remote 端，也可以为 host 端，可以使用数个不同其他项目的组件，也可以为数个其他项目提供不同的组件。 具体怎么工作？例子：项目要引入一个工单工作台的页面，如下：工单工作台作为 remote 端的配置 remote端（工单工作台）(1) 由于我们两个项目都使用的是 vue3 + vite 方案，所以使用 vite-plugin-federation 插件是我们最佳的选择。首先需要在 host 端和 remote 端安装插件，如下命令： 1yarn add @originjs/vite-plugin-federation -D (2) 在插件内注册需要提供的组件,并且提供需要共享的三方依赖 (3) 配置完成后打包在 remote 端打包后会生成对应的入口文件，chunk 文件及依赖包文件 host端（IM 和电话工作台）(1) 插件配置，设置远程包地址 (2) 引用及注册组件，main.ts 文件如下这时需要注意，ticket-share 为 host 侧在 vite 插件中注册的包名，Detail 为 remote 端暴露(exposes 字段)声明的组件名。除了在全局注册，还可以在任意需要引用的地方引用。(3) 组件的使用在需要的地方引入使用，并根据业务情况传递 props，props 的使用方式与普通组件无异。此时我们已经完成了全部配置，此后我们只要打包上线运行即可。 线上如何调试使用Redirector 浏览器扩展：假设微应用程序的远程入口文件在https://my-federated-app.com/federated/my-micro-app/remoteEntry.js. 然后，如果我想使用本地开发服务器处理此应用程序，我可以将包含该模式的任何请求重定向/federated/my-micro-app/到http://localhost:3000运行开发服务器的位置 优势 更新成本低：引入公共包不需要打包再发布，相比npm包，不需要挨个升级使用该包的项目的依赖版本，他也适用于复杂度高的，业务关联性高，更新频次高的三高页面级组件 技术成本低：只需要修改一下webpack配置即可 支持延迟加载： bundle以仅在必要时加载模块，从而提高 Web 性能。 减少重复性依赖：引入的公共代码可以直接使用宿主环境的依赖 灵活拆分，细粒化程度高：相比git submodules，可以颗粒化到单页应用或者组件。也就是说他也可以代替iframe 劣势 没有样式隔离机制，容易造成主子应用样式污染 本地开发需要开启多个端口的服务，比较麻烦 共享包的维护成本高：需要将组件共享的包都找出来，共享有时是强制的，如果漏了某些包，可能会导致页面报错或崩溃，同一个库，有时需要维护在约定的版本范围内，有时一个包太老或太新也会在加载时报错（不过是否需要共享可供用户选择） 需要合理规划chunk拆分，如果拆分chunk过多会导致请求Chunk数量过多，并发量过大，如果多个模块共用一个remoteEntry又无法对其中包含的模块的版本做单独管理（改动频繁的划分到一起，如何像npm包一样做版本管理？external-remote-plugin 可以让版本号由JS动态注入，这里可以结合云控配置） 回到我们的业务场景，由于模块联邦只能复用JS chunk，对于我们依赖的后端服务无法复用，因此无法作为基层解决方案，但是他能解决目前代码复用方式存在的问题：由于我们的各个子项目都依赖了submodule中的公共组件、公共方法，每当修改一次这些公共组件、方法的时候，无论子应用需不需要修改调用方式，都需要在每个应用到这些公共组件、方法 的应用重新编译打包，显然影响到了效率，利用模块联邦的特性，我们可以在保证修改无副作用的前提下，直接上线submodule的内容，对于子应用是无感知的，只是cdn链接指向的Js chunk的内容变了而已。 微前端微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。微前端架构与框架无关，每个微应用都可以独立开发、独立运行、独立部署。 qiankun乾坤是市面上常见的微前端框架，以此为例说说他的特性：qiankun采用HTML Entry 方式进行了替代优化。 什么是HTML Entry? 就是直接将子应用打出来 HTML 作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。 使用qiankun进行微前端改造后，页面被拆分为一个基座应用和多个子应用，每个子应用都运行在独立的沙箱环境中。 具有如下特点： 独立性：微前端的主应用以及各个子应用独立开发、独立部署，并且在一定程度上微前端子应用可以独立于主应用单独运行； 沙箱隔离：子应用有自己单独的运行时，各个子应用之间的状态不被共享，也就是各个子应用之间：CSS与JS都是相互独立的，不会被别的子应用所污染。 框架无关：子应用完全可以采取不同的框架进行开发，因为现有微前端框架实现中，主应用仅是加载子应用构建后的 bundle； 状态共享：子应用可共享主应用的状态 可以看出他相比别的方案最大的优势是沙箱隔离与框架无关 适用场景 当巨石应用中某一部分需要在技术栈上做增量升级或者重构的时候 需要实现前端应用的动态加载和卸载以提高用户体验跟资源利用率 需要保证各个前端应用之间的样式隔离以及js沙箱 需要将多个前端应用整合为一个整体但是又不想牺牲各自的技术栈跟开发方式 不适用场景前端复杂度较低，没必要各个应用之间有很强的业务耦合或者数据依赖、需要频繁通信或者是共享状态 由于我们的项目本身就是一个多页面项目，天然支持HTML Entry，加上我们是将巨石应用拆分成多个小应用而不是聚合多个小应用因此不存在技术栈不统一的问题，与这个方案并不是很匹配 总结无论是哪一种方案都不是完美的，具体应用哪一种还是需要结合业务场景、切身实践选择 参考 https://xie.infoq.cn/article/cab16528dc0ecf3514fdfd492 https://www.burhanuday.com/blog/2023/03/devx-and-deployments-in-a-module-federated-micro-frontend","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/架构/"}]},{"title":"vue-router浅析原理","slug":"vue-router浅析原理","date":"2023-04-16T09:25:44.000Z","updated":"2023-04-17T02:44:04.560Z","comments":true,"path":"2023/04/16/vue-router浅析原理/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/16/vue-router浅析原理/","excerpt":"","text":"前言近期被问到一个问题，在你们项目中使用的是Vue的SPA（单页面）还是Vue的多页面设计？ 这篇文章主要围绕Vue的SPA单页面设计展开。 vue-router实现原理SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。单页面应用(SPA)的核心之一是: 1.更新视图而不重新请求页面; 2.vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。 路由模式vue-router 提供了三种运行模式： hash: 使用 URL hash 值来作路由。默认模式。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 hashhash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。 可以为hash的改变添加监听事件： 1window.addEventListener(\"hashchange\",funcRef,false) push()方法最主要的是对window的hash进行了直接赋值： 123function pushHash (path) &#123; window.location.hash = path&#125; hash的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，看下 transitionTo()方法： 12345678910111213141516171819202122History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) &#123; var this$1 = this; var route = this.router.match(location, this.current); this.confirmTransition(route, function () &#123; this$1.updateRoute(route); ... &#125;);&#125;;History.prototype.updateRoute = function updateRoute (route) &#123; var prev = this.current; this.current = route; this.cb &amp;&amp; this.cb(route); this.router.afterHooks.forEach(function (hook) &#123; hook &amp;&amp; hook(route, prev); &#125;);&#125;;History.prototype.listen = function listen (cb) &#123; this.cb = cb;&#125;; 可以看到，当_route值改变时，会自动调用Vue实例的render()方法，更新视图。 HashHistory.replace()replace()方法与push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史栈顶，而是替换掉当前的路由： 123456789101112131415161718192021HashHistory.prototype.replace = function replace (location, onComplete, onAbort) &#123; var this$1 = this; var ref = this; var fromRoute = ref.current; this.transitionTo(location, function (route) &#123; replaceHash(route.fullPath); handleScroll(this$1.router, route, fromRoute, false); onComplete &amp;&amp; onComplete(route); &#125;, onAbort);&#125;; function replaceHash (path) &#123; const i = window.location.href.indexOf('#') // 直接调用 replace 强制替换 以避免产生“多余”的历史记录 // 主要是用户初次跳入 且hash值不是以 / 开头的时候直接替换 // 其余时候和push没啥区别 浏览器总是记录hash记录 window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + '#' + path )&#125; 可以看出，它与push()的实现结构基本相似，不同点它不是直接对window.location.hash进行赋值，而是调用window.location.replace方法将路由进行替换。 historyHistory interface是浏览器历史记录栈提供的接口，在过去时期，通过back()，forward()，go()，打开本标签新地址等方法，我们可以改变浏览器历史记录栈的信息，进行各种地址跳转操作（其实就是控制浏览器的前进后退键），浏览器就会按照地址向服务端发送资源请求，服务器会返回对应的页面html文件，浏览器拿到后再进行渲染。 如何实现的无刷新跳转：pushState犹大在使用pushState将url改变之前，先做了页面组件的刷新，也就模拟出了页面跳转的样子。 那么，如果我刷新首页，又或者前进后退，怎么再更新页面组呢？答案就是使用popstate来做事件监听，当用户首次访问，进或后退的时候，都会触发popstate事件，再由popstate来当前页，上一页等页面的记录和绘制。 history模式的404问题使用history模式时，用户点击页面链接确实能“跳转”到不同页面，也会发现浏览器地址栏路径发生了视觉上的变化。但在子页面刷新时如果后端未做配置会出现问题。 比如 初始url是 http://localhost:8080 ，当用户点击链接时，url变成 http://localhost:8080/a 。 用户确实能看到/a 路径相对应的页面(区域/组件)，但当在该链接下刷新时，向服务端发送请求的的路径是 http://localhost:8080/a ，而服务端并未做/a的配置，会导致请求失败。所以使用history模式需要服务端做响应的配置。而http://oursite.com/#/user/id //如请求，只会发送http://oursite.com/所以hash模式下遇到根据url请求页面不会有问题","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue/"}]},{"title":"react18新特性解读","slug":"react18","date":"2023-04-16T03:59:52.000Z","updated":"2023-04-21T02:48:17.189Z","comments":true,"path":"2023/04/16/react18/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/16/react18/","excerpt":"","text":"并发什么是并发并发是只要一段时间内同时发生多件事情就行。 并发渲染机制react18为优化性能做的基于优先级的可打断的渲染流程。主要目标是根据用户的设备性能和网速对渲染过程进行适当的调整，帮助应用始终保持可响应，也就是说它能够保证 React 应用在长时间的渲染过程中依旧保持可交互性，能优先执行高优先级变更，避免页面出现卡顿或无响应的情况，从而提升用户体验。 Fiber 树的更新流程分为 render 阶段与 commit 阶段，render 阶段会收集 Fiber 树中需要更新的部分，代表着对于本次更新，我们需要做哪些具体变更。commit 阶段是将变更应用到真实的宿主环境中 render 阶段是没有副作用的（只是收集 Fiber 树中需要更新的部分），意味着可以被拆分，在阻塞模式下，render 阶段一次性执行完成，而在并发渲染模式下，render 阶段可以被拆解 如何开启在 React 18 中，提供了新的 root api，我们只需要把 render 升级成 createRoot(root).render(&lt;App /&gt;) 就可以开启并发模式了。 为什么会出现这么一套机制并发渲染出现之前：一旦它们开始渲染一次更新，它们不能中断包括创建新的 DOM 节点和运行组件中代码在内的工作。我们称这种方式为 “阻塞渲染”。如果渲染过程耗时比较长的话，就可能导致 UI 线程挂起和事件得不到响应，进而出现页面卡顿。比如当两个set State同时触发的时候（比如state2会在state1更新的时候也触发更新）会出现什么？同步模式下也就会按照顺序依次执行。但如果这个渲染流程中处理的 fiber 节点比较多，渲染一次就比较慢，这时候用户输入的内容可能就不能及时的渲染出来，用户就会感觉卡，体验不好。（注意之前所说的批处理机制是针对同一个state的） 并发渲染机制做的就是指定这两个state的优先级，比如：用户输入的 setState 的更新重要程度更高，如果有这种更新就把别的先暂停，执行这次更新，执行完之后再继续处理。并发渲染 示例React 会把 vdom 树转成 fiber 链表，因为 vdom 里只有 children，没有 parent、sibling 信息，而 fiber 节点里有，这样就算打断了也可以找到下一个节点继续处理。fiber 结构就是为实现并发而准备的。比如：针对上面两个setState同时触发的场景，如果第二个setStatek的优先级比较高的话：第一个setState触发的fiber节点变更会被打断，先执行第二个的fiber节点处理，完成之后再回来继续第一个。并发是通过交替执行来实现的上面是两个 setState 引起的两个渲染流程，先处理上面那次渲染的 1、2、3 的 fiber 节点，然后处理下面那次渲染的 1、2、3、4、5、6 的 fiber 节点，之后继续处理上面那次渲染的 4、5、6 的 fiber 节点。react的并发也就是在循环处理重新渲染涉及的fiber节点里多了个打断和恢复的机制 打断与恢复机制的流程基于时间分片的机制实现调度并发渲染机制的实现原理：时间分片 是什么时间分片其实就是一个固定而连续且有间隔的时间区间固定：每天固定工作8小时连续：每天都要上班有间隔：明天上班前会休息一段时间 为什么会出现时间分片JS是单线程的，浏览器是多线程的，除了JS线程还有事件处理线程以及定时器线程、网络请求线程、UI线程等，其中JS线程跟GUI渲线程是互斥的，因为如果操作dom的同时一边渲染会造成页面的错乱。因为假如一个setState涉及到大量的dom节点变化，如果按照之前同步渲染的方式，需要将所有的dom节点更新都处理完成，就会导致Js线程一直被占用，GUI渲染线程被挂起，就会造成页面的卡断，所以引入了时间分片的机制，遍历一会，休闲一会，休息的时候将控制权交还给浏览器，这样就能及时响应用户事件避免造成卡顿 时间分片是怎么做的总结就是把一个耗时长的任务按照优先级排序分成很多小片，每一个小片的运行时间很短，这里的运行时间长短会根据任务的优先级进行调整 一般是5毫秒，如果超过这个规定的时间还没执行完成的话就会被打断，在每个小片执行完之后，当第一个小任务完成后，先判断这一帧是否还有空闲时间，没有就挂起下一个任务的执行，将其添加到宏任务，记住当前挂起的节点，让出控制权给浏览器执行更高优先级的任务，之后为什么还能找到这个挂起的节点呢？主要是得益于fiber 结构，否则继续执行下一个任务比如事件处理（用户输入用户点击等），。这里的优先级react有自己的一套机制，比如一般是用户输入 点击事件的优先级更高，然后是滚动 拖拽 鼠标hover等为什么这里是宏任务？因为一轮事件循环，是先执行一个宏任务，然后再清空微任务队列里面的任务，如果在清空微任务队列的过程中，依然有新任务插入到微任务队列中的话，还是把这些任务执行完毕才会释放主线程。所以微任务会阻塞本次页面更新。而如果是宏任务，会将这个新增的宏任务丢到下一轮事件循环，不会阻塞本次的页面更新 上面所有的东西都是基于 fiber 架构实现的，fiber为状态更新提供了可中断的能力 useDeferredValue首先来看 React 18 新增的一个 API，useDeferredValue，它能够很好地展示并发渲染过程中的优先级调整特性。 useDefferedValue 用于声明组件部分状态的处理是可以延迟的，一般是一些计算逻辑较重的部分，让组件可以先渲染其它部分而不用等待这部分状态计算完成，当这部分状态更新完后再进行渲染，从而让 UI 始终保持可响应。 跟防抖的区别：跟防抖还是有比较大的区别的，那么不论机器快慢，网络情况如何，始终会在用户停止输入后的固定之间才执行。使用场景：输入框搜索 与并发的关系该APi依赖于并发特性，并发特性指开启并发模式后才能使用的特性 SuspenseSuspense 是一种数据获取的机制，它的目标是让组件能够像读取 props 或 state 一样简单地通过网络读取异步数据。这里的数据不仅限于接口返回数据，也可以是代码、图片等等用处1：优先渲染用户点击的组件有两个 Suspense 包裹的组件，如果用户点击其中一个，那么它的优先级会变高，React 会优先进行这部分的 hydration，让它能尽快可交互。用处2：设置loading态 Render API为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。 与之前的render的区别18之前如果我们需要重新渲染整个根app的话 需要传递多次container 1234567const container = document.querySelector('#root');// Initial render. Container is explicitly accessed.ReactDOM.render(&lt;App text=\"Hello\" /&gt;, container);// Subsequent renders. Container is explicitly accessed.ReactDOM.render(&lt;App text=\"Hello world!\" /&gt;, container); 18之后 12345678// First, we create a rootconst root = ReactDOM.createRoot(document.querySelector('#root'));// Initial render. Container is implicitly accessed.root.render(&lt;App name=\"Hello\" /&gt;);// Subsequent renders. Container is implicitly accessed.root.render(&lt;App name=\"Hello world!\" /&gt;); useID是什么支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 hydration 的不兼容，这解决了在 React 17 及 17 以下版本中已经存在的问题。因为我们的服务器渲染时提供的 HTML 是无序的，useId 的原理就是每个 id 代表该组件在组件树中的层级结构 123456789101112131415function NameFields() &#123; const id = useId(); return ( &lt;div&gt; &lt;label htmlFor=&#123;id + '-firstName'&#125;&gt;First Name&lt;/label&gt; &lt;div&gt; &lt;input id=&#123;id + '-firstName'&#125; type=\"text\" /&gt; &lt;/div&gt; &lt;label htmlFor=&#123;id + '-lastName'&#125;&gt;Last Name&lt;/label&gt; &lt;div&gt; &lt;input id=&#123;id + '-lastName'&#125; type=\"text\" /&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 注意不能用于列表的key setState 自动批处理批处理是指为了获得更好的性能，在数据层，将多个状态更新批量处理，合并成一次更新（在视图层，将多个渲染合并成一次渲染）。 在React 18 之前，我们只在 React 事件处理函数 中进行批处理更新。默认情况下，在promise、setTimeout、原生事件处理函数中、或任何其它事件内的更新都不会进行批处理： 123456789101112131415161718192021import React, &#123; useState &#125; from 'react';// React 18 之前const App: React.FC = () =&gt; &#123; console.log('App组件渲染了！'); const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); return ( &lt;button onClick=&#123;() =&gt; &#123; setCount1(count =&gt; count + 1); setCount2(count =&gt; count + 1); // 在React事件中被批处理 &#125;&#125; &gt; &#123;`count1 is $&#123;count1&#125;, count2 is $&#123;count2&#125;`&#125; &lt;/button&gt; );&#125;;export default App; 在 18 之后，任何情况（在setTimeout，Promise，原生事件等其他场景下的更新也能受益（前提是关闭了严格模式），不像react 17只能在合成事件中实现批处理）都会自动执行批处理，多次更新始终合并为一次 误区这里的批处理不是针对的同一个state的update， 12345678const onClick=()=&gt;&#123;setA(9)console.log(a,'a') // undefinedsetTimeout(()=&gt;&#123; setA(100) console.log(a,'a2') // undefined&#125;,10)&#125; 第一个是因为如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，还无法拿到，其实就是批处理（批处理不是18才出现的，18只是做了更多的批处理），第二个是因为回调函数形成的闭包，始终是定时器设置的时候的state 批处理与并发的关系 类组件的批量更新策略 针对对象形式：对象合并（类似Object.assign）,针对相同属性名，后面属性覆盖前面属性。 123456this.setState(&#123;count: this.state.count + 1&#125;)this.setState(&#123;count: this.state.count + 1&#125;)// 合并为this.setState(&#123;count: this.state.count + 1&#125;)// 所以count为2 针对函数形式： 函数收集，然后依次执行1234this.setState(prev =&gt; (&#123;count: prev.count + 1&#125;))this.setState(prev =&gt; (&#123;count: prev.count + 1&#125;))// 执行两次 prev =&gt; (&#123;count: prev.count + 1&#125;)，所以count为3 函数批量更新策略： 针对直接传参形式： 简单理解就是覆盖，后面覆盖前面的 123setCount(1)setCount(2)// 后面覆盖前面，count为2 针对函数形式：函数收集，依次执行 123456setCount(prev =&gt; prev + 1)setCount(prev =&gt; prev + 2)// 收集函数，依次执行// prev =&gt; prev + 1// prev =&gt; prev + 2// 所以count = 1 + 1 + 2 = 4 如上代码在setTimeout中也是只触发一个rerender的 flushSync批处理是一个破坏性改动，如果你想退出批量更新，你可以使用 flushSync 1234567891011121314151617181920212223242526import React, &#123; useState &#125; from 'react';import &#123; flushSync &#125; from 'react-dom';const App: React.FC = () =&gt; &#123; const [count1, setCount1] = useState(0); const [count2, setCount2] = useState(0); return ( &lt;div onClick=&#123;() =&gt; &#123; flushSync(() =&gt; &#123; setCount1(count =&gt; count + 1); &#125;); // 第一次更新 flushSync(() =&gt; &#123; setCount2(count =&gt; count + 1); &#125;); // 第二次更新 &#125;&#125; &gt; &lt;div&gt;count1： &#123;count1&#125;&lt;/div&gt; &lt;div&gt;count2： &#123;count2&#125;&lt;/div&gt; &lt;/div&gt; );&#125;;export default App; flushSync 函数内部的多个 setState 仍然为批量更新，这样可以精准控制哪些不需要的批量更新。 React 组件的返回值在 React 17 中，如果你需要返回一个空组件，React只允许返回null。如果你显式的返回了 undefined，控制台则会在运行时抛出一个错误。在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined（但是 React 18 的dts文件还是会检查，只允许返回 null，你可以忽略这个类型错误）。 Suspense 不再需要 fallback 来捕获在 React 18 的 Suspense 组件中，官方对 空的fallback 属性的处理方式做了改变：不再跳过 缺失值 或 值为null 的 fallback 的 Suspense 边界。相反，会捕获边界并且向外层查找，如果查找不到，将会把 fallback 呈现为 null。更新前：以前，如果你的 Suspense 组件没有提供 fallback 属性，React 就会悄悄跳过它，继续向上搜索下一个边界： 123456789101112// React 17const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 这个边界被使用，显示 Loading 组件 &lt;Suspense&gt; // &lt;--- 这个边界被跳过，没有 fallback 属性 &lt;Page /&gt; &lt;/Suspense&gt; &lt;/Suspense&gt; );&#125;;export default App; 现在，React将使用当前组件的 Suspense 作为边界，即使当前组件的 Suspense 的值为 null 或 undefined： 123456789101112// React 18const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 不使用 &lt;Suspense&gt; // &lt;--- 这个边界被使用，将 fallback 渲染为 null &lt;Page /&gt; &lt;/Suspense&gt; &lt;/Suspense&gt; );&#125;;export default App; 参考","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/react/"}]},{"title":"撸一个组件库","slug":"撸一个组件库","date":"2023-04-16T03:38:14.000Z","updated":"2023-04-18T06:44:35.115Z","comments":true,"path":"2023/04/16/撸一个组件库/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/16/撸一个组件库/","excerpt":"","text":"组件库的开发 组件库的要求：tree shaking（tree shaking）怎么实现？针对支持ESM模块的前端项目：生成ESM格式 即可配合webpack5 tree shaking针对不支持ESM的：使用：babel-plugin-import ，它不仅能让： 123456// 原始代码import &#123; Button &#125; from 'vant';​// 编译后代码import Button from 'vant/es/button';import 'vant/es/button/style'; 不使用 ESM 的库也能做到上面这样的转换 生成UMD格式以更好的支持前端项目做 external，减少构建时长，生成ESM格式（JS 标准， Tree Shaking 友好，优先考虑使用该模块）以及CJS（模块同时跑在前后端项目，需要兼容） 产物要求哪几种格式？ ESM: JS 标准模块格式， 对Tree Shaking 友好，优先考虑使用该模块 CJS：如果模块同时跑在前后端项目，需要兼容 UMD：用以支持支持多种引入方式，自动判断现在的环境来决定代码的导出方式。比如用 script 标签引入的话，代码会被挂载到 window 对象， require 方式的话会以 module.exports 的方式导出等,并且还能支持externals。1234567// webpack打包生成 umdoutput: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].min.js'), library: 'skel', libraryTarget: 'umd&#125; 按需加载每个组件在打包产物中有一个对应的文件夹 webpack配置 指定多个入口即可 1234567entry: &#123; popup: './src/popup', background: './src/background', contentScripts: './src/content-scripts', demo: './src/view/demo' ...&#125; vite 加几个配置项让打包目录和我们目录对应即可 1234567891011121314151617181920212223output: [ &#123; format: 'es', // file:'./dist/index.esm.js', entryFileNames: '[name].js', //让打包目录和我们目录对应 preserveModules: true, // 打包根目录 dir: 'es', // Put preserved modules under this path at root level preserveModulesRoot: `packages/360kuai_ui/src/components`, &#125;, &#123; format: 'cjs', entryFileNames: '[name].js', //让打包目录和我们目录对应 preserveModules: true, // 打包根目录 dir: 'lib', // Put preserved modules under this path at root level preserveModulesRoot: `packages/360kuai_ui/src/components`, &#125;,] package.json 指定模块的入口文件package.json文件有两个字段可以指定模块的入口文件：main和exports main当我们从模块中import一个XXX的时候，Node.js 就会到./node_modules目录下面，找到模块，然后根据该模块package.json的main字段去执行入口文件。 exportsexports字段的优先级高于main字段。它有多种用法。 覆盖main字段声明主入口有两种写法： 12345678910&#123; \"exports\": &#123; \".\": \"./main.js\" &#125;&#125;// 等同于&#123; \"exports\": \"./main.js\"&#125; 为不同的模块格式指定不一样的入口// require条件指定require()命令的入口文件（即 CommonJS 的入口），// default条件指定其他情况的入口（即 ES6 的入口）。 123456&#123; \"exports\": &#123; \"require\": \"./main.cjs\", \"default\": \"./main.js\" &#125;&#125; 指定脚本或子目录的别名。指定/es/react/index.js的别名为/react 123456789101112\"exports\": &#123; \"./react\": &#123; \"import\": \"./es/react/index.js\", \"require\": \"./lib/react/index.cjs\", \"default\": \"./dist/react/index.js\" &#125;, \"./vue\": &#123; \"import\": \"./es/vue/index.js\", \"require\": \"./lib/vue/index.cjs\", \"default\": \"./dist/vue/index.js\" &#125; &#125;, 依赖处理：可能需要声明组件库的宿主依赖（peerDependencies 表示同版本依赖）：peerDependencies：宿主依赖，指定了当前模块包在使用前需要安装的依赖，比如说我们目前正在学习的 Element Plus 组件库，它需要宿主环境提供指定的 Vue 版本来搭配使用，如果在一个 npm 包的 dependencies 中定义依赖，执行 npm install 时当子依赖的依赖版本在已经构建的依赖树中匹配不到时，就会重复下载。而 peerDependencies 则可以解决这个问题，在 peerDependencies 中定义的依赖，不会重复下载，但会要求宿主环境提供 peer 依赖一致的版本，否则在安装的时候提示警报亦或报错中断命令的执行。 实时预览文档代码格式化和规范检测 单测 支持typescript 样式隔离因为组件库的样式需要能被用户自定义的样式覆盖，所以不能选用css In modules（打包时会自动将 id 和 class 混淆成全局唯一的 hash 值）等做法，这里参考的antd直接给每个元素加上一个全局的类名，这里可以用postcss插件：autoprefixer 版本号管理使用changeset自动更新包的version和生成changelog。 遇到的问题 将样式文件单独拆分到每个组件如果不做处理，最后生成了一个单个的style.css文件，我们想要将样式文件单独拆分到每个组件下怎么办 external掉scss，避免vite去处理我们的css文件 写一个脚本将scss文件复制到打包后目录 将所有的sass文件使用sass.compile手动编译一下，然后将sass文件中引入的sass文件都改成css后缀 最后自定义一个vite插件，generateBundle拿到打包之后的代码将JS文件中的import xx.scss替换成import xx.css","categories":[],"tags":[{"name":"vite","slug":"vite","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vite/"}]},{"title":"合成事件","slug":"合成事件","date":"2023-04-15T13:16:01.000Z","updated":"2023-04-18T06:44:35.116Z","comments":true,"path":"2023/04/15/合成事件/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/15/合成事件/","excerpt":"","text":"大家都知道 React 有一套自己的事件机制，如官方文档所述： SyntheticEvent 实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。如果因为某些原因，当你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。合成事件与浏览器的原生事件不同，也不会直接映射到原生事件。例如，在 onMouseLeave 事件中 event.nativeEvent 将指向 mouseout 事件。每个 SyntheticEvent 对象都包含以下属性： 123456789101112131415boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()void persist()DOMEventTarget targetnumber timeStampstring type React使用合成事件的原因： 进行浏览器兼容 避免垃圾回收 方便事件统一管理和事务机制下面对比DOM2原生事件，演示几个Demo方便更好的理解，Demo 使用 “react”: “^16.14.0” 来演示 父组件监听两个原生事件1234567891011121314151617export default class App extends Component &#123; componentDidMount() &#123; document.addEventListener(\"click\", () =&gt; &#123; console.log(\"document\"); &#125;); window.addEventListener(\"click\", () =&gt; &#123; console.log(\"window\"); &#125;); &#125; render() &#123; return ( &lt;div className=\"black-box\"&gt; &lt;Demo /&gt; &lt;/div&gt; ); &#125;&#125; 1、原生事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component &#125; from \"react\";import \"./index.css\";const getDom = (className) =&gt; &#123; return document.querySelector(`.$&#123;className&#125;`);&#125;;// 冒泡/捕获const BUBBLING = false;export default class Demo extends Component &#123; state = &#123;&#125;; componentDidMount() &#123; const c1 = getDom(\"demo1-content1\"); const c2 = getDom(\"demo1-content2\"); const c3 = getDom(\"demo1-content3\"); c1.addEventListener( \"click\", () =&gt; &#123; console.log(1); &#125;, BUBBLING ); c2.addEventListener( \"click\", () =&gt; &#123; console.log(2); &#125;, BUBBLING ); c3.addEventListener( \"click\", () =&gt; &#123; console.log(3); &#125;, BUBBLING ); &#125; render() &#123; return ( &lt;div className=\"black\" &#123;...this.props&#125;&gt; &lt;h3 onClick=&#123;() =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;); &#125;&#125; id=\"black-1\" &gt; demo1 原生事件 &lt;/h3&gt; &lt;div className=\"demo1-content1\"&gt; 1 &lt;div className=\"demo1-content2\"&gt; 2&lt;div className=\"demo1-content3\"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;this.state.show &amp;&amp; &lt;p&gt;3-2-1-document-window&lt;/p&gt;&#125; &lt;/div&gt; ); &#125;&#125; 输出结果是显而易见的，如图： 2、合成事件12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; Component &#125; from \"react\";import \"./index.css\";export default class Demo extends Component &#123; state = &#123;&#125;; render() &#123; return ( &lt;div className=\"black\"&gt; &lt;h3 onClick=&#123;() =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;); &#125;&#125; &gt; demo2 合成事件 &lt;/h3&gt; &lt;div className=\"demo2-content1 yellow\" onClick=&#123;() =&gt; &#123; console.log(1); &#125;&#125; &gt; 1 &lt;div className=\"demo2-content2 yellow\" onClick=&#123;() =&gt; &#123; console.log(2); &#125;&#125; &gt; 2 &lt;div className=\"demo2-content3 yellow\" onClick=&#123;() =&gt; &#123; console.log(3); &#125;&#125; &gt; 3 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;this.state.show &amp;&amp; &lt;p&gt;3-2-1-document-window&lt;/p&gt;&#125; &lt;/div&gt; ); &#125;&#125; 输出结果： 3、原生事件和合成事件混合使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Component &#125; from \"react\";import \"./index.css\";const getDom = (className) =&gt; &#123; return document.querySelector(`.$&#123;className&#125;`);&#125;;// 冒泡/捕获const BUBBLING = false;export default class Demo extends Component &#123; state = &#123;&#125;; componentDidMount() &#123; const c1 = getDom(\"demo3-content1\"); const c3 = getDom(\"demo3-content3\"); c1.addEventListener( \"click\", () =&gt; &#123; console.log(1); &#125;, BUBBLING ); c3.addEventListener( \"click\", () =&gt; &#123; console.log(3); &#125;, BUBBLING ); &#125; render() &#123; return ( &lt;div className=\"black\"&gt; &lt;h3 onClick=&#123;() =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;); &#125;&#125; &gt; demo3 混合使用 &lt;/h3&gt; &lt;div className=\"demo3-content1\"&gt; 1 &lt;div className=\"demo3-content2 yellow\" onClick=&#123;() =&gt; &#123; console.log(2); &#125;&#125; &gt; 2&lt;div className=\"demo3-content3\"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;this.state.show &amp;&amp; ( &lt;p&gt; 3-1-2-document-window &lt;br /&gt; &lt;/p&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 输出结果： 黄色的数字2所在区域是react事件，1和3是原生事件 到这里的疑惑是，为什么1比2先打印出来？ 简单的来说，其实是React(v16)所有事件最后都是代理到 document 上面，通过冒泡机制先输出3和1，然后触发document上的事件 打印2。document上挂载的两个事件，第一个是我们在 组件里注册的，第二个是 React 挂载的，如下图所示。 4、原生事件阻止冒泡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import &#123; Component &#125; from \"react\";import \"./index.css\";const getDom = (className) =&gt; &#123; return document.querySelector(`.$&#123;className&#125;`);&#125;;// 冒泡/捕获const BUBBLING = false;export default class Demo extends Component &#123; state = &#123;&#125;; componentDidMount() &#123; const c1 = getDom(\"demo5-content1\"); const c2 = getDom(\"demo5-content2\"); const c3 = getDom(\"demo5-content3\"); c1.addEventListener( \"click\", () =&gt; &#123; console.log(1); &#125;, BUBBLING ); c2.addEventListener( \"click\", (e) =&gt; &#123; console.log(2, \"阻止原生事件冒泡\"); // 阻止冒泡或捕获 e.stopPropagation(); &#125;, BUBBLING ); c3.addEventListener( \"click\", () =&gt; &#123; console.log(3); &#125;, BUBBLING ); &#125; render() &#123; return ( &lt;div className=\"black\"&gt; &lt;h3 onClick=&#123;() =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;); &#125;&#125; &gt; demo4 原生阻止冒泡 &lt;/h3&gt; &lt;div className=\"demo5-content1\"&gt; 1 &lt;div className=\"demo5-content2 stop\"&gt; 2&lt;div className=\"demo5-content3\"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;this.state.show &amp;&amp; ( &lt;p&gt; 3-2 &lt;br /&gt; e.stopPropagation(); &lt;/p&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 这里也不难理解，红色虚线为阻止了冒泡 5、合成事件阻止冒泡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; Component &#125; from \"react\";import \"./index.css\";export default class Demo extends Component &#123; state = &#123;&#125;; render() &#123; return ( &lt;div className=\"black\"&gt; &lt;h3 onClick=&#123;() =&gt; &#123; this.setState(&#123; show: !this.state.show &#125;); &#125;&#125; &gt; demo5 合成阻止冒泡 &lt;/h3&gt; &lt;div className=\"demo6-content1 yellow\" onClick=&#123;() =&gt; &#123; console.log(1); &#125;&#125; &gt; 1 &lt;div className=\"demo6-content2 yellow stop\" onClick=&#123;(e) =&gt; &#123; e.stopPropagation(); console.log(2); &#125;&#125; &gt; 2 &lt;div className=\"demo6-content3 yellow\" onClick=&#123;() =&gt; &#123; console.log(3); &#125;&#125; &gt; 3 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;this.state.show &amp;&amp; ( &lt;p&gt; 3-2-document &lt;br /&gt; e.stopPropagation(); &lt;/p&gt; )&#125; &lt;/div&gt; ); &#125;&#125; 这里可以看到，的确是阻止了React事件的冒泡，只输出了3和2。但是也有两个问题。 第一，为何window上的原生事件也被阻止了？第二，为何document上的原生事件没被阻止?我们知道，上面调用的e.stopPropagation()，其实是React事件本身处理过的。原生的事件需要通过 nativeEvent 获取。来简单看一下下面的代码，React是如何做的： 12345678910111213141516171819202122stopPropagation: function () &#123; // 原生事件 var event = this.nativeEvent; if (!event) &#123; return; &#125; if (event.stopPropagation) &#123; // 原生事件阻止冒泡 event.stopPropagation(); &#125; else if (typeof event.cancelBubble !== 'unknown') &#123; // The ChangeEventPlugin registers a \"propertychange\" event for // IE. This event does not support bubbling or cancelling, and // any references to cancelBubble throw \"Member not found\". A // typeof check of \"unknown\" circumvents this issue (and is also // IE specific). event.cancelBubble = true; &#125; // 这里应该是阻止 React合成事件冒泡的地方(待求证) this.isPropagationStopped = functionThatReturnsTrue;&#125;, 当调用 React事件本身的e.stopPropagation()的时候，React 调用了一次原生事件上的stopPropagation()，从而阻止了window上的事件。 原生事件与合成事件混用如何阻止冒泡 12e.nativeEvent.stopImmediatePropagation(); e.stopPropagation(); 调用 e.nativeEvent.stopImmediatePropagation()，阻止document上注册的其它原生事件。React 可能是基于设计方面考虑，没有实现这个方法。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/react/"}]},{"title":"模块联邦在微前端架构中的实践","slug":"模块联邦在微前端架构中的实践","date":"2023-04-03T14:46:42.000Z","updated":"2023-04-18T06:39:29.870Z","comments":true,"path":"2023/04/03/模块联邦在微前端架构中的实践/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/04/03/模块联邦在微前端架构中的实践/","excerpt":"","text":"前言译自# [Micro Frontends Architecture with Webpack Module Federation](译自# Micro Frontends Architecture with Webpack Module Federation),原文作者Sercan Eraslan 背景我们有一个用React编写的管理面板，在这里我们跟踪和管理Trendyol GO（Hızlı Market和Trendyol Yemek）中所有阶段的订单。单一仓库很好地满足了我们的期望，因为一开始我们是唯一的团队，员工数量不多。 单一的仓库并不总是坏的。如果它能满足你的期望，如果它不会给你带来负面影响，那么你可以使用各种方法。重要的是；找到以最有效的方式达到你的目标的方法。 大约1.5年后，当我们的队友人数变得足够多时，我们以领域驱动设计（DDD）的理念将我们的团队划分为多个小团队。在这一点上，我们必须设计微前端的结构，使每个团队可以独立开发应用。 我之前在几个不同的项目中有过微前端的经验。我也曾自己设计过一个微前端架构，但研究所有其他的替代方案并选择最能满足我们需求的方案是更合理的。我们探索了所有的替代方案，权衡了每个方案的利弊（我不会在这篇文章中谈论所有的替代方案，因为那是另一个话题。），在评估的最后，我们发现Webpack 模块联邦可以很好地满足我们的需求。 为什么是Webpack模块联邦？当我们研究了所有的替代方案后，出于以下原因，选择Webpack模块联邦更有意义。 没有维护成本（如果你自己建立一个架构，会有维护成本） 没有团队特定的学习成本（如果你自己建立一个架构，会有学习成本） 向模块联邦过渡的成本很小 不需要对每个项目进行重新架构 所有的需求都在构建时得到满足 在运行时不需要额外的工作 分享依赖的成本低 库/框架独立 你不需要处理所有的压缩和缓存问题 你不需要处理路由问题 Shell和Micro Apps不是紧耦合的，而是松耦合的 怎么使用模块联邦有以下三种形式： 域名 通过这种方式，你可以创建尽可能多的微型前端（应用程序），并通过Shell App管理完全独立的域。例如，想象一下，在Shell App中有一个菜单，当链接被点击时，它将在右边带出相关的应用程序。 2.微件 通过这种方式，你可以从任何应用程序中添加任何微件/组件（即一小段代码）到任何应用程序。你可以在产品应用中的用户应用中公开UserDetail组件。 混合型 你可以同时使用第一和第二种方式。 开始实践首先创建一个app 命名为shell，并且以相同的方式创建应用product &amp; user 1npx create-react-app shellcd shellyarn add webpack webpack-cli webpack-server html-webpack-plugin css-loader style-loader babel-loader webpack-dev-server 第一步：初始化项目123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App&apos;;ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;)); 第二步：配置webpack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ModuleFederationPlugin = require(&apos;webpack/lib/container/ModuleFederationPlugin&apos;);const deps = require(&apos;./package.json&apos;).dependencies;module.exports = &#123; mode: &apos;development&apos;, devServer: &#123; port: 3001, &#125;, module: &#123; rules: [ &#123; test: /.js?$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos;, ], &#125;, &#125;, &#123; test: /.css$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, ], &#125;, plugins: [ new ModuleFederationPlugin( &#123; name: &apos;SHELL&apos;, filename: &apos;remoteEntry.js&apos;, shared: [ &#123; ...deps, react: &#123; requiredVersion: deps.react, singleton: true &#125;, &apos;react-dom&apos;: &#123; requiredVersion: deps[&apos;react-dom&apos;], singleton: true, &#125;, &#125;, ], &#125; ), new HtmlWebpackPlugin(&#123; template: &apos;./public/index.html&apos;, &#125;), ],&#125;; 其中关于模块联邦的配置项，解释如下： name: 我们用它来确定应用程序的名称。我们将通过这个名称与其他应用程序进行交流。 filename: 我们用它作为一个入口文件。在这个例子中，其他应用程序将能够通过输入 “SHELL@http://localhost:3001/remoteEntry.js “访问SHELL应用程序。 shared（共享）。我们用它来指定这个应用程序将与其他应用程序共享哪些依赖。这里需要注意的是 &quot;singleton: true&quot;。如果你不写 &quot;singleton: true&quot;，每个应用程序将在一个单独的React实例上运行 把同样的文件复制到User和 Product项目，但不要忘记增加端口和改变名称字段。 第三步：设计1234567// app.jsimport React from &apos;react&apos;;import &apos;./App.css&apos;;const App = () =&gt; ( &lt;div className=&quot;shell-app&quot;&gt; &lt;h2&gt;Hi from Shell App&lt;/h2&gt; &lt;/div&gt;);export default App; 123456789// app.css.shell-app &#123; margin: 5px; text-align: center; background: #FFF3E0; border: 1px dashed #FFB74D; border-radius: 5px; color: #FFB74D; &#125; 上面两个文件都放到src下，Product 以及 User 项目也做同样的更改，只是将src命名为shell。三个项目依次运行以下的命令 1yarn webpack server 现在，我们所有的应用程序都为Micro Frontends架构做好了准备，并且可以相互独立运行。🎉 第四步：整合是时候提到模块联邦的两个伟大的功能了 :) expose：它允许你从任何应用程序到另一个应用程序共享一个组件、一个页面或整个应用程序。你所暴露的一切都被创建为一个单独的构建，从而创造了一个自然的tree shaking。每个构建都以文件的MD5哈希值命名，所以你不必担心缓存的问题。 remote： 它决定了你将从哪些应用程序接收一个组件、一个页面或应用程序本身。每个应用程序都可以同时暴露和定义一个远程，并多次进行。 现在让我们把Product应用暴露给Shell应用，让我们做第一个微前端连接。 让我们打开产品 repo 中的 webpack.config.js 文件，并改变其中传给ModuleFederationPlugin中的对象，如下。exposes对象中的值决定了它在repo中共享哪个组件，而对象中的key决定了其他应用程序可以访问这个组件的名称。 12345678910111213141516171819new ModuleFederationPlugin( &#123; name: &apos;PRODUCT&apos;, filename: &apos;remoteEntry.js&apos;, exposes: &#123; &apos;./App&apos;: &apos;./src/App&apos;, &#125;, shared: [ &#123; ...deps, react: &#123; requiredVersion: deps.react, singleton: true &#125;, &apos;react-dom&apos;: &#123; requiredVersion: deps[&apos;react-dom&apos;], singleton: true, &#125;, &#125;, ], &#125;), 让我们打开shell repo中的webpack.config.js文件，将其中传给ModuleFederationPlugin方法的对象做如下修改。remotes对象中的值决定了如何访问Product（@符号前的名称必须与Product库中Webpack config中的名称相同），对象中的key允许我们只用名称来访问Product。 12345678910111213141516171819new ModuleFederationPlugin( &#123; name: &apos;SHELL&apos;, filename: &apos;remoteEntry.js&apos;, remotes: &#123; PRODUCT: &apos;PRODUCT@http://localhost:3002/remoteEntry.js&apos; &#125;, shared: [ &#123; ...deps, react: &#123; requiredVersion: deps.react, singleton: true &#125;, &apos;react-dom&apos;: &#123; requiredVersion: deps[&apos;react-dom&apos;], singleton: true, &#125;, &#125;, ], &#125;), 我们已经将2个应用程序连接在一起。现在让我们看看如何在Shell应用程序中使用Product。让我们在shell资源库中打开App.js并做如下修改。 1234567891011121314import React from &apos;react&apos;;import &apos;./App.css&apos;;const ProductApp = React.lazy( () =&gt; import(&apos;PRODUCT/App&apos;));const App = () =&gt; ( &lt;div className=&quot;App&quot;&gt; &lt;h2&gt;Hi from Shell App&lt;/h2&gt;&lt;React.Suspense fallback=&apos;Loading...&apos;&gt; &lt;ProductApp /&gt; &lt;/React.Suspense&gt; &lt;/div&gt;);export default App; 我们已经定义了名为 “App “的组件，该组件通过React的lazy方法从Product中暴露出来，到我们名为ProductApp的变量。我们需要对我们将从不同的微前端获得的组件使用lazy函数，我们需要使用Suspense在模板部分使用它，这样我们可以确保所有的东西都加载到页面上。 如果你现在想，你可以在User应用程序中添加一个组件，并尝试在产品应用程序中使用这个组件:) 你可以使用expose和remotes共享你想要的组件。创建模块联邦的Zack Jackson有一个Github repo，叫做module-federation-examples。在这个Repo中，有许多的示例，如React、Vue、Angular、服务器端渲染、共享路由，如果你想的话，你可以查看它们。 需要解决的问题路由其中一个重要的问题是，微前端管理自己的路由，以保持它们与Shell的松散耦合关系。 在我们建立的项目中，我们倾向于在Shell的路由安装微前端模块。当到达/mf-a路径时，Shell会懒加载Micro-Frontend-A应用程序，当用户到达/mf-b路径时，它以同样的方式加载Micro-Frontend-B。 12345678910111213141516171819202122232425// shell/src/Shell.jsimport ...const MicroFrontendA = lazy(() =&gt; import(&apos;MicroFrontendA/MicroFrontendARoutes&apos;));const MicroFrontendB = lazy(() =&gt; import(&apos;MicroFrontendB/MicroFrontendBRoutes&apos;));const Shell = () =&gt; &#123; return ( &lt;Router&gt; &lt;Menu /&gt; &lt;main&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Yükleniyor...&lt;/div&gt;&#125;&gt; &lt;Switch&gt; &lt;Route exact path=&quot;/&quot;&gt; &lt;Redirect to=&quot;/mf-a&quot; /&gt; &lt;/Route&gt; &lt;Route path=&quot;/mf-a&quot;&gt; &lt;MicroFrontendA /&gt; &lt;/Route&gt; &lt;Route path=&quot;/mf-b&quot;&gt; &lt;MicroFrontendB /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/main&gt; &lt;/Router&gt; );&#125;;export default Shell; 之后，控制权转移到微前端。微前端-A处理自己的子模块，并对其进行路由设置。与上面的例子有关，当导航到/mf-a的路径时，PageA被加载，当路径是/mf-a/page-b时，PageB被加载。 1234567891011121314151617181920212223// micro-frontend-a/src/pages/MicroFrontendARoutes.jsimport React, &#123; lazy &#125; from 'react';import &#123; Switch, Route, useRouteMatch &#125; from 'react-router-dom';import withPermissions from 'Shell/hoc/withPermissions';const PageA = lazy(() =&gt; import('pages/pageA/PageA'));const PageB = lazy(() =&gt; import('pages/pageB/PageB'));const MicroFrontendARoutes = () =&gt; &#123; const &#123; path &#125; = useRouteMatch();return ( &lt;Switch&gt; &lt;Route exact path=&#123;path&#125; render=&#123;() =&gt; withPermissions(['VIEW_PAGE_A'])(PageA)&#125; /&gt; &lt;Route exact path=&#123;`$&#123;path&#125;/page-b`&#125; render=&#123;() =&gt; withPermissions(['VIEW_PAGE_B'])(PageB)&#125; /&gt; &lt;/Switch&gt; );&#125;;export default MicroFrontendARoutes; 共享状态以及hooks实际上，在模块联邦中共享这些是非常容易的；但它目前有一个有趣的解决方案。 如果你看看我为Shell的webpack.config.js所举的例子，在共享方面有一个微妙的接触。一个消耗公共状态的hooks也在库下共享。由于应用程序总是在Shell下渲染，所有的context都以正确的顺序加载，当我们像例子中那样共享 hooks时，我们可以在微前端中使用通用context而不会有任何错误。 12345678910111213// shell/webpack.config.jsconst &#123; dependencies: deps &#125; = require('./package.json');const moduleFederationOptions = &#123; ...exposes: &#123; ... './hooks/useToastr': './src/hooks/useToastr', &#125;, shared: [ &#123; ... &#125;, './src/hooks/useToastr', // Here! ],&#125;; 热重载举例说明我们遇到的问题。如果我们通过Shell访问应用程序，我们在Micro-Frontend-A中做的一个改变不会触发热重载。因此，我们在开发的时候会慢一点，我们必须在每次改变后刷新。 为了解决这个问题，模块联邦团队开发了@module-federation/fmr包。当它作为插件被包含在Webpack配置中时，你的模块联邦结构的任何变化都会自动运行Live Reload。 部署在使应用程序上线的过程中，我们遇到了两个主要问题。 在运行时动态地设置publicPath。当用模块联邦创建一个复杂的应用程序时，会出现这类问题。Shell将从哪里获得微前端的共享文件？属于Shell的文件将来自微前端的哪些路径？许多文件路径需要被设置。我们通过正确指定publicPath选项来控制这些。 在Trendyol GO中，我们将应用程序作为Docker镜像创建一次，然后我们使它们在不同的环境中通过环境变量接受不同的设置。如果publicPath是在构建时设置的，我们就必须解决大的配置文件问题，这不是一个优化的解决方案。 我们稍微修改了Zack Jackson在这篇文章中提到的方法，使其非常简单地在运行时分配动态publicPath。 在我们使用的方法中，有一个叫做setPublicPath.js的文件。其内容的格式如下。 12// shell/src/setPublicPath.js__webpack_public_path__ = `$&#123;new URL(document.currentScript.src).origin&#125;/`; 我们通过在构建时操作Webpack设置中的entry 12345// shell/webpack.config.jsentry: &#123; Shell: './src/setPublicPath', main: './src/index',&#125;, 在运行时，动态设置模块联邦设置中分配的远程URL。我们用External Remotes Plugin来实现 1234567// shell/webpack.config.jsconst moduleFederationOptions = &#123; ...remotes: &#123; MicroFrontendA: 'MicroFrontendA@[window.MF_A_URL]/remoteEntry.js', MicroFrontendB: 'MicroFrontendB@[window.MF_B_URL]/remoteEntry.js', &#125;, ...&#125;; 如何在运行时设置window.MF_A_URL and window.MF_B_URL 12345678// shell/src/index.jsimport config from 'config'; // dynamic vars. from an .env file e.g.window.MF_A_URL = config.MF_A_URL;window.MF_B_URL = config.MF_B_URL;import('./bootstrap'); 在这个过程的最后，我们实现了一个稳定的应用程序。虽然在我们面前还有许多不同的改进，但从现在开始，每个团队可以开发自己的模块，而不必依赖其他团队。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"},{"name":"模块联邦","slug":"模块联邦","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/模块联邦/"}]},{"title":"拯救动画卡顿之FLIP","slug":"拯救动画卡顿之FLIP","date":"2023-03-20T15:16:48.000Z","updated":"2023-04-18T06:44:35.053Z","comments":true,"path":"2023/03/20/拯救动画卡顿之FLIP/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/03/20/拯救动画卡顿之FLIP/","excerpt":"","text":"前置知识什么是FPSFPS是浏览器的每秒的渲染帧数，也就是浏览器切换画面的次数，大多数设备的刷新率都是60FPS，一般来说FPS越低页面就会越卡顿。 什么是像素管道？像素管道是浏览器单个帧的渲染流水线，如果其中有某些环节执行过程过长就会导致卡顿 JavaScript。通常来说，阻塞的发起都是来自于 JS ，这不是说不用 JS，而是要正确的使用 JS 。首先，JS 线程的运行本身就是阻塞 UI 线程的（暂不考虑 Web Worker）。从纯粹的数学角度而言，每帧的预算约为 16.7 毫秒（1000 毫秒 / 60 帧 = 16.66 毫秒/帧）。但因为浏览器需要花费时间将新帧绘制到屏幕上，只有 ~10 毫秒来执行 JS 代码，过长时间的同步执行 JS 代码肯定会导致超过 10ms 这个阈值，其次，频繁执行一些代码也会过长的占用每帧渲染的时间。此外，用 JS 去获取一些样式还会导致强制同步布局。 样式计算（Style）。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 规则的过程，这个过程不仅包括计算层叠样式表中的权重来确定样式，也包括内联的样式，来计算每个元素的最终样式。 布局（Layout）。在知道对一个元素应用哪些规则之后，浏览器即可开始计算该元素要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，一般来说如果修改了某个元素的大小或者位置，则需要检查其他所有元素并重排（re-flow）整个页面。 绘制（Paint）。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的，绘制包括两个步骤： 1) 创建绘图调用的列表， 2) 填充像素，后者也被称作栅格化。 合成（Composite）。由于页面的各部分可能被绘制到多个层上，因此它们需要按正确顺序绘制到屏幕上，才能正确地渲染页面。尤其对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。 上述的五个阶段并不是一定都会执行到的，这五个阶段中涉及到了老生常谈的两个概念：重排跟重绘，虽然初次渲染布局跟绘制必不可少，但是后期我们可以控制避免通过这两个管道：以下是当我们修改不同的样式属性时，会触发的几种帧流程： 从上图中能看到JS阶段以及Style 和 Composite阶段 是不可避免的，因为需要 JS 来引发样式的改变，Style 来计算更改后最终的样式，Composite 来合成各个层最终进行显示，能跳过的步骤只有布局跟绘制，我们知道，执行的阶段越少，耗时就越少，每秒的渲染帧数就会越高，那么能不能直接跳过这两个步骤直接到合成呢？答案是肯定的，如下的属性只会触发合成阶段：transform、opacity、pointer-events、perspective （透视效果）、curosr、orphans设置当元素内部发生分页时必须在页面底部保留的最少行数（用于打印或打印预览）、widows（设置当元素内部发生分页时必须在页面顶部保留的最少行数（用于打印或打印预览））。 FLIP综上所述，当我们写动画的时候如果用height margin padding left等会触发重排的属性，相较于只用transform或者opacity会带来更多的性能开销，一旦这个计算时长超过1个动画帧(一般是60帧每秒,也就是说超过16.7ms), 那么这帧动画将不会绘制，产生页面卡顿。FLIP技术，就是一种让动画只利用到transform或者opacity的技巧，FLIP是 First, Last, Invert, Play的简称。 概念First对应动画的Start阶段，用 element.getBoundingClientRect()记录初始位置。 Last对应动画的End阶段，先执行触发layout变动的代码，同样的用element.getBoundingClientRect()记录元素的终止位置。 Invert现在元素处于End位置，利用 transform 做一个逆运算，让添加了 transform 的元素回归到初始位置。 Play真正需要执行动画时，将 transform 置为 None 上述阶段可能有人会困惑，getBoundingClientRect不是也会触发重排吗？但是需要注意的是我们的重心是在动画阶段，要保障的是动画阶段的流畅，更何况用户在网页上进行交互时，比如click，touch，从交互结束到感知到程序的相应大约需要100ms的生理反应时间。我们在用户交互后要做100ms内准备好动画就好了，这些动画准备计算就是getBoundingClientRect(或getComputedStyle)等的计算。 实践现在实现一个简单的从左到右的循环滚动动画 1234567891011121314151617181920212223242526272829const playAnimate = (el) =&gt; &#123; if (!el) return; // 记录初始位置，对应 FLIP的FIRST const pos = tagWrapperRef.current?.getBoundingClientRect(); const &#123; left: initLeft &#125; = pos; // 设置元素样式为动画结束时的目标位置 tagWrapperRef.current.classList.add('scroll-to-end'); // 记录终止位置 对应FLIP的LAST const endPos = tagWrapperRef.current?.getBoundingClientRect(); const &#123; left: endLeft &#125; = endPos; // 计算初始位置跟终止位置的偏差 const deltaLeft = initLeft - endLeft; tagWrapperRef.current.animate( [ // 动画开始时，利用 `transform` 做一个逆运算，让添加了 `transform` 的元素回归到初始位置。 &#123; transform: `translate($&#123;deltaLeft&#125;px,0)`, &#125;, &#123; transform: 'none', &#125;, ], &#123; duration: totalTime * 1000, easing: 'linear', iterations: Infinity, &#125; ); &#125; 123.scroll-to-end&#123; left:100% &#125; 采用FLIP的形式成功的避开了动画过程中更改left。我们注意到：我们可以在动画开始前预先用API计算元素在动画终止时候的位置，只要知道了终态跟初始状态，就能迅速计算出要达到终态该怎么移动，由此避开一些复杂的计算，由此我们也可以得出： 除了用来做性能优化之外，FLIP也能用于简化某些场景下动画的实现过程，如以下几个场景： 元素宿主元素的变化，比如将元素从A移动到B 容器大小变化 图片展开和收缩效果 项目删除和添加时填充空白区域的效果 网格项的重新排序举个例子，如第三个场景，如若添加或者删除的卡片的大小是未知的，如果用常规的方式移动其他卡片将变得困难，而如果使用FLIP，问题将迎刃而解12345678910111213141516171819// Lastif (updateType === 0) &#123; // 增加卡片 newListData = this.state.listData.slice(0, activeIndex).concat(&#123; index: cardIndex++ &#125;, this.state.listData.slice(activeIndex)) &#125; else &#123; // 删除卡片 newListData = this.state.listData.filter((value, index) =&gt; index !== activeIndex)&#125;// Invert// 0 增加 1 删除const updateIndex = updateType === 0 ? 1 : 0activeList.forEach((item, index) =&gt; &#123; rect = item.getBoundingClientRect() invertArr[index + updateIndex][0] = invertArr[index + updateIndex][0] - rect.left invertArr[index + updateIndex][1] = invertArr[index + updateIndex][1] - rect.top ... 使用FLIP形式需要注意什么 FLIP中的前三个阶段也就是前期的准备工作需要在绘制这个步骤之前，也就是时间需要尽可能的控制在之前提到的100ms以内，否则的话 渲染的过程中可能出现闪烁，但是我们怎么才能抓住绘制前这个时机呢？本人用React比较多，以React为例：答案是useLayoutEffect，它接受一个回调函数，这个函数会在dom更新后、重绘之前同步的执行 比如，我们实现一个点击方块互换位置的动画（详见https://codepen.io/jlkiri/pen/oNjaMrK) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Flipper = () =&gt; &#123; const [ids, setIds] = React.useState([\"square-1\", \"square-2\"]); const rects = React.useRef(new Map()).current; const swap = ([a, b]) =&gt; [b, a]; React.useEffect(() =&gt; &#123; const squares = document.querySelectorAll(\".square\"); // Cache position and size once on initial render for (const square of squares) &#123; rects.set(square.id, square.getBoundingClientRect()); &#125; &#125;, []); React.useLayoutEffect(() =&gt; &#123; const squares = document.querySelectorAll(\".square\"); for (const square of squares) &#123; // Get previous size and position from cache const cachedRect = rects.get(square.id); if (cachedRect) &#123; const nextRect = square.getBoundingClientRect(); // Invert const translateX = cachedRect.x - nextRect.x; // Cache the next size and position rects.set(square.id, nextRect); // Play square.animate( [ &#123; transform: `translateX($&#123;translateX&#125;px)` &#125;, &#123; transform: `translateX(0px)` &#125; ], 1000 ); &#125; &#125; &#125;, ids); return ( &lt;div className=\"container\"&gt; &#123;ids.map((id, i) =&gt; &#123; return ( &lt;div id=&#123;id&#125; onClick=&#123;() =&gt; setIds(swap(ids))&#125; className=&#123;`square`&#125;&gt; &#123;id&#125; &lt;/div&gt; ); &#125;)&#125; &lt;/div&gt; );&#125;;ReactDOM.render(&lt;Flipper /&gt;, document.querySelector(\"#root\")); 以上可以用如下的流程图概括：虽然useEffect总是在useLayoutEffect以及浏览器绘制之后执行，但是注意到这里我们仅仅在第一次渲染之后执行了，而这里的useLayoutEffect在之后的每一次渲染之后都会执行。 避免多次触发重排可能会有的人“读”“写”一起进行。 错误的做法：循环遍历元素并使用 getBoundingClientRect 读取它们的位置，然后立即使用 animate 为它们设置动画。 正确的做法：批量的读取与写入 最后Invert这一步骤可能有些许麻烦，今年5月份作者提供了插件Flip Plugin 参考 FLIP Your Animations Animating Layouts with the FLIP Technique 前端性能优化之浏览器渲染优化 —— 打造60FPS页面","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/css/"}]},{"title":"a2hs debug记录","slug":"debug记录","date":"2023-03-15T13:34:53.000Z","updated":"2023-04-18T06:44:35.115Z","comments":true,"path":"2023/03/15/debug记录/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/03/15/debug记录/","excerpt":"","text":"beforeInstallPrompt事件不触发如果页面是可安装的话，将在页面加载后不久触发。 没触发的原因？ PWA 必须尚未安装 （chrome://apps查看已经安装的应用） 满足用户参与启发式（以前，用户必须与域交互至少 30 秒，这不再是要求）。 您的 Web 应用程序必须包含 Web 应用程序清单。 您的 Web 应用程序必须通过安全的 HTTPS 连接提供服务。(或者是localhost)如果证书过期了证书有问题也会有问题 这里可以直接用chrome://flags/#unsafely-treat-insecure-origin-as-secure设置一下 注意本地需要启http服务，如果是HTTPS会不生效，如果是不仅仅在Chrome测试，推荐webpack-mkcert本地就能启动https 证书有效 已使用 fetch 事件处理程序注册了一个服务工作者。 manifest.json编写有问题，（注意这里也可以是json后缀） 如下 start_url有问题或者是没设置scope，当设置的是相对路径的时候，是相对于当前json文件所在的路径，如果JSON文件是一个外链文件的话，这里的start_url需要是绝对路径，同时scope 也必须设置成绝对路径 icons的src有问题，图片必须跟设置的sizes是同一宽高比，此外似乎只支持png jpeg格式 icons的src没设置type 怎么debug ？ devtool的lighthouse可以检测你的pwa存在哪些问题 为什么不生效，但是好像不准确 验证该浏览器是否支持？ demo(源码) 怎么动态设置start_url?12345678910111213141516171819202122import manifestJson from './manifests.json'; const manifestContent = &#123; ...manifestJson, name, start_url: window.location.href, scope: `$&#123;window.location.origin&#125;$&#123;window.location.pathname&#125;` &#125;; const imgType = cover.replace(/\\?.*/, '').split('.').slice(-1)[0]; const &#123;icons&#125; = manifestContent; icons[0].src = cover; icons[0].type = `image/$&#123;imgType&#125;`; const linkDom = document.querySelector('#manifest'); const stringManifest = JSON.stringify(manifestContent); if (linkDom) &#123; linkDom.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(stringManifest)); &#125; else &#123; const link = document.createElement('link'); link.id = 'manifest'; link.rel = 'manifest'; link.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(stringManifest)); document.head.appendChild(link); &#125; 以上测试结果来源于chrome, 360浏览器, Safari不支持beforeInstallPrompt","categories":[],"tags":[{"name":"a2hs","slug":"a2hs","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/a2hs/"}]},{"title":"gitlab ci  从入门到实践","slug":"从入门到实践","date":"2023-03-02T11:22:48.000Z","updated":"2023-04-18T06:44:35.053Z","comments":true,"path":"2023/03/02/从入门到实践/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/03/02/从入门到实践/","excerpt":"","text":"一、Gitlab CI 是什么？现代持续的软件开发导致了开发者需要持续的build, test 和 deploy 重复的代码更改，这些重复的过程非常的繁琐，但是对保证代码持续更新迭代来说又非常的重要。此时便需要一种非人为手动的方法来帮助我们自动完成这些重复的工作。这个自动完成工作的理念被称为CI/CD. 在这里Gitlab CI/CD就是Gitlab官方发布的一种自动流水线帮助开发者完成重复性工作的一个服务。 二、如何使用？Gitlab CI的使用主要需要2大步骤步骤一：配置runner我们可以简单的把Gitlab runner给理解成.gitlab-ci.yml 文件内容的*执行者，.gitlab-ci.yml 告诉了Gitlab runner去做什么。Gitlab runner不是一个配置项，它是需要专门部署的，比如用docker部署一个runner镜像到可以连接内网的容器。也可以使用公司内配好的shared runners. 使用shared runner：无需多余操作，请确保shared runner选项被enable了即可直接使用公共runner。（如下） 自己配置runner：部署Gitlab runner官方文档：Run GitLab Runner in a container | GitLab[1] 关联runner到gitlab官方文档：Registering runners | GitLab[2] A. 安装docker: 1$ brew install --cask docker B. 启动Gitlab runner container:起一个docker container来执行Gitlab Runner镜像 1234docker run -d --name gitlab-runner --restart always \\ -v /Users/Shared/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest C. 注册runner到Gitlab:只用docker起一个gitlab runner不能将我们当前使用的gitlab repository和上一步创建的runner进行关联。在此需要将其进行相互关联，将runner注册到我们的gitlab repository 使用上图得到的URL和token去替换下面指令的–url和–registration-token –tag-list 为当前runner的标签，在配置流水线job的时候使用，在此可随意配置不同的标签名 1234567891011docker run --rm -v /Users/Shared/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register \\ --non-interactive \\ --executor \"docker\" \\ --docker-image alpine:latest \\ --url \"https://gitlab.com/\" \\ --registration-token \"wc-Reg7qUpGRB4Lw3q9Y\" \\ --description \"gitlab—cicd-runner\" \\ --tag-list \"yehanli,liyehan\" \\ --run-untagged=\"true\" \\ --locked=\"false\" \\ --access-level=\"not_protected\" 至此，Gitlab runner和配置均已成功，打开setting/CICD页面可以看到如下提示： 步骤二：创建.gitlab-ci.yml文件在mono repo的根目录创建一个文件, 命名为.gitlab-ci.yml, 并将其push到master分支。 123git add .gitlab-ci.ymlgit commit -m \"Add .gitlab-ci.yml\"git push origin master 在较低gitlab版本(比如11.4)，如果在master主分支下没有.gitlab-ci.yml的话，在Gitlab左侧的导航栏不会有Gitlab Runner这个tab。 在项目的setting/CI/CD/General pipelines中，我们可以自定义设置CI设置文件的路径，默认如下 三、如何编写.gitlab-ci.yml文件？首先，让我们先来熟悉下yaml的常见写法，以及对比下它与json有什么不同。 Yaml Syntax写法详情具体请见 =&gt; YAML Syntax ‒ Ansible Documentation[3] YAML语法：数组写法： 123&#123; \"array\": [\"red\", \"blue\", \"yellow\"]&#125; 转化为yaml为 1234array: - red - blue - yellow 对象写法： 123456789&#123; \"student1\": &#123; \"name\": \"小明\" &#125;, \"array\": [\"red\", \"blue\", \"yellow\"], \"student2\": &#123; \"name\": \"小明\" &#125;&#125; 转化为yaml为 123456789# 我是注释student1: name: 小明array: - red - blue - yellowstudent2: name: 小明 yaml中不像json那样无法注释，我们可以用#进行注释 流水线环节梳理:流水线的流程，根据配置的.gitlab-ci.yml文件可以分为如下几个环节： 在单个的流水线任务执行之前进行配置定义单个流水线任务(job)，并对此任务进行针对配置 单个流水线任务的形式可以参考如下示例，具体字段释义可以暂时忽略，会在之后详解： 12345678910# 这个my_job的任务名是可以自定义起的my_job: only: - master tags: - yehanli script: - echo 'job ========= 完成' stage: build retry: 2 Gitlab-CI 关键字：Gitlab CI的关键字有很多，但实际常用的只有较小一部分。在此部分会对常用关键字进行详解。 script需要被运行的脚本。以数组形式配置。 1234567pipeline_job: ...... script: - cd &lt;文件夹目录路径&gt; - npm install - npm build ...... before_script在所有的流水线任务执行之前需要执行的脚本，或者单个流水线任务中的script执行之前执行某些scrip variables变量在Gitlab-CI中，变量大致可分为三类： Gitlab给我们预先定义的变量，比如CI_COMMIT_BRANCH. Setting =&gt; Gitlab CI/CD =&gt; variables中定义的变量 在.gitlab-ci.yml中定义的变量(如下示例) 123456789variables: TEST_VAR: \"All jobs can use this variable's value\"job1: variables: TEST_VAR_JOB: \"Only job1 can use this variable's value\" script: - echo \"$TEST_VAR\" ...... imageCI流水线运行环境的docker镜像(任何相关的代码运行环境镜像皆可),比较常用的有：node, python, java, etc… stagesGitlab CI允许我们进行自定义的流水线阶段配置，我们可以将自己的流水线自我划分为若干stages，然后在不同的stage来做不同的事。（稍后会有示例）(对应gitlab上的那一排圆圈圈)stages会依次执行，如果前一个stage的任务没有运行完，后面的stage不会被触发。 一旦有一个stage中的任务fail掉了，下一个stage的任务便不会执行。如果当前stage定义了多个任务，那么其中一个任务失败，另外一个任务还是会被继续执行。以下为自定义的stages： 123456stages: - first_stage - second_stage - third_stage - fourth_stage - fifth_stage 如果没有自定义stages，那么默认的stages为.pre =&gt; build =&gt; test =&gt; deploy =&gt; .post(自定义stages会重写除了.pre, .post之外所有的默认stages) 123456stages: - .pre # 执行在所有的stages之前 - build - test - deploy - .post # 执行在所有的stages之后 stagestage为stages的一个子项，在我们自定义单个流水线任务时可以配置 cache:缓存多个流水线任务之间共用的文件，目录， etc… 12345cache: key: cache-node-modules # 在这里写出需要缓存的文件的路径，在此为node_modules paths: - node_modules retry:一个job可以被重新执行的最大数量。必须是个正整数, 0-2, 2为最大值 when可设置在特定失败原因的情况下执行12345job: script: rspec retry: max: 2 when: runner_system_failure only &amp; except only: 设置流水线任务执行时机 except: 设置流水线任务不执行时机可配置选项（常用的几个）：pushes： git push时触发，适用于所有分支merge_requests： MR被创建时触发，适用于所有分支web： 手动在Gitlab Runner/pipeline里面点击run pipeline时触发 配置branch名称来规定触发任务的分支(如下) 123456789myjob: only: - master# 以上写法等同于myjob: only: variables: # $CI_COMMIT_REF_NAME是一个gitlab的预设变量，代表当前commit给哪个branch上了 - $CI_COMMIT_REF_NAME == \"master\" rules:if此字段可以在单个流水线job或者workflow字段下进行配置。 rules关键词下可以进行if语句配置，如果if满足的话可执行某些自定义配置 12rules: - if: $CI_COMMIT_REF_NAME =~ /feature/ 注意: only &amp; except和rules:if都是用来决定单个job执行时机的，在配置时只能存在一个，否则会报错 workflow需要和rules配合用来控制整个pipeline的行为，比如整个流水线执行与否。整个流水线正常运行的前提是其rules配置中的if语句至少需要触发一个. 在各个流水线任务的外层进行配置 12345678variables: IS_FEATURE: \"false\"workflow: rules: - if: $CI_COMMIT_REF_NAME =~ /feature/ variables: IS_FEATURE: \"true\" - when: always # Run the pipeline in other cases when这个关键字和stage需要配合使用。如果一个stage fail掉了，那么我们应该期待下个stage怎么办呢？ (When to run a job?) on_success(default): 所有之前stage的任务都执行成功了才执行当前stage的任务，或者之前fail的任务有配置了allow_failure: trueon_failure ：只有在之前的流水线任务有至少一次的fail之下才执行当前任务。always：无论之前的stage的流水线的任务状态如何，当前的任务都会触发。never：不运行当前任务manual：流水线手动触发,点击play，如下图 tags这个是设定Gitlab 在执行脚本时使用哪个runner 注意事项:配置时有些关键字比如workflow，rules什么的会显示报错 XXX config conatins unknown keys. 这个是因为公司的Gitlab版本较旧，Gitlab 12.5之后才支持这些配置。 实践项目背景：子项目，依赖于360kuai仓库，每次编译需要拉取该仓库代码然后进行编译，之后将打包后的文件cp到360kuai的public目录下对应的该仓库的打包文件目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445stages: - compileimage: xxx/node-git:0.0.1variables: # GIT_SUBMODULE_STRATEGY: normal NPM_CONFIG_CACHE: '$CI_PROJECT_DIR/.npm'cache: key: files: - package-lock.json paths: - $&#123;NPM_CONFIG_CACHE&#125;compile: stage: compile only: refs: - merge_requests variables: - $TARGET_BRANCH_NAME == \"master\" script: - ls - rm -rf 360kuai - git submodule update --init --recursive --remote --depth=1 - npm ci --prefer-offline - npm run compile after_script: - ls - rm -rf 360kuai - git clone -b xxx/360kuai.git - git config --global user.email \"xxx\" - git config --global user.name \"xxx\" - cd 360kuai # - git checkout master - cp -r ../public/static/css/supmodule public/static/css - cp -r ../public/static/js/supmodule public/static/js - cp -r ../public/static/img/supmodule public/static/img - git status - git add . - git commit --author=\"xxx &lt;xxx@360&gt;\" -m \"更新\" - git log -1 # - git push","categories":[],"tags":[{"name":"cicd","slug":"cicd","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/cicd/"}]},{"title":"webpack打包产物优化","slug":"webpack打包产物优化","date":"2023-02-15T09:23:18.000Z","updated":"2023-04-18T06:44:34.818Z","comments":true,"path":"2023/02/15/webpack打包产物优化/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/02/15/webpack打包产物优化/","excerpt":"","text":"体积更小 合理分包，不重复加载 加载速度更快 减少体积开启tree shaking 什么是tree shaking？他会在打包过程中通过静态分析模块之间的依赖关系从而确定哪些模块导出/引入的值没有被使用，从而将它删除，Webpack 4生产环境已经默认开启了这个功能，无需其他配置。 减少Babel编译后的产物体积Babel 为编译的每个文件都插入了辅助代码，使代码体积过大，你可以将这些辅助代码作为一个独立模块，来避免重复引入。@babel/plugin-transform-runtime的作用: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用 按需加载使用import方式懒加载组件 1234567// index.jssetTimeout(() =&gt; &#123; // 直接使用import导入即可，这样加载的模块，相当于一个独立的chunk存在 import('./common/dynamicData.js').then(res =&gt; &#123; console.log(res.default.msg); &#125;)&#125;, 1000) 提取公共代码在optimization中配置splitChunks属性，设置cacheGroups分组，一般分为两个组：verdors（用于提取第三方库）和common（用于提取自定义的公共模块）针对第三方库，几乎不会改变，提取出来后，改动业务代码不会动到第三方库的打包文件，这样，就能命中缓存，加快加载速度针对公共模块，只用加载一次，就可以在多个模块中使用 12345678910111213141516171819202122232425// webpack.prod.js optimization: &#123; splitChunks: &#123; chunks: 'all', // 表示要分割的chunk类型：initial只处理同步的; async只处理异步的；all都处理 // 缓存分组 cacheGroups: &#123; // 第三方模块 verdors: &#123; name: 'verdor', // chunk名称 test: /node_modules/, // 设置命中目录规则 priority: 1, // 优先级，数值越大，优先级越高 minSize: 0, // 小于这个大小的文件，不分割 minChunks: 1 // 最少复用几次，这里意思是只要用过一次就分割出来 &#125;, // 公共模块 common: &#123; name: 'common', minChunks: 2, priority: 0, minSize: 0, minChunks: 2 // 只要引用过2次，就分割成公共代码 &#125; &#125; &#125; &#125; npm包都拆出来了，这么多并发请求量会有影响吗：开启http2的时候没影响拆分的越多越好吗？拆分的越多的话会失去代码压缩的优势，因为会生成更多的webpack样板代码,但是不一定会影响加载总时间，在http2下可能会比只有一个文件更快 基于路由的动态加载（React 独占）1React.lazy(() =&gt; import('./mobile/app')) 忽略某些库不需要的模块比如国际化项目所有地区语言包都会与核心库一起打包，如果我们只要少数几种语言，可以使用IgnorePlugin忽略掉一些地区语言包, http请求优化 小图片base64编码通过设置url-loader的阀值来控制，小于阀值的图片使用base64编码，以此来减少http请求 使用 CDN 加速在输出文件配置中将CDN路径添加至publicPath中（针对js和css文件）；针对图片，也可以在loader的配置中添加publicPath 1234567891011121314151617181920212223242526 output: &#123; // filename: 'bundle.[chunkhash].js', // 输出文件名，一般要加上hash filename: '[name].[contenthash:8].js', path: distPath, // 输出目录 publicPath: 'http://cdn.xxx.com' &#125;,// 或者是将图片放到cdn中module: &#123; rules: [ &#123; test: /\\.(jpg|png|jpeg|gif)$/, use: &#123; loader:'url-loader', options: &#123; limit: 8 * 1024, //限制 8kb 以下使用base64 esMoudle: false, name: '[name]-[hash:10].[ext]', // 打包到/images目录下 // outputPath: 'images', // 有了publicPath，会自动忽略outputPath，这是针对放在静态资源服务器上的目录 publicPath: 'http://cdn.xxx.com' &#125; &#125; &#125; ]&#125; 充分利用缓存bundle 加 hash 值给产出的文件增加hash值，当内容没有变化时，生成的文件名将不会变化，浏览器就会应用缓存，从而提升加载速度将来开发时我们对静态资源会使用缓存来优化，这样浏览器第二次请求资源就能读取缓存了，速度很快。但是这样的话就会有一个问题, 如果不设置hash:因为前后输出的文件名是一样的，一旦将来发布新版本，因为文件名没有变化导致浏览器会直接读取缓存，不会加载新资源，项目也就没法更新了。 在360是通过替换资源前面的链接放一个hash值来实现的。hash有三种： hash（webpack4 是 hash） 每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。 chunkhash chunkhash根据不同的入口文件(entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。当某个文件内容发生变动时，再次执行打包，只有该文件以及依赖该文件的文件的打包结果 hash 值会发生改变。比如：在 index.js 中引用了 index.css ，打包后他们属于一个模块，hash值也是一样的。当JS文件变化的时候，css文件的hash也会变化 contenthash 根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。在生产环境下，我们对 output 中打包的文件名一般采用 chunkhash，对于 css 等样式文件，采用 contenthash，这样可以使得各个模块最小范围的改变打包 hash 值。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"深入react hooks","slug":"hooks","date":"2023-01-21T15:02:53.000Z","updated":"2023-04-19T05:41:33.765Z","comments":true,"path":"2023/01/21/hooks/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2023/01/21/hooks/","excerpt":"","text":"为什么会出现hooks? 类组件逐渐被函数式组件完全取代 函数式组件捕获了渲染所用的值。 函数组件更加符合设计理念、也更有利于逻辑拆分和复用 相比类组件，函数组件编写更轻便，生成的代码也更少hooks是完全为函数组件设计的，它能让函数组件拥有类组件的能力，并且保留轻量、优雅的特性。探讨原理之前先看看如下几个问题？ 1 在无状态组件每一次函数上下文执行的时候，react用什么方式记录了hooks的状态？ 2 多个react-hooks用什么来记录每一个hooks的顺序的 ？ 换个问法！为什么不能条件语句中，声明hooks? hooks声明为什么在组件的最顶部？ 3 function函数组件中的useState，和 class类组件 setState有什么区别？ 4 react 是怎么捕获到hooks的执行上下文，是在函数组件内部的？ 5 useEffect,useMemo 中，为什么useRef不需要依赖注入，就能访问到最新的改变值？ 6 useMemo是怎么对值做缓存的？如何应用它优化性能？ 7 为什么两次传入useState的值相同，函数组件不更新? function组件和class组件本质的区别首先回顾一下function组件和class组件的区别 12345678910111213141516171819202122232425262728293031323334353637// class组件class Index extends React.Component&lt;any,any&gt;&#123; constructor(props)&#123; super(props) this.state=&#123; number:0 &#125; &#125; handerClick=()=&gt;&#123; for(let i = 0 ;i&lt;5;i++)&#123; setTimeout(()=&gt;&#123; this.setState(&#123; number:this.state.number+1 &#125;) console.log(this.state.number) // 12345 &#125;,1000) &#125; &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123; this.handerClick &#125; &gt;num++&lt;/button&gt; &lt;/div&gt; &#125;&#125;// 函数组件function Index()&#123; const [ num ,setNumber ] = React.useState(0) const handerClick=()=&gt;&#123; for(let i=0; i&lt;5;i++ )&#123; setTimeout(() =&gt; &#123; setNumber(num+1) console.log(num) // 00000 &#125;, 1000) &#125; &#125; return &lt;button onClick=&#123; handerClick &#125; &gt;&#123; num &#125;&lt;/button&gt;&#125; 为什么会产生两种不一样的结果？第一个类组件中，由于执行上setState没有在react正常的函数执行上下文上执行，而是setTimeout中执行的，批量更新条件被破坏。所以可以直接获取到变化后的state。 这里的批处理条件是啥？ 【React的更新机制】 生命周期函数和合成事件中： 无论调用多少次setState，都不会立即执行更新。而是将要更新的state存入’_pendingStateQuene’,将要更新的组件存入’dirtyComponent’; 当根组件didMount后，批处理机制更新为false。此时再取出’_pendingStateQuene’和’dirtyComponent’中的state和组件进行合并更新； 原生事件和异步代码中： 原生事件不会触发react的批处理机制，因而调用setState会直接更新； 异步代码中调用setState，由于js的异步处理机制，异步代码会暂存，等待同步代码执行完毕再执行，此时react的批处理机制已经结束，因而直接更新 在解释react-hooks原理的之前，我们要加深理解一下， 函数组件和类组件到底有什么区别函数式组件捕获了渲染所使用的值*，并且我们还能进一步意识到：函数组件真正将数据和渲染紧紧的绑定到一起了。React有一个经典公式：ui=f(data),即同样的输入必定有同样的 结果，函数式组件捕获了渲染时所用的值，因此组件每一次渲染都会有自己的props和state。每一次渲染都会有 自己的事件处理函数，而这里每次渲染都有独立的 state 上下文 为什么会出现hooks？ 对于class组件，我们只需要实例化一次，实例中保存了组件的state等状态。对于每一次更新只需要调用render方法就可以。但是在function组件中，每一次更新都是一次新的函数执行,为了保存一些状态,执行一些副作用钩子,react-hooks应运而生，去帮助记录组件的状态，处理一些额外的副作用。 一原理概念Hooks链表无论是初次挂载还是更新，每调用一次hooks函数，都会产生一个hook对象与之对应。以下是hook对象的结构。 产生的hook对象依次排列，形成链表存储到fiber.memoizedState上。在这个过程中，有个十分重要的指针：workInProgressHook，它通过记录当前生成（更新）的hook对象，可以间接反映在组件中当前调用到哪个hook函数了。每调用一次hook函数，就将这个指针的指向移到该hook函数产生的hook对象上。例如： 那么构建hook链表的过程，可以概括为下面这样调用useState(‘A’)： 调用useEffect： memorizedStatememorizedState 就是保存 hooks 数据的地方。它是一个通过 next 串联的链表。与我们调用的hooks是按照调用hooks的顺序对应起来的。 这就是 hooks 存取数据的地方，执行的时候各自在自己的那个 memorizedState 上存取数据，完成各种逻辑。 这个 memorizedState 链表是什么时候创建的呢?好问题，确实有个链表创建的过程，也就是 mountXxx。链表只需要创建一次（此时会调用ountWorkInProgressHook），后面只需要 update（此时会调用updateWorkInProgressHook）。比如第一次调用 useState 会执行 mountState，后面再调用 useState 会执行 updateState。 创建 memorizedState 链表的过程mountXxx 是创建 memorizedState 链表的过程，每个 hooks api 都是这样的： 其中mountXXX的过程就是创建对应的 memorizedState 对象，然后用 next 串联起来。 useRef每个 useXxx 的 hooks 都有 mountXxx 和 updateXxx 两个阶段，比如 ref 就是 mountRef 和 updateRef。 12345useRef&lt;T&gt;(initialValue: T): &#123;|current: T|&#125; &#123; currentHookNameInDev = 'useRef'; mountHookTypesDev(); return mountRef(initialValue); &#125; 其中：mountWorkInProgressHook ：创建并返回 memorizedState 链表updateWorkInProgressHook：更新。 Object.freeze vs Object.sealObject.seal:只要是可写的，就可以更改它们的值。 useRef的原理在memorizedState上挂载了有 current 属性的对象，冻结了一下，后面 update 的时候，没有做任何处理，直接返回这个对象。所以：useRef 可以保存一个数据的引用，这个引用不可变。 useRef跟直接在组件文件顶层定义一个对象的区别前者在组件卸载的时候会释放，后者不会，当从组件A切换到组件B的时候假如import 组件A这一句还在，那么后者占用的内存依旧存在，原因是：ES6 module 每个模块的作用域都是独立的，不属于全局作用域切换到组件B之后，组件A的引用还在，它所形成的局部作用域并未被销毁。 那如果在函数组件内部定义一个变量呢？这样的每次function重新执行的时候它都会重新创建一次，它的引用一直都会变化，相比之下 useRef是不会的。 useCallback useCallback的原理useCallback 在 memorizedState 上放了一个数组，第一个元素是传入的回调函数，第二个是传入的依赖。更新的时候把之前的那个 memorizedState 取出来，和新传入的 deps 做下对比，如果没变，那就返回之前的回调函数，也就是 prevState[0]。 如果变了，那就创建一个新的数组，第一个元素是传入的回调函数，第二个是传入的 deps。 所以，useCallback 的功能也就呼之欲出了：useCallback 可以实现函数的缓存，如果 deps 没变就不会创建新的，否则才会返回新传入的函数 useMemo跟useCallback类似，只是函数变成值。useMemo 也在 memorizedState 上放了个数组，第一个元素是传入函数的执行结果，第二个元素是依赖。更新的时候也是取出之前的 memorizedState，和新传入的 deps 做下对比，如果没变，就返回之前的值，也就是 prevState[0]。 如果变了，创建一个新的数组放在 memorizedState，第一个元素是新传入函数的执行结果，第二个元素是依赖。 自定义hooks其实就是个函数调用，没啥神奇的，我们可以把上面的 hooks 放到 xxx 函数里，然后在 function 组件里调用，对应的 hook 链表是一样的。 因此自定义hooks在不同的组件之间调用不可能共享state这些。 useState跟useEffect的原理本质上就是闭包加上数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const MyReact = (function() &#123; let hooks = [], currentHook = 0 // hooks数组, 和一个iterator! return &#123; // 注意这里的render相当于ReactDOM的render而不是rerender!所以要复位 render(Component) &#123; // rerender是不会重新执行组件的 const Comp = Component() // 运行 effects Comp.render() currentHook = 0 // 复位，为下一次render做准备 return Comp &#125;, // 注意这里只是callback不会每次rerender的时候运行，useEffect还是会的， // 所以每次的depArray都是当前依赖最新的值 useEffect(callback, depArray) &#123; const hasNoDeps = !depArray // 闭包变量来啦，它记录的是初始化或者上一次依赖变化时候依赖的值 const deps = hooks[currentHook] // type: array | undefined // console.log('deps::: ', deps,depArray); const hasChangedDeps = deps ? !depArray.every((el, i) =&gt; el === deps[i]) : true // 如果是初始化或者是依赖变了 执行回调函数 if (hasNoDeps || hasChangedDeps) &#123; callback() hooks[currentHook] = depArray &#125; currentHook++ // 本hook运行结束 &#125;, useState(initialValue) &#123; // 上一次调用useState currentHook++了，所以第二调用的时候，往hooks里push新的[0] -&gt; [0,'foo'] // hooks[currentHook] = hooks[currentHook] || initialValue // type: any // currentHook++不能放在这里只能放在最后一行，因为如果放在这里就是：hooks[0]=initvalue 但是返回的却是[hooks[1]] hooks[currentHook]=initialValue const setStateHookIndex = currentHook // 给setState的闭包准备的变量!因为这里的useState只执行一次，所以这里的 // setStateHookIndex永远等于该useState的值在hooks中对应的位置，否则的话每次render的时候currentHook都会变化，导致setState修改错位置 const setState = newState =&gt; &#123; console.log('newState::: ', setStateHookIndex,newState,currentHook,hooks); return (hooks[setStateHookIndex] = newState) &#125; // 调用useState第一次：[0] 调用第二次 [0,'foo] console.log(hooks,currentHook) // 注意这里是currentHook++而不是++currentHook,所以第一次currentHook++=0 return [hooks[currentHook++], setState] &#125; &#125; &#125;)() function Counter() &#123; const [count, setCount] = MyReact.useState(0) const [text, setText] = MyReact.useState('foo') // 第二个 state hook! // MyReact.useEffect(() =&gt; &#123; // console.log('effect', count, text) // &#125;, [count, text]) return &#123; click: () =&gt; setCount(count + 1), type: txt =&gt; setText(txt), noop: () =&gt; setCount(count), render:()=&gt;&#123;&#125; // render: () =&gt; console.log('render', &#123; count, text &#125;) &#125; &#125; let App App = MyReact.render(Counter) // effect 0 foo // render &#123;count: 0, text: 'foo'&#125; App.click() App = MyReact.render(Counter) // effect 1 foo // render &#123;count: 1, text: 'foo'&#125; App.type('bar') // App.type('ss') // App = MyReact.render(Counter) // // effect 1 bar // // render &#123;count: 1, text: 'bar'&#125; // App.noop() // App = MyReact.render(Counter) // // // no effect run // // render &#123;count: 1, text: 'bar'&#125; // App.click() // App = MyReact.render(Counter) 总结： 以下的私有闭包变量就是说内层函数变量 它相当于这个内层函数的私有变量，多次内层函数调用，每次的私有变量相互独立。 闭包套闭包，第一个闭包记住hooks们要用到的状态，存放在hooks数组中，以避免每次rerender之后丢失，这里的hooks数组按照调用useEffect useState等钩子的顺序存放state或者是useEffect的依赖项的值 useState中利用私有闭包变量记住自己在hooks数组中的位置，然后每次更新的时候用这个闭包变量作为索引去找到自己在数组中的位置然后更新 useeffect中利用私有闭包变量记住自己的依赖项的值，每次更新的时候调用一次useEffect，注意是调用useEffect而不是它的回调函数，然后比较一下最新的依赖的值跟之前的依赖项的值，如果不一样就更新闭包变量记录的当前依赖项的值以供下次使用，并且执行回调函数。 总结React 支持 class 和 function 两种形式的组件，class 支持 state 属性和生命周期方法，而 function 组件也通过 hooks api 实现了类似的功能。fiber 架构是 React 在 16 以后引入的，之前是 jsx -&gt; render function -&gt; vdom 然后直接递归渲染 vdom，现在则是多了一步 vdom 转 fiber 的 reconcile，在 reconcile 的过程中创建 dom 和做 diff 并打上增删改的 effectTag，然后一次性 commit。这个 reconcile 是可被打断的，可以调度，也就是 fiber 的 schedule。hooks 的实现就是基于 fiber 的，会在 fiber 节点上放一个链表，每个节点的 memorizedState 属性上存放了对应的数据，然后不同的 hooks api 使用对应的数据来完成不同的功能。其中这里memorizedState链表的维护根据是否是初次渲染分为两个阶段：初次渲染为mounted阶段，后续为update阶段mounted 阶段：我们来总结一下初始化阶段,react-hooks做的事情，在一个函数组件第一次渲染执行上下文过程中，每个react-hooks执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上，然后react-hooks上的状态，绑定在当前hooks对象的memoizedState属性上。对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树构建完成，再执行每个 effect 副作用钩子。update阶段：在组件更新时，会在建好的hooks链表上用updateWorkInProgressHook取出之前保存的hooks对象做对应的操作，同时新的hook对象也能基于它创建，最后更新完成。 常见问题为什么不能将hooks放在条件语句在组件第一次渲染的时候，为每个hooks都创建了一个对象 1234567type Hook = &#123; memoizedState: any, baseState: any, baseUpdate: Update&lt;any, any&gt; | null, queue: UpdateQueue&lt;any, any&gt; | null, next: Hook | null,&#125;; 最终形成了一个链表 memoizedState属性就是用来存储组件上一次更新后的 state,next指向下一个hook对象。在组件更新的过程中，hooks函数执行的顺序是不变的,如果放到条件语句中可能会导致顺序错乱，导致当前hooks拿到的不是自己对应的Hook对象。 为什么useState useEffect这里要使用闭包首先回顾一下闭包的特性 1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收 如果这里这样写useState: 12345678useState(initialValue) &#123; var _val = initialValue // 不使用state()函数 function setState(newVal) &#123; _val = newVal &#125; return [_val, setState] // 直接对外暴露_val &#125; 那么每次rerender的时候都会走一遍： 1var _val = initialValue 这样的话每次rerender之后，state的值都变成初始值了，这就是为什么要用到闭包变量hooks的原理 闭包陷阱回顾闭包闭包是一个特殊的对象它由两部分组成，执行上下文A以及在A中创建的函数B。当B执行时，如果访问了A中的变量对象，那么闭包就会产生。因此闭包其实不局限于我们常见的这种形式：会转换成：也就是这样也会产生闭包 我们将上面闭包定义的A，B用本例中的名称替换一下：自执行函数AppModule以及在AppModule中创建的函数App。当App在render 中执行时，访问了AppModule中的变量对象(定义了变量Counter)，那么闭包就会产生。根据闭包的生成条件与实践场景，我们会发 现，模块中，非常容易生成闭包,ES6 module 每个模块的作用域都是独立的，不属于全局作用域 .每一个JS模块都可以认为是一个独 立的作用域，当代码执行时，该词法作用域创建执行上下文，如果在模块内部，创建了可供外部引用访问 的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了该JS模块内部的其他变量，闭包就会产生。 闭包陷阱一 123456789101112131415161718192021import React, &#123; useEffect, useState &#125; from \"react\";import ReactDOM from \"react-dom\";function App() &#123; const [count, setCount] = useState(0); const clickCb = () =&gt; &#123; // 这里拿到的count始终是初始值 setCount(count + 1); &#125;; useEffect(() =&gt; &#123; document.addEventListener(\"click\", clickCb); return () =&gt; document.removeEventListener(\"click\", clickCb); &#125;, []); return ( &lt;&gt; &lt;button&gt;+1&lt;/button&gt; &lt;span&gt;count:&#123;count&#125;&lt;/span&gt; &lt;/&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 这里的闭包陷阱所说的闭包实际上是事件监听器的回调函数所形成的闭包，而闭包最大的特点，就是它可以“记住”诞生的环境，因为useEffect的回调只执行了一次，这个回调函数作用域中的闭包永远引用着App函数第一次执行时创建的作用域。 怎么解决方式一：useLayoutEffect + useRef 123456789101112131415161718192021222324function App() &#123; const [count, setCount] = useState(0); const countRef = useRef(0); const handleBtnClick = () =&gt; &#123; setCount(count + 1); &#125;; const clickCb = () =&gt; &#123; console.log(\"clickCb countRef.current\", countRef.current); &#125;; useLayoutEffect(() =&gt; &#123; // + countRef.current = count; // + 这里是每当count改变自动同步更新countRef的值 &#125;, [count]); // + useEffect(() =&gt; &#123; document.addEventListener(\"click\", clickCb); return () =&gt; document.removeEventListener(\"click\", clickCb); &#125;, []); return ( &lt;&gt; &lt;button onClick=&#123;handleBtnClick&#125;&gt;+1&lt;/button&gt; &lt;span&gt;count:&#123;count&#125;&lt;/span&gt; &lt;/&gt; );&#125; 为什么不是useEFfect?useEffect的执行时机 vs useEffectLayoutuseEffect 在每轮渲染之后执行useEffect确实相当于异步执行，它是深度优先，且从最底层的子组件开始执行，冒泡到最父级组件，但是也不是完全的异步。每个组件内的useEffect也是按顺执行。useLayoutEffect类似于useEffect，深度优先，但执行优先级高于useEffect，而且没有阻塞dom render 。useLayoutEffect的是在渲染器执行当前渲染界面任务时，同步执行。在当前一轮的Reconciler任务调度过程中，在渲染器执行完当前任务后，才会异步调用useEffect。useLayoutEffect先于useEffect执行，并且子组件优先执行。如果是useEffect的话，还没执行它就触发了click事件打印了值 方式二：直接在外面更新useRef的值 123456789101112131415161718192021222324export function useLatest(value) &#123; const ref = useRef(value); ref.current = value; return ref;&#125;function App() &#123; const [count, setCount] = useState(0); const latestCountRef = useLatest(count); const handleBtnClick = () =&gt; setCount(count + 1); const clickCb = () =&gt; &#123; console.log(\"clickCb latestCountRef\", latestCountRef.current); &#125;; useEffect(() =&gt; &#123; document.addEventListener(\"click\", clickCb); return () =&gt; document.removeEventListener(\"click\", clickCb); &#125;, []); return ( &lt;&gt; &lt;button onClick=&#123;handleBtnClick&#125;&gt;+1&lt;/button&gt; &lt;span&gt;count:&#123;count&#125;&lt;/span&gt; &lt;/&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 为什么是useRef?countRef对象和函数App多次重新render时操作的countRef对象是同一个内存地址(useRef在hook.memoizedState保存着)，所以是可以获取到预期的值的。方式三：直接修改state为对象，然后更改state的时候： 方式四：增加依赖项：count让回调函数重新执行 useEffect ** 闭包陷阱二 **代码描述：一个卡片上有多个下载按钮，点击后请求文件地址。问题描述：测试时发现问题：如果连续点击 a 和 b 按钮，当 b 下载结束时，a 按钮会被重置为”下载中”。 原因：总结其实就是handle click中延迟3秒之后那里拿到的并不是最 新的state值，所以每次都设置了错误的state。两次按钮点击 产生了 4 次 setState，因此导致 4 次 re-render，算上初始 化的 render，App 共执行了 5 次。为什么？回顾我们之前所说的闭包理念，这里用到useState实际上也是形成了一个闭包，这里的useState对应我们之前所说的JS模块，而且我们恰巧在另一个函数内部用到了他提供的state。实际上看似是bug的问题是符合React的设计理念的, React有一个经典公式：ui=f(data),即同样的输入必定有同样的结果，函数式组件捕获了渲染时所用的值，因此组件每一次渲染都会有自己的props和state。每一次渲染都会有自己的事件处理函数，而这里每次渲染都有独立的 state 上下文。 Hooks 是否因为在渲染中创建函数而变慢？不会。在现代浏览器中，除了在极端情况下，闭包的原始性能与类相比没有显着差异。 此外，考虑到 Hooks 的设计在以下几个方面更高效： 挂钩避免了类所需的大量开销，例如在构造函数中创建类实例和绑定事件处理程序的成本。 使用 Hooks 的惯用代码不需要在使用高阶组件、渲染道具和上下文的代码库中普遍存在的深层组件树嵌套。使用更小的组件树，React 要做的工作更少。 如何测量 DOM 节点？12345678910function MeasureExample() &#123; const [height, setHeight] = useState(0); const measuredRef = useCallback(node =&gt; &#123; if (node !== null) &#123; setHeight(node.getBoundingClientRect().height); &#125; &#125;, []); return ( &lt;&gt; &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;/h1&gt; &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/h2&gt; &lt;/&gt; );&#125; 参考 https://zhuanlan.zhihu.com/p/66923924 https://www.51cto.com/article/704138.html https://cooperhu.com/2020/09/03/useEffect-componentDidMount/","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/react/"}]},{"title":"线上如何像本地一样debug","slug":"线上如何像本地一样debug","date":"2022-09-23T14:54:58.000Z","updated":"2023-04-18T06:44:35.095Z","comments":true,"path":"2022/09/23/线上如何像本地一样debug/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/09/23/线上如何像本地一样debug/","excerpt":"","text":"我之前犯了一个愚蠢的错误：比如我想像在本地debug一样debug线上的页面，直接写上代理如下： 1https://www.360kuai.com http://dev.360kuai.com:57824 但是这样跟 1https://www.360kuai.com www.baidu.com 有啥区别？ 原本的方案： 123456789101112131415161718192021222324252627282930313233343536373839404142// devServerwriteToDisk(curPath) &#123;return onlineDebug ? true : ...&#125;// webpack plugin 这里虽然有现成的配置可用 但是不知道为什么无论怎么配置 总是会在原来的基础上生成一个新的sourcemappingUrl 两个URL并存根本没用const ReplacePlugin=require('./replace_sourcemap_url');new ReplacePlugin()// replace_sourcemap_url 把生成的sourceMappingURL改为本地的地址const RawSource = require('webpack-sources').RawSource;const path = require('path');const fs=require('fs');const pathPrefix = `file://$&#123;path.resolve(__dirname, '../public/static')&#125;`;module.exports = class ReplacePlugin &#123; apply(compiler) &#123; compiler.hooks.emit.tap('ReplacePlugin', (compilation, cb) =&gt; &#123; const reg = /sourceMappingURL=[^/]+.map$/; const files = compilation.getAssets(); for (const file of files) &#123; try &#123; if (/.js$/.test(file.name)) &#123; const _path = `sourceMappingURL=$&#123;pathPrefix&#125;/$&#123;file.name&#125;.map`; if(pathPrefix.includes('jenkins/workspace'))&#123; break; &#125; const content=file.source.source(); compilation.updateAsset( file.name, new RawSource(content.replace(reg, _path)) ); &#125; &#125; catch (err) &#123; console.log(err, 'err'); &#125; &#125; &#125;); &#125;&#125;; 在上面的代码中，我把线上源文件的sourceMappingURL改成了本地的map文件所在的地址，以为这样既能做到利用了source map功能又不会让别人看到，但实际上是，这样做只能对自己有用，因为路径都是自己电脑上的，对别的同事就没用了。虽然但是，可以把路径改成仅仅内网可访问的吧：总结就是： sourcemap上传到仅仅内网可访问的cdn 生成的sourcemapurl加上publicpath为该cdn但是这样的话怎么能在本地边改，边同步线上呢？writetodisk也没意义了。。。想边改边看还是得靠whistle。。。或者说sourceMap的映射修改应该放在浏览器发起请求的时候而不是打包的时候。","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/debug/"}]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2022-09-10T12:18:35.000Z","updated":"2023-04-23T05:44:20.364Z","comments":true,"path":"2022/09/10/vue响应式原理/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/09/10/vue响应式原理/","excerpt":"","text":"概念 Dep 管理依赖的，每一个依赖就是一个观察者，当观察的目标变化的时候就会做出反应，扮演观察目标的角色，每一个数据都会有Dep类实例，它部有个订阅者队列，保存着依赖本数据的观察者，当本数据变更时，调用dep.notify()通知观察者 Dep是一个简单的订阅发布模式的实现。Dep类是一个可观察对象，可以有多个指令订阅它。当它的notify()方法被调用时，所有订阅者都会被通知。在Vue.js中，每个数据属性都有一个Dep实例，当数据属性被修改时，会通知Dep实例，然后Dep实例会通知所有订阅它的指令更新视图。 123456789101112131415161718192021222324252627// 当本数据变更时，调用dep.notify()通知观察者 - Watcher：扮演观察者的角色，进行观察者函数的包装处理。如render()函数，会被进行包装成一个Watcher实例 - Observer：辅助的可观测类，数组/对象通过它的转化，可成为可观测数据let uid = 0; class Dep &#123; static target = null; // 巧妙的设计！ constructor() &#123; this.id = uid++; // 每一个数据都会有Dep类实例，它内部有个subs队列，subs就是subscribers的意思，保存着依赖本数据的观察者 this.subs = []; &#125; addSub(sub) &#123; // 其中存放的是多个watcher this.subs.push(sub); &#125; removeSub(sub) &#123; this.subs.$remove(sub); &#125; depend() &#123; // 由于JavaScript是单线程模型，所以虽然有多个观察者函数，但是一个时刻内，就只会有一个观察者函数在执行，那么此刻正在执行的那个观察者函数，所对应的Watcher实例，便会被赋给Dep.target这一类变量，从而只要访问Dep.target就能知道当前的观察者是谁。 在后续的依赖收集工作里，getter里会调用dep.depend()，而setter里则会调用dep.notify() Dep.target.addDep(this); &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125; &#125;&#125; Observer：辅助的可观测类，数组/象通过它的转化，可成为可观查数据。 12345678910111213141516171819202122232425//创建一个观察值类,观察data中的数据变化class Observer &#123; constructor(data) &#123; //调用函数 this.walk(data) //实现$set需要重新new一个Dep实例 this.dep = new Dep() //在data中新增一个__ob__属性,设置该属性不可遍历 Object.defineProperty(data,'__ob__',&#123; value:this, //不可遍历 enumerable:false, configurable:true, writable:true &#125;) &#125; //walk函数 walk(data) &#123; let keys = Object.keys(data) for(let i = 0; i &lt; keys.length; i++)&#123; //代用抽离出去的函数 defineReactive(data,keys[i],data[keys[i]]) &#125; &#125;&#125; Watcher扮演观察者的角色，进行观察者函数的包装处理。如render()函数，会被进行包装成一个Watcher实例 一个组件里可以有多个Watcher类实例,同时每个组件实例都有相应的watcher实例 - 渲染组件的过程，会把属性记录为依赖 - 当我们操纵一个数据时，依赖项的setter会被调用，从而通知watcher重新计算，从而致使与之相关联的组件得以更新 1234567891011// 在初始准备工作里，会将当前Watcher实例赋给Dep.targetfunction Watcher(vm, node, name, type) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.type = type; // 当某个数据更新时，由于进行了setter拦截，所以会对该数据的dep.subs这一观察者队列里的watchers进行通知，从而执行watcher.update()方法 this.update(); Dep.target = null;&#125; dep与watcher之间的关系Dep是一个依赖收集器，它用于收集依赖于数据的所有Watcher实例。当数据发生变化时，Dep会通知所有Watcher实例进行更新。而Watcher则是一个观察者，它会观察数据的变化，并在数据发生变化时执行回调函数1。 具体来说，当一个组件被渲染时，Vue.js会为这个组件创建一个Watcher实例。这个Watcher实例会观察组件中所有响应式数据的变化，并将自己添加到这些数据的Dep中。当数据发生变化时，Dep会通知所有Watcher实例进行更新，从而更新组件中的DOM1。 Observer：辅助的可观测类，数组/对象通过它的转化，可成为可观查数据Observer类的实例被挂载在ob属性上，提供后续观测数据使用，以及避免被重复实例化 对象以及数组的监测 如果value是个对象，就遍历对象（walk()）把每一项数据都变为可观测数据（调用defineReactive方法处理） - 如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，以便能够对元素还是数组的情况进行处理 123456789walk(obj) &#123; var keys = Object.keys(obj) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; this.convert(keys[i], obj[keys[i]]) &#125; &#125;convert(key, val) &#123; defineReactive(this.value, key, val) &#125; 123456789101112131415161718192021222324252627282930313233const data = &#123; arr: [1, 2, 3]&#125;function defineReactive(obj, key, val) &#123; const property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return; &#125; const getter = property &amp;&amp; property.get; const setter = property &amp;&amp; property.set; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; console.log('取值过程被拦截了'); const value = getter ? getter.call(obj) : val; return value; &#125;, set(newval) &#123; console.log(`新的值是$&#123;newval&#125;`) if (setter) &#123; setter.call(obj, newval); &#125; else &#123; val = newval; &#125; &#125; &#125;)&#125;defineReactive(data, 'arr', data.arr);data.arr.reverse(); // 取值过程被拦截了data.arr = [4, 5, 6] // 新的值是4,5,6 defineProperty为什么不能监测到数组？除了对arr重新赋值一个数组外，其他的操作都不会被setter检测到而是被get拦截了因此对于数组：如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，当调用数组的push()、pop()、shift()、unshift()、splice()、sort()和reverse()等方法时，这些方法会被重写，从而触发视图更新。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue/"}]},{"title":"升级Babel7踩坑","slug":"升级Babel7踩坑","date":"2022-08-23T15:33:43.000Z","updated":"2023-04-18T06:44:35.114Z","comments":true,"path":"2022/08/23/升级Babel7踩坑/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/08/23/升级Babel7踩坑/","excerpt":"","text":"总结 npx babel-upgrade --write自动更换依赖中的Babel版本 更换babelrc配置 更换eslint配置 原始配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// .babelrc&#123; \"presets\": [ // 用来在vue中写jsx的 [\"@vue/babel-preset-jsx\"], // @babel/transform-vue-jsx 支持的是Babel6+ [ \"@babel/env\", &#123; \"targets\": &#123; \"chrome\": 52, \"browsers\": [\"last 2 versions\", \"safari 7\"] &#125;, \"modules\": false, \"useBuiltIns\": \"usage\" // polyfill 由于@babel/polyfill已经快被废弃，该选项依赖babel/polyfill,所以不建议用此选项 &#125; ] ], \"sourceType\": \"unambiguous\", // 项目中有些地方import跟module.exports混用了，webpack2不支持 但是配置了还是无效 \"plugins\": [ [ \"@babel/plugin-transform-runtime\", &#123; \"corejs\": false, // corejs 是一个给低版本的浏览器提供接口的库，如 Promise, map, set 等。设置false不会对polyfill进行处理 如果不是开发js库 常规的业务设置false \"helpers\": true, // 辅助函数是否抽取出来，避免重复 \"regenerator\": true, // 同babel-plugin-transform \"useESModules\": true // 使用 es modules helpers, 减少 commonJS 语法代码 &#125; ], [\"@babel/plugin-syntax-dynamic-import\"], [\"@babel/plugin-transform-modules-commonjs\"], // 解决import跟module.exports混用的问题 [\"@babel/plugin-proposal-nullish-coalescing-operator\"] 坑爹，虽然官方说babel-preset-env支持了 但是其实并不 // As I know so far that babel preset-env won't support stage-x plugin. This // babel/plugin-proposal-nullish-coalescing-operator seems to be at stage-4 // for now which means you have to keep using this as plugin. ], \"comments\": false, \"env\": &#123; \"test\": &#123; \"plugins\": [\"istanbul\"] &#125; &#125;&#125;// eslintrc.js parserOptions: &#123; // eslint7才支持es2020 7.5支持非空运算符 ecmaVersion: 2020, \"sourceType\": \"module\", ecmaFeatures: &#123; experimentalObjectRestSpread: true //jsx: true &#125;, &#125;, 修正版本12345678910111213141516171819202122232425262728&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"targets\": &#123; \"chrome\": 52, \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"modules\": false, &#125; ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", &#123; \"corejs\": &#123; \"version\": 3, \"proposals\": true // 引入所有该版本的提案 注意是提案（建议）不是标准 &#125;, // 关闭其对polyfill的处理 \"helpers\": true, // 辅助函数是否提取 \"regenerator\": true, // 同babel-plugin-transform \"useESModules\": true // 使用 es modules helpers, 减少 commonJS 语法代码 &#125; ] ]&#125; 踩坑1.可选链插件需要升级Babel7才能用。。2.升级的时候如果项目存在stage-xxx 自动升级会安装一堆该阶段的语法插件3.usebuiltIns已经不被推荐了,如果使用它需要结合配置core-js","categories":[],"tags":[{"name":"babel","slug":"babel","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/babel/"}]},{"title":"hello，chrome extension","slug":"extension","date":"2022-08-16T03:23:17.000Z","updated":"2023-04-16T08:55:44.996Z","comments":true,"path":"2022/08/16/extension/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/08/16/extension/","excerpt":"","text":"Chrome Extension 是 Chrome 浏览器的扩展，也就是大家所说的『插件』。由一堆html，js，css组合而成 基本概念 manifest.json （插件配置文件） content script (插入到目标页面中执行的js) background script (在chrome后台中运行的程序，新版本被service worker取代) popup (点击插件图标弹出的页面)manifest.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; \"name\": \"Chrome插件Demo\", \"version\": \"1.0\", \"description\": \"chrome插件Demo。\", \"icons\": &#123; \"16\": \"images/icon.png\", \"48\": \"images/icon.png\", \"128\": \"images/icon.png\" &#125;, \"manifest_version\": 3, // 文件版本 // popup页面配置 \"page_action\": &#123; // 浏览器插件按钮的图标 \"default_icon\": \"images/icon.png\", // 浏览器插件按钮hover显示的文字 \"default_title\": \"React CRX\", // popup页面的路径（根目录为最终build生成的插件包目录） \"default_popup\": \"index.html\" &#125;, // background script配置 \"background\": &#123; // background script路径（根目录为最终build生成的插件包目录） \"service_worker\": \"js/background.js\" &#125;, // content script配置 \"content_scripts\": [ &#123; // 该脚本会在哪些页面地址运行（可以使用正则，&lt;all_urls&gt;表示匹配所有地址） \"matches\": [ \"&lt;all_urls&gt;\" ], // 注入的css，注意不要污染样式 \"css\": [ \"static/css/content.css\" ], // 注入的js \"js\": [ \"static/js/content.js\" ], // 代码注入的时间，可选document_start、document_end、document_idle（默认） \"run_at\": \"document_end\" &#125; ], // 权限申请（需要background发起跨域请求的url也放在这里） \"permissions\": [ \"tabs\", // 根据定制的网页规则，采取相应的措施（例如只在baidu.com启动组件） \"declarativeContent\", // 插件本地存储 \"storage\", // 通知 \"notifications\" ], // 如果向目标页面插入js，需要在这里声明下才能获得执行的权限 \"web_accessible_resources\": [\"insert.js\"]&#125; popup就是一个html页面，它可以有自己的css跟Js,使用之前需要在配置文件中声明一下特性： 可访问绝大部分 API 生命周期短12345\"action\": &#123; \"default_icon\": \"icons/ic_16.png\", \"default_title\": \"Extension Popup\", \"default_popup\": \"html/popup.html\" &#125;, popup与卸载当弹出popup的时候会触发useEffect模拟的mount content scripts描述：content script是驻入到目标页面中执行的js脚本，可以获取目标页面的Dom并进行修改。但是，content script的JavaScript与目标页面是互相隔离的。也就是说，content script与目标页面不会出现互相污染的问题，同时，也不能调用对方的方法。同时也不能获取到目标页面的变量。除此之外，大部分的Chrome API 他都不能调用。只能通过与background或者是popup通信调用。 特性： 生命周期短。 权限和background非常类似，调用的api一样。执行时机：可以指定它的执行时机：123456\"content_scripts\": [ &#123; ... \"run_at\": \"document_start\" &#125; ], 总共有三个取值： document_startstyle样式加载好，dom渲染完成和脚本执行前 document_enddom渲染完成后，即DOMContentLoaded后马上执行 document_idle（默认）在DOMContentLoaded 和 window load之间，具体是什么时刻，要视页面的复杂程度和加载时间，并针对页面加载速度进行了优化。 tips service worker描述：在版本2叫做background js,常驻在浏览器后台运行，没有实际页面，它的生命周期随着浏览器打开而开始，随着浏览器关闭而结束。一般把全局的、需要一直运行的代码（比如监听不定时触发的事件）放在这里。以下摘自官网扩展程序是基于事件的程序，用于修改或增强 Chrome 浏览体验。事件是浏览器触发器，例如导航到新页面、删除书签或关闭选项卡。扩展使用service worker中的脚本监视这些事件，然后根据指定的指令做出反应。 service worker是啥service worker 是一个独立 worker 线程，独立于当前网页进程，有自己独立的 worker context ,service worker 的线程能力基于 webworker 而生，通过 postMessage 和 onMessage 进行线程之间的通信；缓存机制是依赖 cache API 实现的。需要注意的是，service worker不会一直处于激活的状态，除了初次安装，以及接收到网络请求的时候，在Chrome extension中，按照官方描述：正在侦听的事件触发，按照指定的指令做出反应，然后卸载。 特性： 生命周期长：从浏览器页面打开时候开始加载，关闭时终止。 权限大：可以调用几乎可以调用所有的Chrome扩展API（除了devtools）。 无跨域限制：可以跨域访问任何网站而无需要求对方设置CORS。 不能访问dom：worker线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的DOM对象，也无法使用document，window，parent这些对象。 文件限制：work线程无法读取本地文件，既不可以打开本季的文件系统，所加载的脚本，必须来自网络通信机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* eslint-disable no-undef */// 统一消息格式class ChromeMessage &#123; constructor(msg, params) &#123; this.msg = msg; this.params = params; &#125;&#125;// 获取函数的形参个数function getFuncParameters(func) &#123; if (typeof func === 'function') &#123; const match = /[^(]+\\(([^)]*)?\\)/gm.exec(Function.prototype.toString.call(func)); if (match[1]) &#123; const args = match[1].replace(/[^,\\w]*/g, '').split(','); return args.length; &#125; &#125; return 0;&#125;// 监听回调函数const listeners = &#123;&#125;;// 事件分发function dispatchEvent(request, sendResponse) &#123; const &#123; msg &#125; = request; let callBack; Object.keys(listeners).forEach((key) =&gt; &#123; if (key === msg) &#123; callBack = listeners[key]; &#125; &#125;); if (callBack) &#123; const paramSize = getFuncParameters(callBack); callBack(request, sendResponse); return paramSize === 2; &#125; return false;&#125;chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; &#123; const success = dispatchEvent(request, sendResponse); if (!success) &#123; sendResponse(new ChromeMessage('Default Response')); &#125; return true;&#125;);// content scripts 发送和监听消息class ContentClient &#123; listen(msg, callBack) &#123; listeners[msg] = callBack; &#125; sendMessage(message) &#123; return new Promise((resolve) =&gt; &#123; chrome.runtime.sendMessage(message, (res) =&gt; &#123; resolve(res); &#125;); &#125;); &#125;&#125;class popupClient extends ContentClient &#123;&#125;// background 发送和监听消息class BackgroundClient &#123; listen(msg, callBack) &#123; listeners[msg] = callBack; &#125; sendMessage(message) &#123; return new Promise((resolve) =&gt; &#123; chrome.tabs.query(&#123; active: true &#125;, (tabs) =&gt; &#123; chrome.tabs.sendMessage(tabs[0].id, message, (response) =&gt; &#123; resolve(response); &#125;); &#125;); &#125;); &#125;&#125;const contentClient = new ContentClient();const backgroundClient = new BackgroundClient();export &#123; contentClient, backgroundClient, ChromeMessage, popupClient&#125;; 存储机制localStorage优点： 同步，因此更容易使用：var value = localStorage[key] 在 Dev Tools: Resources &gt; Local Storage中支持查看和修改。缺点： 仅存储字符串，因此您需要自己序列化数据，即JSON.stringify 无法从内容脚本访问（或者更确切地说，上下文脚本与页面而不是扩展共享它），因此您需要依靠消息传递将值传递给它们。 在并发执行的扩展页面之间同步 AND 共享，从而导致可能的同步问题。chrome.storage.local优点： 自动序列化与 JSON 兼容的数据，可以存储非字符串，但是不能存储map对象，需要： 123456789// setconst validValue = isMap ? Object.fromEntries(value) : value; chrome.storage[storageType].set(&#123; [key]: validValue &#125;, () =&gt; &#123; resolve(value); &#125;);// get res = isMap ? new Map(Object.entries(res)) : res; resolve(res); 在内容脚本中完全可用。 支持通知更改的事件：chrome.storage.onChanged 经”unlimitedStorage”许可，可以保存任意大量的数据。 有一个很好的默认值内置机制：chrome.storage.local.get({key: defaultValue}, function(value){/…/}); Firefox WebExtensions 和 Edge Extensions 完全支持。缺点： 在开发工具中不可视化；需要调用chrome.storage.local.get(null)以获取所有值或使用类似Storage Area Explorer 的东西。chrome.storage.sync与上面相同，但是：优点： 如果启用了扩展同步，则在已登录的 Chrome 实例之间自动同步。缺点： 数据大小小 实战指南怎么做到热更新？正常的更新流程 1.本地npm run build2.进入扩展程序管理页面，重新加载dist文件3.按下刷新按钮刷新4.回到被脚本注入的页面，刷新资源 热更新的更新流程在 webpack server 和 chrome extension 之间搭建一个 连接，由 webpack server 向 chrome extension 推送编译完成的消息 将bundle写入到磁盘中而不是内存中 12345module.exports = &#123; devServer: &#123; writeToDisk: true, &#125;&#125; 监听reload接口，监听到之后，注册监听编译完成的钩子，在此处发送消息到Chrome extension 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function ReloadServer(app) &#123; app.get('/reload', (req, res, next) =&gt; &#123; // 将 request 转换为一个 SSEStream const sseStream = new SSEStream(req); const compiler = ChromeReloadPlugin.innerCompiler; sseStream.pipe(res); let closed = false; const reloadPlugin = () =&gt; &#123; if (!closed) &#123; // sse不需要双向通讯 sseStream.write( &#123; event: 'compiled successfully', data: &#123; action: 'reload extension and refresh current page' &#125; &#125;, 'utf-8', (err) =&gt; &#123; if (err) &#123; console.error(err); &#125; &#125;, ); setTimeout(() =&gt; &#123; sseStream.unpipe(res); &#125;, 100); &#125; &#125;; compiler.hooks.done.tap( 'chrome reload plugin', reloadPlugin ); res.on('close', () =&gt; &#123; closed = true; sseStream.unpipe(res); &#125;); next(); &#125;);&#125; 其中涉及到一种技术：SSE，这里简单介绍一下，SSE是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新。 Chrome extension监听reload接口，调用Chrome的reload完成更新，同时通知content script更新123456789101112131415161718// background.jsimport &#123; backgroundClient, ChromeMessage, reload &#125; from '../chrome';const eventSource = new EventSource('http://localhost:8080/reload/');eventSource.addEventListener('compiled successfully', () =&gt; &#123; const res = await backgroundClient.sendMessage(new ChromeMessage('refresh page')); if (res) &#123; reload(); &#125;&#125;);// content scriptcontentClient.listen('refresh page', (res, sendResponse) =&gt; &#123; sendResponse('received refresh cmd'); setTimeout(() =&gt; &#123; window.location.reload(); &#125;, 500);&#125;); 常见问题 content script样式污染问题content script能操作目标页面的dom，所以也能生成dom插入到目标页面，可以为生成的dom指定样式文件12345678\"content_scripts\": [ &#123; \"matches\": [\"&lt;all_urls&gt;\"], \"js\": [\"js/contentScripts.js\"], \"css\": [\"css/contentScripts.css\"], \"run_at\": \"document_start\" &#125;] 这里的样式文件并不会与目标页面的样式相互隔绝。怎么解决？使用postcss的插件postcss-plugin-namespace为全局的css生成一个namespace包裹在最外面。 1234const postCssPlugins = [ require('autoprefixer'), require('postcss-plugin-namespace')(`.$&#123;wrapperClassName&#125;`, &#123; ignore: ['#chrome-extension-content-base-element', /^((?!\\.ant-btn).)*$/] &#125;)]; 同时也要为dom元素手动加上此类名 123new webpack.DefinePlugin(&#123; WRAPPER_CLASS_NAME: `'$&#123;wrapperClassName&#125;'` // 防止插件的样式被污染或者是当前页面的样式污染插件的样式 &#125;) 需要注意的是像组件库中的modal等组件，并不能给他的最外层指定类名，但是组件库的样式文件同样会被加上namespace需要在配置的时候ignore掉这一部分类名，手动在样式文件中加上包裹的类名。升级到v3之后background无法监听到异步发送的消息了 1234567891011121314151617181920212223242526272829303132333435363738// content scirptdocument.addEventListener('DOMContentLoaded', () =&gt; &#123; this.listenSetCookieCmd(); this.sendUserPermission();&#125;)// background.js async listenSetPersonalPermissionCmd() &#123; contentClient.listen('get-current-permission', async (res, sendResponse) =&gt; &#123; await storage.set('personalPermission', res.params, true); sendResponse(new ChromeMessage('set personal permission success')); &#125;); &#125;如上 并未响应，猜想是service worker在一段时间没收到消息之后会自动进入休眠怎么解决？// content script async init() &#123; this.setHeartBeat(); // 注意，必须设置了run_at=document_start 此段代码才会生效 document.addEventListener('DOMContentLoaded', () =&gt; &#123; ... setHeartBeat() &#123; setTimeout(() =&gt; &#123; contentClient.sendMessage('ping'); &#125;, 10); &#125; // background.js init()&#123; this.listenPing() &#125; listenPing() &#123; parentClient.listen('ping', ((res, sendResponse) =&gt; &#123; sendResponse('pong'); &#125;)); &#125; 脚本注入 无论是registerScript还是execute Script，他的window跟被注入页面的都是相互独立的window，如果需要更改目标页面的window:const script = document.createElement(‘script’); script.setAttribute(‘type’, ‘text/javascript’); script.setAttribute(‘src’, chrome.runtime.getURL(‘inject.js’)); (document.head || document.documentElement).prepend(script);临时注入的脚本不能阻塞后面的脚本的执行，可能是因为被注入的时候还后面的脚本已经开始parse了 临时插入的脚本，虽然是个本地的脚本但是也需要加载，需要script.onload=xxx,content script是一个standalone的孤立的脚本，它不会等到被插入到页面的这个脚本执行完毕之后再执行 content script与injectjs的通信：postmessage 不能直接执行内联脚本修改window变量，会报错12script.innerHTML = `window.ggconfig=$&#123;JSON.stringify(config)&#125;`;document.body.appendChild(script); 重定向 拦截被注入页面的重定向，html的重定向需要是一个相同的域名如何阻塞当前页面的解析？123var startTime = new Date().getTime() + 2*1000;while (new Date().getTime() &lt; startTime) &#123;&#125; 插入如上耗时代码，但是因为这段代码是直接在主线程执行的，所以如果我在扩展的脚本中加上一个定时器，定时器因为是宏任务，也会被阻塞，想到的方法是让这段定时器代码在web worker中执行，但是chrome extension不支持本地js 作为web worker子进程，折中的方式：new Worker(URL.createObjectURL(new Blob([(${xFunction.toString()})(${json})], { type: ‘text/javascript’ })))但是 web worker貌似不能像父窗口之外的窗口发送postMessage 综上：chrome extension对脚本的限制还是比较多的，如果技术上不可行的话，及时更换产品方案Chrome extension能用来做啥操作cookie强大的chrome.cookiesapi能获取到当前域名下存在的所有的cookie，包括设置了httpOnly的，可以用来对cookie进行快速读取删除等操作。拦截网络请求chrome.webRequest能拦截到ajax请求的各个阶段，并且修改或者是屏蔽请求 屏蔽掉所有发往www.evil.com的请求 1234567chrome.webRequest.onBeforeRequest.addListener( function(details) &#123; return &#123;cancel: details.url.indexOf(\"://www.evil.com/\") != -1&#125;; &#125;, &#123;urls: [\"&lt;all_urls&gt;\"]&#125;, [\"blocking\"]); 其他 向页面注入JS脚本,比如temperMongkey 网页截图 利用chrome.tabsapi 操作当前打开的标签页（整理，搜索,移除等等），比如one tab 操作当前页面的dom,比如划词搜索参考如何实现 chrome extension 的热更新","categories":[],"tags":[{"name":"chromeExtension","slug":"chromeExtension","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/chromeExtension/"}]},{"title":"vue3响应式原理","slug":"响应式原理","date":"2022-05-15T12:52:41.000Z","updated":"2023-04-18T06:44:35.115Z","comments":true,"path":"2022/05/15/响应式原理/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/05/15/响应式原理/","excerpt":"","text":"ProxyVue3 的响应式原理依赖了 Proxy 这个核心 API，通过 Proxy 可以劫持对象的某些操作。 123456789101112131415161718192021222324const obj = &#123; a: 1 &#125;;const p = new Proxy(obj, &#123; get(target, property, receiver) &#123; console.log(\"get\"); return Reflect.get(target, property, receiver); &#125;, set(target, property, value, receiver) &#123; console.log(\"set\"); return Reflect.set(target, property, receiver); &#125;, has(target, prop) &#123; console.log(\"has\"); return Reflect.has(target, prop); &#125;, deleteProperty(target, prop) &#123; console.log(\"deleteProperty\"); return Reflect.deleteProperty(target, prop); &#125;,&#125;);p.a; // 输出 --&gt; getp.a = 2; // 输出 --&gt; set\"a\" in p; // 输出 --&gt; hasdelete p.a; // 输出 --&gt; deleteProperty 如上例子，我们用 Proxy 代理了 Obj 对象的属性访问、属性赋值、in 操作符、delete 的操作，并进行 console.log 输出。 ReflectReflect 是与 Proxy 搭配使用的一个 API，当我们劫持了某些操作时，如果需要再把这些操作反射回去，那么就需要 Reflect 这个 API。 由于我们拦截了对象的操作，所以这些操作该有的功能都丧失了，例如，访问属性 p.a 应该得到 a 属性的值，但此时却不会有任何结果，如果我们还想拥有拦截之前的功能，那我们就需要用 Reflect 反射回去。 12345678910111213141516171819const obj = &#123; a: 1 &#125;;const p = new Proxy(obj, &#123; get(target, property, receiver) &#123; console.log(\"get\"); return Reflect.get(target, property, receiver); &#125;, set(target, property, value, receiver) &#123; console.log(\"set\"); return Reflect.set(target, property, receiver); &#125;, has(target, prop) &#123; console.log(\"has\"); return Reflect.has(target, prop); &#125;, deleteProperty(target, prop) &#123; console.log(\"deleteProperty\"); return Reflect.deleteProperty(target, prop); &#125;,&#125;); 举个例子以下全文我们都会通过这个例子来讲述 Vue3 响应式的原理。 12345678910111213141516&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; // 创建一个响应式对象 const state = reactive(&#123; counter: 1 &#125;); // 立即运行一个函数，当响应式对象的属性发生改变时重新执行。 effect(() =&gt; &#123; document.querySelector(\"#app\").innerHTML = state.counter; &#125;); // 2s 后视图更新 setTimeout(() =&gt; &#123; state.counter += 1; &#125;, 2000);&lt;/script&gt; 我们用 reactive 创建了一个响应式对象 state，并调用了 effect 方法，该方法接受一个副作用函数，effect 的执行会立即调用副作用函数，并将 state.counter 赋值给 #app.innerHTML；两秒后，state.counter += 1，此时，effect 的副作用函数会重新执行，页面也会变成 2. 内部的执行过程大概如下图所示： 调用 reactive() 返回一个 Proxy 代理对象，并劫持对象的 get 与 set 操作 调用 effect() 方法时，会访问属性 state.counter，此时会触发 proxy 的 get 操作。 get 方法会调用 track() 进行依赖收集；建立一个对象（state）、属性（counter）、effect 副作用函数的依赖关系； set 方法会调用 trigger() 进行依赖更新；通过对象（state）与属性（coutner）找到对应的 effect 副作用函数，然后重新执行。reactive reactivereactive 会返回如下一个 Proxy 对象 123456789101112131415161718192021const reactive = (target) =&gt; &#123; return new Proxy(target, &#123; get(target, key, receiver) &#123; const res = Reflect.get(target, key, receiver); track(target, key); // 收集依赖 if (isObject(res)) &#123; // 如果当前获取的属性值是一个对象，则继续将为此对象创建 Proxy 代理 return reactive(res); &#125; return res; &#125;, set(target, key, value, receiver) &#123; Reflect.set(target, key, value, receiver); trigger(target, key); // 依赖更新 &#125;, &#125;);&#125;; effect123456789let activeEffect;function effect(fn) &#123; const _effect = function reactiveEffect() &#123; activeEffect = _effect; fn(); &#125;; _effect();&#125; 首先定义全局的 activeEffect，它永远指向当前正在执行的 effect 副作用函数。effect 为 fn 创建一个内部的副作用函数，然后立即执行，此时会触发对象的 get 操作，调用 track() 方法。 1234effect(() =&gt; &#123; // effect 的立即执行会访问 state.counter，触发了对象的 get 操作。 document.querySelector(\"#app\").innerHTML = state.counter;&#125;); tracktrack 会建立一个 对象（state） =&gt; 属性（counter） =&gt; effect 的一个依赖关系 1234567891011121314151617181920const targetMap = new WeakMap();function track(target, key) &#123; if (!activeEffect) &#123; return; &#125; let depsMap = targetMap.get(target); if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())); &#125; let dep = depsMap.get(key); if (!dep) &#123; depsMap.set(key, (dep = new Set())); &#125; if (!dep.has(activeEffect)) &#123; dep.add(activeEffect); &#125;&#125; 执行完成成后我们得到一个如下的数据结构： 12345678910111213[ // map 集合 &#123; key: &#123;counter: 1&#125; // state 对象, value: [ // map 集合 &#123; key: \"counter\", value: [ // set function reactiveEffect() &#123;&#125; // effect 副作用函数 ], &#125; ], &#125;,]; trigger当我们给 state.counter 赋值的时候就会触发代理对象的 set 操作，从而调用 trigger 方法 123456789101112setTimeout(() =&gt; &#123; // 给 counter 属性赋值会触发 set 操作 state.counter += 1;&#125;, 2000);function trigger(target, key) &#123; const depsMap = targetMap.get(target); if (!depsMap) return; const effects = depsMap.get(key); effects &amp;&amp; effects.forEach((effect) =&gt; effect());&#125; vue3为什么要用proxy取代definePropertyVue3使用Proxy取代defineProperty的原因是，Proxy可以直接代理对象，而defineProperty只能劫持对象的属性。由于Object.defineProperty只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。这样的效率比较低，而且代码量也比较大。而Proxy可以直接劫持数组、对象的改变，可以直接添加对象属性，兼容性也比较好。比如：下面的例子使用get拦截，实现数组读取负数的索引。 123456789101112131415161718function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; let target = []; target.push(...elements); return new Proxy(target, handler);&#125;let arr = createArray('a', 'b', 'c');arr[-1] // c 上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。 因为直接对对象做的代理所以还能实现链式操作 12345678910111213141516171819202122var pipe = function (value) &#123; var funcStack = []; var oproxy = new Proxy(&#123;&#125; , &#123; get : function (pipeObject, fnName) &#123; if (fnName === 'get') &#123; return funcStack.reduce(function (val, fn) &#123; return fn(val); &#125;,value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125;); return oproxy;&#125;var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(\"\").reverse().join(\"\") | 0;pipe(3).double.pow.reverseInt.get; // 63","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue3/"}]},{"title":"前端包管理工具","slug":"前端包管理工具","date":"2022-04-23T15:39:34.000Z","updated":"2023-04-16T09:25:29.142Z","comments":true,"path":"2022/04/23/前端包管理工具/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2022/04/23/前端包管理工具/","excerpt":"","text":"当下最火的包管理工具是pnpm，在其出现之前，前端最常用的包管理工具有两个 npm、yarn，那为什么会出现 pnpm 呢，以及 pnpm 的出现到底解决了哪些问题？ npm 存在的问题1、早期npm 的 node_modules 采用了嵌套结构，完全按照目录结构来下载依赖树，容易造成依赖黑洞，最关键的是windows上支持的文件路径最长是 260 多个字符。 2、单个项目中，同一个版本的依赖包，有可能被下载多次；多个项目中，每次都需要重新下载所有依赖包，浪费了大量的磁盘空间。 npm2.x 目录结构123456789node_modules ├── moduleA │ └── node_modules │ └── moduleC └── moduleB └── node_modules └── moduleC └── node_modules └── moduleD 从上面的目录结构我们能看到，多层的嵌套结构，以及 moduleC 同时被moduleA、moduleB依赖，所以被重复下载了两次。 npm 官方在 npm3.x 中对上述问题做了改进。 npm3.x 中 node_modules 采用了扁平化结构。将所有的子依赖都提升到根目录下。也就是 hoist 机制。 npm3.x 目录结构12345node_modules ├── moduleA ├── moduleB └── moduleC └── moduleD 这在很大程度上解决了地狱依赖的问题，以及磁盘空间的浪费问题，但同时又带来了其他问题 1、幽灵依赖在package.json中没有声明的依赖包，因为被其他包依赖，被下载并提升到 node_modules 根目录下，导致直接可以在项目中去引用。 2、下载文件的不确定性同一份 package.json，下载出来的 node_modules 可能不一致的问题。 3、依赖重复安装这个也很好理解，AB都依赖某个包，依赖不同的版本，无论node_modules的顶层提升了哪个版本，这个包都是会被安装两次的。这会加剧node_modules对磁盘空间的占用率 也就是说两个依赖包同时依赖的C包的不同版本，C包只有一个版本会被 hoist，那么到底应该提升哪个版本呢，答案是不确定。 npm 5.x 为此新增了 package-lock.json 文件，用来锁定依赖包的版本号，以及确定不同版本如何 hoist 的问题。 这样就确保了同一份 package.json 下载出来的 node_modules 目录结构一致、但 幽灵依赖 问题仍然没有得到解决 yarnyarn 的出现，弥补了 npm2.x 的众多缺陷。 1、采用扁平化的方式管理 node_modules，并且首次提出了离线缓存下载的概念，下载速度大幅提升。 2、yarn.lockyarn.lock 用来确定依赖树之间的结构，确保同一个项目生成同样的 node_modules 但是 yarn 跟 npm 一样，都没有解决幽灵依赖的问题。 pnpmpnpm 在 2017 年发布，它的出现，解决了 npm、yarn 长期以来存在的性能、安全访问等问题。 相对于别的包管理工具具有如下的特点： 包安装速度极快； 磁盘空间利用非常高效。 pnpm的包管理方式是通过建立链接+store的方式来完成快速安装和防止重复安装（以减少磁盘空间）的问题。 storepnpm 默认会将所有依赖包下载到系统{home dir}/Library/pnpm/store/v3中，系统中相同文件只会存在一份。 软硬链接软连接每个项目 node_modules 下安装的包结构为树状，符合 node 就近查找规则，以软链接方式将内容指向 node_modules/.pnpm 中的包。 硬链接每个项目的 node_modules 下有 .pnpm 目录以打平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。 这样幽灵依赖的问题就解决了，包版本不确定性的问题也就解决了。毕竟顶层就只有我们手动安装的包，其他依赖包都收在.pnpm中 除此之外，这种方式的好处是： 不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 hardlink(硬链接） 即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。 软硬链接的区别软硬链接的区别 总结就是软链接指向的是文件的文件路径，硬链接记录的是文件的内容，但是当源文件被删除的时候，硬链接还是能访问（文件真正删除的条件是与之相关的所有硬连接文件均被删除。）软硬链接任何一个文件发生改变，都会同步到其他的链接，因此硬链接可以用来被多个地方同时操作但是防止误删，所以pnpm会使用硬连接指向.pnpm store 中的文件地址，相比硬链接，软链接的优势是：可以立即知道符号链接指向的位置，而使用硬链接，您需要探索整个文件系统以找到共享相同 inode 的文件。因此软链接通常用来做快捷方式，而这里使用软链接是为了更快找到依赖在pnpm store中的位置","categories":[],"tags":[{"name":"包管理","slug":"包管理","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/包管理/"}]},{"title":"设计模式","slug":"设计模式","date":"2021-06-21T04:33:37.000Z","updated":"2023-04-21T04:59:41.814Z","comments":true,"path":"2021/06/21/设计模式/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2021/06/21/设计模式/","excerpt":"","text":"单例模式1234567891011121314151617181920212223242526272829class SingletonApple &#123; constructor(name, creator, products) &#123; this.name = name; this.creator = creator; this.products = products; &#125; //静态方法 static getInstance(name, creator, products) &#123; if (!this.instance) &#123; this.instance = new SingletonApple(name, creator, products); &#125; return this.instance; &#125;&#125;let appleCompany = SingletonApple.getInstance('苹果公司', '乔布斯', [ 'iPhone', 'iMac', 'iPad', 'iPod',]);let copyApple = SingletonApple.getInstance('苹果公司', '阿辉', [ 'iPhone', 'iMac', 'iPad', 'iPod',]);// console.log(appleCompany === copyApple); 单例模式实现modal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Login &#123; //构造器 constructor() &#123; this.init(); &#125; //初始化方法 init() &#123; //新建div let mask = document.createElement('div'); //添加样式 mask.classList.add('mask-layer'); //添加模板字符串 mask.innerHTML = ` &lt;div class=\"login-wrapper\"&gt; &lt;div class=\"login-title\"&gt; &lt;div class=\"title-text\"&gt;登录框&lt;/div&gt; &lt;div class=\"close-btn\"&gt;×&lt;/div&gt; &lt;/div&gt; &lt;div class=\"username-input user-input\"&gt; &lt;span class=\"login-text\"&gt;用户名:&lt;/span&gt; &lt;input type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"pwd-input user-input\"&gt; &lt;span class=\"login-text\"&gt;密码:&lt;/span&gt; &lt;input type=\"password\"&gt; &lt;/div&gt; &lt;div class=\"btn-wrapper\"&gt; &lt;button class=\"confrim-btn\"&gt;确定&lt;/button&gt; &lt;button class=\"clear-btn\"&gt;清空&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `; //插入元素 document.body.insertBefore(mask, document.body.childNodes[0]); //注册关闭登录框事件 Login.addCloseLoginEvent(); &#125; //静态方法: 获取元素 static getLoginDom(cls) &#123; return document.querySelector(cls); &#125; //静态方法: 注册关闭登录框事件 static addCloseLoginEvent() &#123; this.getLoginDom('.close-btn').addEventListener('click', () =&gt; &#123; //给遮罩层添加style, 用于隐藏遮罩层 this.getLoginDom('.mask-layer').style = \"display: none\"; &#125;) &#125; //静态方法: 获取实例(单例) static getInstance() &#123; // 如果静态方法包含this关键字，这个this指的是类，而不是实例 if(!this.instance) &#123; this.instance = new Login(); &#125; else &#123; //移除遮罩层style, 用于显示遮罩层 this.getLoginDom('.mask-layer').removeAttribute('style'); &#125; return this.instance; &#125;&#125;// 注册点击事件Login.getLoginDom('.login-btn').addEventListener('click', () =&gt; &#123; Login.getInstance();&#125;) 发布订阅模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 通用发布订阅模式class EventEmitter &#123; // 订阅者列表 subscriber = &#123;&#125;;​ // 订阅 subscribe(key, fn) &#123; if (!Array.isArray(this.subscriber[key])) &#123; this.subscriber[key] = []; &#125; this.subscriber[key].push(fn); &#125;​ // 取消单个订阅 unsubscribe(key, fn) &#123; const subscribers = this.subscriber[key] || []; this.subscriber[key] = subscribers.filter((_fn) =&gt; _fn !== fn); &#125;​ // 取消所有订阅 unsubscribeAll(key) &#123; this.subscriber[key] = []; &#125;​ // 发布 publish(key, ...args) &#123; const subscribers = this.subscriber[key] || [];​ if (subscribers.length === 0) &#123; // console.log(\"has't subscriber\"); &#125;​ subscribers.forEach((subscriber) =&gt; &#123; subscriber.apply(this, args); &#125;); &#125;&#125;​// 创建发布订阅信道中介const e = new EventEmitter();​// 发布者const publisher = &#123; article1: 'article1', article2: 'article2',&#125;;​// 订阅者const subscriber1 = (article) =&gt; &#123; // console.log(`fans1 receive $&#123;article&#125;`);&#125;;const subscriber2 = (article) =&gt; &#123; // console.log(`fans2 receive $&#123;article&#125;`);&#125;;​// 订阅操作e.subscribe('event1', subscriber1);e.subscribe('event1', subscriber2);​// 发布操作e.publish('event1', publisher.article1);// fans1 receive article1// fans2 receive article1​// 多事件发布订阅e.subscribe('event2', subscriber1);e.publish('event2', publisher.article1);// fans1 receive article1​// 取消单个订阅e.unsubscribe('event1', subscriber1);e.publish('event1', publisher.article2);// fans2 receive article2​// 取消所有订阅e.unsubscribeAll('event1');e.publish('event1');// has't subscriber 与观察者模式的区别 策略模式123456789101112131415let strategies = &#123; source: &#123; action: \"sourceOption\", getOptions: function() &#123; // 拉取 options &#125; &#125;, product: &#123; action: \"productOption\", getOptions: function() &#123; // 拉取 options &#125; &#125;, ...&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/设计模式/"}]},{"title":"Vue2和Vue3区别","slug":"Vue2和Vue3区别","date":"2021-04-16T02:30:44.000Z","updated":"2023-04-16T03:18:12.870Z","comments":true,"path":"2021/04/16/Vue2和Vue3区别/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2021/04/16/Vue2和Vue3区别/","excerpt":"","text":"响应式原理api的改变Vue2响应式原理采用的是defineProperty，而vue3选用的是proxy。这两者前者是修改对象属性的权限标签，后者是代理整个对象。性能上proxy会更加优秀。 diff算法，渲染算法的改变Vue3优化diff算法。不再像vue2那样比对所有dom，而采用了block tree的做法。此外重新渲染的算法里也做了改进，利用了闭包来进行缓存。这使得vue3的速度比vue2快了6倍。 vue2的diff过程vue在内部通过一个叫patch的函数完成该过程 在对比时，vue采用深度优先、同层比较的方式进行比对。 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。 这样一直递归的遍历下去，直到整棵树完成对比 react的diff 优化点 只比较同层 双端比较：即同时从新旧 VNode 的头部和尾部开始比较，然后根据情况移动指针，直到找到不同的节点为止。这种策略可以最大程度地减少比较次数，从而提高 diff 算法的效率。 key优化：如果没有给节点添加key值，那么Vue会认为这些节点是相同的，从而对整个列表进行重渲染。而如果给节点添加了唯一的key值，那么Vue就可以根据key值来判断哪些节点是相同的，哪些节点是不同的，从而只对不同的节点进行更新，提高了性能。 vue3的diff 静态节点优化：静态节点指的是不会改变的节点，如文本节点。在Vue2中，每次重新渲染时，都会重新创建这些静态节点，这样会浪费很多时间。Vue3中，通过静态提升的方式，将静态节点提升到父组件的渲染函数中，在组件更新时，只需要对动态节点进行比较，从而避免了对静态节点的重复渲染，提高了性能 。 建立数据 data这里就是Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）旧的选项型API在代码里分割了不同的属性（properties）：data，computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。 Vue3对TypeScript的支持更加友好","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue/"}]},{"title":"常见登录方案","slug":"常见登录方案","date":"2021-04-10T03:44:17.000Z","updated":"2023-04-18T06:44:34.817Z","comments":true,"path":"2021/04/10/常见登录方案/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2021/04/10/常见登录方案/","excerpt":"","text":"cookiecookie有哪些属性 Expires过期时间，是客户端的过期时间，到时间会被删除 Max-Agecookie 的有效时间长度，单位为秒。通过设置小于等于 0 的数字，可以让一个 cookie 失效。 如果 Max-Age 和 Expires 同时存在，以 Max-Age 为准。 Path我们以上面示例为例，浏览器会将名为 lang 的 cookie 保存到当前域名下。但之后请求时，会判断路径是否匹配 /user，来决定是否带上 cookie。 / ：不会带上名为 lang 的 cookie/user：会带上/user/1：会带上/user2：不会带上 Domain 设置 cookie 的 domain 作用域。 在不提供该属性的情况下，会使用请求时的 domian，比如 http://www.a.com/api/v1/books 不设置 Domain 时，拿到的 cookie 的 Domain 属性会被设置为 www.a.com 。 通常我们会省略掉 Domain 属性。 但在希望多个子域名共享 cookie 的场景下，比如 sub1.a.com 和 sub2.a.com（或者再加上父域名 a.com），就需要显式将其设置为 .a.com。开头的小圆点可写可不写，都一样。 如果 Domain 不能覆盖当前域名，该 cookie 会被认定为无效，然后被丢弃掉。 Secure 请求必须为安全连接（HTTPS），cookie 才会被保存下来。HTTP 协议下，cookie 无效。 samesite strict：严格模式，完全禁止使用Cookie：浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。 lax：宽松模式，允许部分情况使用Cookie，跨域的都行，a标签跳转，link标签，GET提交表单：从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。比如：从 ​​time.geekbang.org​​ 的页面中，通过a标签打开页面，如下所示：1&lt;a href=\"https://www.infoq.cn/sendcoin?user=hacker&amp;number=100\"&gt;点我下载&lt;/a&gt; 当用户点击整个链接的时候，因为InfoQ中a_vaule(infoQ的cookie)的SameSite的值设置成了strict，那么a_vaule的值将不会被携带到这个请求的HTTP头中。 none：任何情况下都会发送Cookie，但必须同时设置Secure属性，意思是需要安全上下文，Cookie 只能通过https发送，否则无效sessionSession 是一种存储在服务器上的数据结构，用于存储有关用户的信息。Session 数据存储在服务器上，因此比 Cookie 更加安全。Session 通常使用 Cookie 来跟踪用户会话session机制当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。服务器按照该session ID查找对应的session信息如果没找到说明没登录或者登陆失效如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。session的优势相较于 cookie 来说，session 存储在服务端，客户端仅保留换取 session 的用户凭证。因此传输数据量小，速度快。session 更安全：检验、生成、验证都是在服务端按照指定规则完成，而 cookie 可能被客户端通过 js 代码篡改。session 的劣势 服务器是有状态的。多台后端服务器无法共享 session。**解决方法是，专门准备一台 session 服务器，关于 session 的所有操作都交给它来调用。而服务器之间的调用，可以走内网 ip，走 RPC 调用（后端之间的接口请求，前端不能请求）（不走 http）。 Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。 由于存放在cookie中，需要防止CSRF攻击解决方案：○ 阻止不明外域的访问，同源检测（检查referer、origin）、限制第三方cookie（samesite=lax)○ 请求提交时附加CSRF token（只要token不放在cookie里，攻击者无法伪造，并且页面没有XSS漏洞泄漏token，CSRF就无法成功） session与cookie的区别 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。 Session 如何实现退出登录呢？需要清除掉 Session 中的登录状态，同时也需要清除掉 Cookie 中的 SessionId。那么如何清除 Cookie 中的 SessionId 呢？我们可以通过将 Cookie 的过期时间设置为一个过去的时间来实现。 session的缺点 依赖cookie，cookie自身就有安全漏洞，如果cookie被劫持的话，黑客从中拿到了session ID，冒充用户依旧是个漏洞怎么预防：○ 使用 HTTPS 协议加密传输数据，可以有效防止中间人攻击和黑客窃听。○ 生成随机且复杂的 Session ID，并设置合理的过期时间，避免被猜测或者重放攻击。○ 不要在 URL 中使用 Session ID，避免会话固定攻击。○ 定期更换 Session ID，以保证会话安全性。 依赖cookie，客户端可能不支持cookie怎么解决：○ URL 重写 Session，是一种在 URL 中传递 Session ID 的方式，缺点是放在URL中是不安全的，以为是明文传输 服务端 Session 需要在服务端维护，需要找地方保存它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。 JWT Token什么是jwt token一种基于 Token 的身份认证机制，它的特点是无状态，也就是说，它不需要在服务端保存会话信息，也不需要在客户端保存会话状态。这里的JWT 就是一个令牌，也就是我们在传递的 token 字符串。 流程 首先用户通过账号和密码向服务器请求登录。 服务端校验用户身份后，生成一个 Token，然后将 Token 返回给客户端。 客户端需要在本地保存这个 Token，以便后续的请求携带 Token。 客户端可以在本地存储或 sessionStorage 中保存 Token，也可以在 Cookie 中保存 Token。 客户端在后续请求中，都需要将 Token 发送给服务器验证。一般将 Token 放在 HTTP 请求头的 Authorization 字段中，发送给服务器。Bearer [Token] 服务端在接收到请求后，会从 Authorization 字段中获取 Token，并验证 token 是否有效，签名是否正确，是否过期等。通过后，再进行响应。 jwt的生成过程jwt分为三个部分：header（头部）、payload（载荷）和 signature（签名）header:定了用于生成签名的算法payload:放了一些过期时间，用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。signature：然后用header中指定的算法对前两部分的base64+私钥（这个密钥只有服务器才能知道，不能泄露给用户）进行签名 jwt如何防止被篡改在整个 JWT 认证流程中，服务端在收到客户端请求头中携带的 token 时，会使用相同的密钥和算法对token进行解码，然后使用相同的算法，将 header 和 payload 以及 secret 私钥进行签名，然后和 token 中原有的签名进行对比，如果一致，说明 token 没有被篡改，如果不一致，说明 token 被篡改了。 无论别人知道多少我们在传输的信息，篡改和伪造后都不能通过服务器的验证，是因为无法获取服务器的密钥 secret，真正能保证安全的就是 secret jwt如何退出登录在用户注销登录后，会把用户 token 存到 token 列表中，当这个 token 再次被用来请求时，就会命中黑名单，而被拒绝请求 jwt存储在客户端如何防止未退出登录的时候被劫持还没有退出登录 token 仍然有效，如果 token 泄露了，攻击者可以盗用这个 token来冒用身份。但是可以在 JWT payload 部分加上 IP 之类的来增强 token 的安全性。同时更安全的做法是使用 https 协议来传输 token 如何实现无感刷新？在用户登录的时候，服务端返回两个 token 一个是 accessToken，用来做用户的鉴权，过期时间比较短，比如 1 小时 一个是 refreshToken，用来刷新 accessToken，过期时间比较长，比如 7 天客户端把这两个 token 都存在本地，每次访问都将 accessToken 传给服务端，服务端校验 accessToken 有效后，响应。如果服务端校验 accessToken过期后，那么就需要将 refreshToken 传给服务端，如果 refreshToken 是有效的，那么服务端就会返回一个新的 accessToken，客户端就可以使用新的 accessToken 继续访问。客户端需要更新本地的 accessToken，这样就实现了无感刷新。这里一共会发送 2 次的 HTTP 请求，第一次过期被拒绝，第二次刷新 token","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/网络/"}]},{"title":"webpack按需加载模块原理","slug":"webpack按需加载模块原理","date":"2021-03-17T14:53:58.000Z","updated":"2023-04-17T22:18:43.350Z","comments":true,"path":"2021/03/17/webpack按需加载模块原理/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2021/03/17/webpack按需加载模块原理/","excerpt":"","text":"最简单的示例第一步：定义一个需要按需加载的模块 a.js 123export default function a() &#123; console.log('我是模块 a');&#125; 第二步：在主模块(index.js)中引入模块 a 123import('./a').then((&#123; default: a &#125;) =&gt; &#123; console.log(a);&#125;); 第三步：使用如“npm run start”(不同的配置可能略有不同)启动服务 笔者在这里启动了 webpack-dev-server ，使用 localhost 浏览可以看下在浏览器的 Console 版面输出一下内容： Network 版面，使用 JS 筛选后会看到加载了两个 js 文件。一个是 index.js (主模块)，另一个是 0.async.js (按需加载文件)。如此就轻松实现了模块的按需加载 配置编译后的文件名通常情况下使用按需加载模块是不用做配置的，但有些时候我们可能对编译生成的文件名有所要求(比如为了方便识别)，这时我们就可能需要调整一些配置了。 在 webpack 中，可以通过 output 的 chunkFileName 子项来调整输出的文件名。chunkFileName 的命名方式是和 filename 是一样的，但为了保证输出文件名的唯一性，推荐使用 [name]、[id] 或 [chunkhash] 其中之一的变量。这里的 [name] 通常情况下和 [id] 表现一直，只有在 import 设置 webpackChunkName 才表现不一致。定义方式如下： 123456789import( // 通过定义 webpackChunkName 可以调整 [name] 值 /* webpackChunkName: \"a-async\" */ // webpackMode 可同选择的值有多个，有兴趣的小伙伴请自行前往帮助文档进一步了解： // https://www.webpackjs.com/api/module-methods/#import- /* webpackMode: \"lazy\" */ './a').then((&#123; default: a &#125;) =&gt; &#123; console.log(a);&#125;); 这时再配合下面 chunkFileName 的配置内容，就能输出 a-async.js 文件名了，如下： 12345678910const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), chunkFilename: `[name].js`, &#125;&#125;; 如果没有配置 chunkFilename，将根据 filename 导出按需加载文件名的规则。具体规则如下： 如果 filename 规则可以保证生成的文件名唯一，则按照 filename 的规则生成；如果 filename 规则不能保证生成的文件名唯一，则会在 filename 规则前统一加上“[id].”来保证唯一 例如配置内容如下： 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;&#125;; 那么实际生成按需加载的文件名为 [id].bundle.js 。 如何实现按需加载webpack如何实现的按需加载呢？ 12345678910111213/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//*! dynamic exports provided *//*! all exports used *//***/ (function(module, exports, __webpack_require__) &#123;__webpack_require__.e/* import() */(0/*! a-async */).then(__webpack_require__.bind(null, /*! ./a */ 82)).then(function (_ref) &#123; var a = _ref.default; console.log(a);&#125;);/***/ &#125;) 上面代码的含义是： webpack_require.e 对应 import() 方法，即异步加载的主体方法；参数是 0 对应 a-async 这个chunk异步加载之后首先执行 webpack_require 方法，第一个入参是 82 对应 ‘./a’ 文件。然后执行的就是自己的代码了 接下来一起来看下webpack_require.e 的方法体内容(解释请看中文注释)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId) &#123;/******/ var installedChunkData = installedChunks[chunkId]; // 0 表示已经加载成功，无需再做任何处理/******/ if(installedChunkData === 0) &#123;/******/ return new Promise(function(resolve) &#123; resolve(); &#125;);/******/ &#125;/******//******/ // a Promise means \"currently loading\". // 正在加载中/******/ if(installedChunkData) &#123;/******/ return installedChunkData[2];/******/ &#125;/******//******/ // setup Promise in chunk cache // 将 promise 对象的相关内容存入 installedChunks[chunkId]，待后面使用/******/ var promise = new Promise(function(resolve, reject) &#123;/******/ installedChunkData = installedChunks[chunkId] = [resolve, reject];/******/ &#125;);/******/ installedChunkData[2] = promise;/******//******/ // start chunk loading // 生成一个 script 标签，用于异步加载 js 文件/******/ var head = document.getElementsByTagName('head')[0];/******/ var script = document.createElement('script');/******/ script.type = \"text/javascript\";/******/ script.charset = 'utf-8';/******/ script.async = true;/******/ script.timeout = 120000;/******//******/ if (__webpack_require__.nc) &#123;/******/ script.setAttribute(\"nonce\", __webpack_require__.nc);/******/ &#125; // __webpack_require__.p 就是 __webpack_public_path__ 对应的地址/******/ script.src = __webpack_require__.p + \"\" + (&#123;\"0\":\"a-async\"&#125;[chunkId]||chunkId) + \".async.js\"; // 超时之后执行 onScriptComplete/******/ var timeout = setTimeout(onScriptComplete, 120000);/******/ script.onerror = script.onload = onScriptComplete;/******/ function onScriptComplete() &#123;/******/ // avoid mem leaks in IE./******/ script.onerror = script.onload = null;/******/ clearTimeout(timeout);/******/ var chunk = installedChunks[chunkId]; // 如果文件加载成功，chunk就被设置为 0；后面只处理了加载失败的情况/******/ if(chunk !== 0) &#123;/******/ if(chunk) &#123;/******/ chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));/******/ &#125;/******/ installedChunks[chunkId] = undefined;/******/ &#125;/******/ &#125;;/******/ head.appendChild(script);/******//******/ return promise;/******/ &#125;; 可以看到并不会被打包入entry chunk，而是如果是需要的，会被使用script标签的形式插入到页面（打包后的文件中的代码逻辑：满足条件插入这段异步代码）","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"常见的攻击方式","slug":"常见的攻击方式","date":"2020-04-16T08:11:09.000Z","updated":"2023-04-16T08:51:37.021Z","comments":true,"path":"2020/04/16/常见的攻击方式/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2020/04/16/常见的攻击方式/","excerpt":"","text":"XSS攻击XSS攻击是一种代码注入攻击，通过恶意注入脚本在浏览器运行，然后盗取用户信息造成XSS攻击其实本质上还是因为网站没有过滤恶意代码，与正常代码混在一起之后，浏览器没有办法分辨哪些是可信的，然后导致恶意代码也被执行。 然后可能导致以下情况： 页面数据或用户信息被窃取，如DOM、Cookie、LocalStorage 修改DOM，比如伪造登录窗口或在页面生成浮窗广告 监听用户行为，比如在登录或银行等站点用 addEventListener 监听键盘事件，窃取账号密码等信息 XSS攻击有三种类型：存储型、反射型、DOM型 存储型：是在有发贴评论等带有数据保存功能的网站的input、textarea将恶意代码提交到网站数据库中，如 ，然后服务器直接存上了，返回给前端展示的时候，就会直接执行这个script标签里的恶意代码 反射型：是攻击者将恶意JS脚本作为用户发送给网站请求中的一部分，然后网站又把恶意脚本返回给用户，这时候就会在页面中被执行。比如打开包含带恶意脚本的链接，当打开后会向服务器请求后，服务器会获取URL中的数据然后拼接在HTML上返回，然后执行。它和存储型不同的是不会储存在服务器里:比如：举个例子，比如我们在访问一个链接的时候（http://102.3.203.111/Web/reflectedXSS.jsp?param=value...），这个URL中就带了参数（param=value...），`如果服务端没有对参数进行必要的校验，直接根据这个请求的参数值构造不同的HTML返回（比如caniuse`），让value出现在返回的html中（JS,HTML某元素的内容或者属性）并被浏览器解释执行，就可能存在反射型XSS漏洞。 基于DOM型：就是攻击者通过一些劫持手段，在页面资源传输过程中劫持并修改页面的数据，插入恶意代码 怎么防范XSS攻击 针对存储型：对输入框的内容进行过滤或使用转义符进行转码字符 转义后的字符 123456&lt; &amp;lt;&amp;gt;&quot; &amp;quot;&apos; &amp;#x27;/ &amp;#x2F&amp; &amp;amp; 针对反射型：使用CSP，就是白名单，告诉浏览器哪些外部资源可以加载执行，让即使插入进来恶意代码的也不会执行，或者可以向哪些第三方站点提交数据。开启白名单的方式有两种：使用 meta 标签 设置http头部的 Content-Security-Policy（使用这种模式,将会直接阻止非法的外部资源加载,同时也可以选择是否配置将非法资源加载的链接和行为报告给我们指定的网址） 针对基于dom型：对一些敏感信息进行保护，在Cookie信息中添加httpOnly，告诉浏览器在保存Cookie，且不要对客户端脚本开放访问权限，然后就不能通过document.cookie获取cookie了 CSRF攻击就是跨站请求伪造攻击，主要就是利用用户的登录状态发起跨站请求冒充用户执行一些操作，比如邮箱里的乱七八糟的链接，打开链接的时候邮箱肯定是处于登录状态，然后黑客就可以用这个登录状态，伪造带有正确 Cookie 的 http 请求，直接绕过后台的登录验证，然后冒充用户执行一些操作发起CSRF攻击有三个必要条件： 目标网站一定要有CSRF漏洞 用户登录过目标网站，并且浏览器保存了登录状态 需要用户主动打开第三方站点 本质是利用cookie在同源请求中携带发送给服务器的特点，来实现冒充用户CSRF攻击也有三种类型：GET类型、POST类型、链接型 自动发GET类型：比如img或iframe标签等，当用户打开这个网站时,恶意网站会像我们的服务器自动发起带Cookie的资源请求 1&lt;img src=\"http://恶意网址\" &gt; 自动发POST类型：比如整一个隐藏的表单，在用户进入页面的时候自动提交表单 诱导链接型：就是诱导用户主动点击链接，比如a标签点击领取大礼包点击下载美女视频 以上三种形式其实都是通过拿到用户的cookie然后引导用户进入恶意网站，恶意网站再去拿着我们的cookie去请求我们的服务器 怎么防范CSRF攻击，有什么解决办法？ 在Cookie信息中添加SameSite属性为none，这个属性有三个值： strict：严格模式，完全禁止使用Cookie：浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。 lax：宽松模式，允许部分情况使用Cookie，跨域的都行，a标签跳转，link标签，GET提交表单：从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。比如：从 ​​time.geekbang.org​​ 的页面中，通过a标签打开页面，如下所示： 1&lt;a href=\"https://www.infoq.cn/sendcoin?user=hacker&amp;number=100\"&gt;点我下载&lt;/a&gt; 当用户点击整个链接的时候，因为InfoQ中a_vaule(infoQ的cookie)的SameSite的值设置成了strict，那么a_vaule的值将不会被携带到这个请求的HTTP头中。 none：任何情况下都会发送Cookie，但必须同时设置Secure属性，意思是需要安全上下文，Cookie 只能通过https发送，否则无效 Chrome 80之前默认值是none，之后是lax，在防范 CSRF 攻击时，可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。 CSRF token前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。 而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 原理CSRF Token的防护策略分为三个步骤： 将CSRF Token输出到页面中 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token(a标签诱导链接型、表单类型、图片src 自动发get请求)。这样可以解决大部分的请求 页面提交的请求携带这个Token 对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 1&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt; 服务器验证Token是否正确 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。 通过origin验证请求来源：服务器根据http请求头中的Origin或Referer属性判断是否为允许访问的站点，从而对请求进行过滤。优先判断Origin，如果两个都不存在的话就直接阻止。 Referer：记录了请求是从哪个链接跳过来的并且包含了路径信息，也就是来源地址，所有请求都会有。不过这家伙不太可靠，所以后来又新增了Origin属性 origin：记录了域名信息，没有具体的URL路径，post请求才会有 referer origin的区别referer 2.1 定义： Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。组成：协议+域名+端口号+路径+参数（注意，不包含 hash值）例子：test.com:1998/home需要注意的是 referer 实际上是 “referrer” 误拼写。在以下几种情况下，Referer 不会被发送： 来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI； 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）； 直接输入网址或通过浏览器书签访问； 使用 JavaScript 的 Location.href 或者是 Location.replace()； 使用 html5 中 noreferrer 2.2 用途 服务端一般使用 Referer 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等，还有个常见的用途是图片防盗链。 防盗链原理是：当用户访问网页时，referer就是前一个网页的URL；如果是图片的话，通常指的就是图片所在的网页。当浏览器向服务器发送请求时，referer就自动携带在HTTP请求头了。 图片服务器根据这个请求头判断，如果 referer 不是自己的服务器，就将其拦截。 origin 3.1 定义 请求首部字段 Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。除了不包含路径信息，该字段与 Referer 首部字段相似。该首部用于 CORS 请求或者 POST 请求。 组成：协议+域名+端口号 注意：只有跨域请求（可以看到 response 有对应的 header：Access-Control-Allow-Origin），或者同域时发送post请求，才会携带origin请求头。 如果浏览器不能获取请求源，那么 origin 满足上面情况也会携带，不过其值为null。而referer不论何种情况下，只要浏览器能获取到请求源都会携带。如果浏览器如果不能获取请求源，那么请求头中不会携带referer。 3.2 用途 用于 CORS: 当我们的浏览器发出跨站请求时，服务器会校验当前请求是不是来自被允许的站点。服务器就是通过 Origin 字段的值来进行判断。 两者的区别1、只有跨域请求，或者同域时发送post请求，才会携带origin请求头，而referer不论何种情况下，只要浏览器能获取到请求源都会携带，除了上面提到的几种情况。 2、 referrer 存在很多问题。比如说在请求外部网站的时候，携带着 url 的很多参数信息，而这些信息实际上是隐私的，所以存在一定的隐私暴露风险。 origin 就不存在这种隐私问题。比如：URL上携带有token等身份信息时，攻击者就可以盗取用户token进行攻击。除此之外 点击a标签的时候也会携带referer：a标签可能泄露你的站点链接，所以项目中包含跨域链接时最好做一些处理，如&lt;a href=&quot;http://example.com&quot; referrerpolicy=&quot;origin&quot;&gt;,&lt;a href=&quot;http://example.com&quot; rel=&quot;noreferrer&quot;&gt;，这两种方法都限制了Referer头部的发送，你也可以直接添加meta标签全局设置Referer发送策略 双重验证Cookie： 利用攻击者只能利用Cookie，不能获取Cookie的特点，用户访问页面时，服务器向请求域名添加一个Cookie随机字符串，然后，用户再次请求时从Cookie中取出这个字符串，添加到URL参数中，然后服务器通过对Cookie中的数据和参数中的数据对比验证，不一样就拒绝请求。缺点是如果网站存在XSS漏洞，这法子就会失效，而且不能做到子域名的隔离 通过验证码和密码的方式确保是真实用户 中间人攻击中间人攻击（MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。中间人攻击常见的方式有：Wi-Fi欺骗、HTTPS欺骗、SSL劫持、DNS欺骗、电子邮件劫持等 如何防范 使用HTTPS协议：HTTPS协议可以防止基本的中间人攻击。当然，攻击者也会通过多种方法，来破坏HTTPS，进而消除加密的安全性。例如，SSLStrip类型的中间人攻击，会强制将浏览器“卡”在旧的HTTP模式。对此，您可以通过细心观察浏览器的地址栏，是否带有红叉或惊叹号的通知，以发现。 使用VPN：VPN是一种虚拟专用网络，可以在公共网络上建立一个私有网络。VPN可以加密数据传输，从而防止中间人攻击。 使用数字证书：数字证书是一种用于验证身份的电子证书。使用数字证书可以防止中间人攻击。 不要使用公共Wi-Fi：公共Wi-Fi很容易被黑客利用进行中间人攻击。所以尽量不要使用公共Wi-Fi123。","categories":[],"tags":[{"name":"浏览器安全","slug":"浏览器安全","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/浏览器安全/"}]},{"title":"react性能优化","slug":"react性能优化","date":"2020-02-23T15:17:51.000Z","updated":"2023-04-20T03:45:56.000Z","comments":true,"path":"2020/02/23/react性能优化/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2020/02/23/react性能优化/","excerpt":"","text":"减少渲染的节点/降低渲染计算量0️⃣ 不要在渲染函数里面进行不必要的计算 1️⃣ 减少不必要的嵌套一般不必要的节点嵌套都是滥用高阶组件/RenderProps 导致的 有很多种方式来代替高阶组件/RenderProps，例如优先使用 props、React Hooks 2️⃣ 虚拟列表实现方案：1.intersectionobserver只渲染在可视区的内容只观察第一个跟最后一个元素，比如一个list，当最后一个元素进入可视区的时候，渲染的第一个元素变成最后一个元素的下一个元素2.滚动加载 3️⃣ 惰性加载 精细化渲染 简化 props① 如果一个组件的 props 太复杂一般意味着这个组件已经违背了‘单一职责’，首先应该尝试对组件进行拆解.② 另外复杂的 props 也会变得难以维护, 比如会影响shallowCompare效率, 还会让组件的变动变得难以预测和调试. hooks优化 useState初始化惰性函数12345function Table(props) &#123; // ⚠️ createRows() 每次渲染都会被调用 const [rows, setRows] = useState(createRows(props.count)); // ...&#125; 为避免重新创建被忽略的初始 state，我们可以传一个 函数 给 useState： 12345function Table(props) &#123; // ✅ createRows() 只会被调用一次 const [rows, setRows] = useState(() =&gt; createRows(props.count)); // ...&#125; 当initialState以函数形式传入时，它只会在函数组件初始化的时候执行一次，函数re-render时不会再被执行 以上尚待考究； 1useState(props.value) 并不会随着props的变化而变化，初始化值只会初始一次,同样的useRef也是一样 优化key除了以下的情况不使用index作为key:列表的重新排序，增删，过滤不会发生 减少re-render哪些原因会导致rerender 状态更改 当组件的状态发生变化时，它将重新渲染自身。需要注意的是，类组件的state被重复设置成同一个值会导致重新渲染，但是函数组件不会。 父级（或子级）重新渲染 注意是父组件的重新渲染触发了子组件的重新渲染，与子组件的 props 是否变化无关。只有那些使用了 React.memo 和 useMemo 的组件，props 的变化才会触发组件的重新渲染。 context 变化 hooks 变化。 hooks 内部的状态变化会触发组件的 re-render 如果 hooks 使用了 context，并且 context 的值发生了变化，也会触发组件的 re-render 怎么避免re-render 避免在 render 函数中创建组件，原因如下：在每次重新渲染时，React 都会重新装载这个组件（即销毁它并从头开始重新创建），这比正常的重新渲染要慢得多。除此之外，还会导致以下问题： 在重新渲染期间可能出现内容 “闪烁” 每次重新渲染时在组件的状态会被重置 每次重新渲染时不会触发依赖项的 useEffect 如果组件被聚焦，则焦点将丢失 state 下移到子组件中 组件作为 props 与前面的模式基本相同，将状态封装在一个较小的组件中，而较重的组件作为 props 传递给它。props 不受 state 变化的影响，因此该较重的组件不会被重新渲染 使用 React.memo 常见误区 无用的 useMemo/useCallback props将子组件的 props 包装成 memoize 值，是不能避免该子组件重新渲染的。只要父组件重新渲染，那么子组件就会被重新渲染，与 props 没有关系。这个时候就需要用到React.Memo了 错误做法 正确做法 正确使用key如果列表项是一个组件，父组件重新渲染了,仅仅设置 key 值并不会提高列表的性能。为了避免列表元素的重新渲染，还要用 React.memo 包装它们 避免 Context 引起 re-render 将 Provider 的值做 memoize 处理 如果 Context Provider 没有在页面的根节点上，那么祖先节点的变化也会导致它被重新渲染，所以它的值也应该被 memoize。 对数据和 API 做拆分 @rematch/core使用时：useContext，无需在根组件包裹store，只需要 1init(&#123; models: &#123; global &#125; &#125;); 使用createPortal创建的组件A，插入到一个dom节点，dom节点所在的组件被重新渲染的话，是不会引发组件A的重新渲染的。 context优化 拆分context useMemo React.memo做缓存 借鉴redux的发布订阅模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// providerconst Provider = (&#123; children &#125;) =&gt; &#123; const [store, dispatch] = useReducer(reducer, initState); const storeRef = useRef(null); storeRef.current = store; // 订阅所有子组件更新的回调函数 const subscribeRef = useRef([]); // store变化的时候执行所有的监听函数 useEffect(() =&gt; &#123; subscribeRef.current.forEach((sub) =&gt; sub()); &#125;, [store]); // 缓存value 利用ref拿到最新的状态 const value = useMemo( () =&gt; (&#123; dispatch, subscribe: (cb) =&gt; &#123; subscribeRef.current.push(cb); // return unsubscribe return () =&gt; &#123; subscribeRef.current = subscribeRef.current.filter( (item) =&gt; item !== cb ); &#125;; &#125;, getState: () =&gt; storeRef.current, &#125;), [] ); // value此后都不会变化了 只有store变化 store变化的时候通知所有的消费者 return &lt;MyContext.Provider value=&#123;value&#125; children=&#123;children&#125; /&gt;;&#125;;// useSelectorexport const useSelector = (selector) =&gt; &#123; const [, forceRender] = useReducer((s) =&gt; s + 1, 0); const store = useContext(Mycontext); // 获取state const selectedStateRef = useRef(null); selectedStateRef.current = selector(store.getState()); // 更新回调 对比更新后的state const checkUpdates = useCallback(() =&gt; &#123; const newState = selector(store.getState()); if (newState !== selectedStateRef.current) &#123; forceRender(); &#125; &#125;, []); // mounted的时候订阅store useEffect(() =&gt; &#123; const unsubscribe = store.subscribe(checkUpdates); // 卸载的时候取消订阅 return unsubscribe; &#125;, [store, checkUpdates]); // 返回最新的state return selectedStateRef.current;&#125;; useDispatch使用： 参考 (一份详尽的 React re-render 指南)[https://mp.weixin.qq.com/s/SH7N2f5ZhUhysQ7_G2s9rQ]","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/react/"},{"name":"性能优化","slug":"性能优化","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/性能优化/"}]},{"title":"webpack构建速度优化","slug":"webpack构建速度优化","date":"2020-02-13T09:51:57.000Z","updated":"2023-04-18T06:44:34.841Z","comments":true,"path":"2020/02/13/webpack构建速度优化/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2020/02/13/webpack构建速度优化/","excerpt":"","text":"webpack打包原理回顾 解析入口文件：Webpack 会从配置文件中读取入口文件的路径，然后解析入口文件，如果入口文件引入了别的文件，webpack就要先将这些文件一个一个的读取完毕，当然读取的代码里面可能有html、css等格式，所以webpack会利用一些loader将这些格式转换成js格式，生成一个抽象语法树 加载模块：Webpack 会根据依赖图中的信息，递归地加载所有需要的模块。对于每个模块，Webpack 会根据其类型（例如 JavaScript、CSS、图片等）使用相应的 loader 进行转换和处理。 分析模块间的依赖关系：Webpack 会分析每个模块之间的依赖关系，并生成一张依赖图谱。这个过程中，Webpack 会确定每个模块的执行顺序，并创建一个 chunk。 生成输出文件：最后，Webpack 会根据 chunk 的信息，生成一个或多个输出文件。输出文件可以是 JavaScript 文件、CSS 文件、图片文件等。关注到上面的过程，可以发现主要优化的就是第二步以及第三步拆分多入口webpack对于单入口文件，每个入口文件把自己所依赖的资源全部打包到一起，即使一个资源循环加载的话，也只会打包一份，因此如果是一个比较大的应用的话，可以拆分成多个入口，这里拆分可以是按照页面拆分或者。。。1234entry: &#123; minivideo: 'src/pages/miniVideo/index.jsx', minivideoHome: 'src/pages/home/index.jsx', &#125; 提取公共包一个多页面应用，如果所有的页面都依赖于一样的基础库，那如果所有的entry都包含有基础库的代码就会造成浪费 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// webpack.config.jsconst path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; // 单入口 // entry: './src/main.js', // 多入口 entry: &#123; main: \"./src/main.js\", app: \"./src/app.js\", &#125;, output: &#123; path: path.resolve(__dirname, \"./dist\"), // [name]是webpack命名规则，使用chunk的name作为输出的文件名。 // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。 // chunk的name是啥呢？ 比如： entry中xxx: \"./src/xxx.js\", name就是xxx。注意是前面的xxx，和文件名无关。 // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的) filename: \"js/[name].js\", clean: true, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: \"./public/index.html\", &#125;), ], mode: \"production\", optimization: &#123; // 代码分割配置 splitChunks: &#123; chunks: \"all\", // 对所有模块都进行分 // 修改配置 cacheGroups: &#123; // 组，哪些模块要打包到一个组 // defaultVendors: &#123; // 组名 // test: /[\\\\/]node_modules[\\\\/]/, // 需要打包到一起的模块 // priority: -10, // 权重（越大越高） // reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块 // &#125;, default: &#123; // 其他没有写的配置会使用上面的默认值 minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积 minChunks: 2, priority: -20, reuseExistingChunk: true, &#125;, &#125;, &#125;, &#125;,&#125;; 减少依赖处理时间 CDN分包之前对打包体积进行分析的时候，发现react-dom、react是占据体积非常大的几个包，在打包这些包的时候就非常耗时。cdn分包可以让我们在打包过程中将特定包分离出来，从而提升打包速度。排除部分库的打包需要借助html-webpack-externals-plugin 插件减少loader解析转换时间 打包速度分析： 1yarn add speed-measure-webpack-plugin -D 我们借助 speed-measure-webpack-plugin 插件，它分析 webpack 的总打包耗时以及每个 plugin 和 loader 的打包耗时，从而让我们对打包时间较长的部分进行针对性优化。 多进程构建 对于耗时较长的模块，同时开启多个 nodejs 进程进行构建thread-loader：将原有的 webpack 对 loader 的执行过程从单一进程的形式扩展成多进程模式，来加速代码构建 缩小构建范围 构建过程是默认全局查找，这非常的耗时。通过手动配置rules中的文件查找范围test、include可以减少打包的范围，从而提升打包的速度。 123456789101112module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.js$/, use: ['babel-loader'], exclude: /node_modules/, &#125;, ], &#125;,&#125;; 缓存Eslint 检查 和 Babel 编译结果 每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。 12345678910111213141516171819202122&#123; test: /\\.js$/, // exclude: /node_modules/, // 排除node_modules代码不编译 include: path.resolve(__dirname, \"../src\"), // 也可以用包含 loader: \"babel-loader\", options: &#123; cacheDirectory: true, // 开启babel编译缓存 cacheCompression: false, // 缓存文件不要压缩 &#125;, &#125;,// eslint new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, \"../src\"), exclude: \"node_modules\", // 默认值 cache: true, // 开启缓存 // 缓存目录 cacheLocation: path.resolve( __dirname, \"../node_modules/.cache/.eslintcache\" ), &#125;), 配置oneOf 使得匹配上一个 loader, 剩下的就不再匹配了，解决打包时每个文件都会经过所有 loader 处理，虽然因为 test 正则原因实际没有处理上，但是都要过一遍。比较慢的问题 1234567891011121314151617181920212223242526272829303132333435363738const path = require(\"path\");const ESLintWebpackPlugin = require(\"eslint-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; entry: \"./src/main.js\", output: &#123; path: undefined, // 开发模式没有输出，不需要指定输出目录 filename: \"static/js/main.js\", // 将 js 文件输出到 static/js 目录中 // clean: true, // 开发模式没有输出，不需要清空输出结果 &#125;, module: &#123; rules: [ &#123; oneOf: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [\"style-loader\", \"css-loader\"], &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: \"asset/resource\", generator: &#123; filename: \"static/media/[hash:8][ext][query]\", &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: \"babel-loader\", &#125;, ], &#125;, ], &#125;, 缓存生成的 webpack 模块和 chunkwebpack5 内置了 cache 模块，缓存生成的 webpack 模块和 chunk，来改善构建速度。它在开发环境下会默认设置为 type: &#39;memory&#39; 而在生产环境中被禁用。可以通过设置 cache: { type: &#39;filesystem&#39; }来开放更多配置项比如我在webpack.config.js中如下配置： 1module.exports = &#123; cache: &#123; type: 'filesystem', &#125;, &#125;; 那么第一次打包后，就会在node_modules文件夹下面生成一个cache文件夹，从而第二次打包速度显著提升。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"算法填坑","slug":"算法填坑","date":"2020-01-06T14:06:55.000Z","updated":"2023-04-02T14:00:30.296Z","comments":true,"path":"2020/01/06/算法填坑/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2020/01/06/算法填坑/","excerpt":"","text":"贪心法方法是从某一起点开始，在每一个解决问题步骤中使用贪心原则，即采取在当前状态下最有利或者是最优化的选择，贪心法常用于找出图的最小生成树，最短路径，哈夫曼编码等等应用：在一定的时间之内上完尽量多的课程策略：每次选择最早结束的课程 123456789101112131415161718192021# 首先将已选课程的列表初始化为空，然后执行贪心算法def executeSchedule(courses,selectionRule): selectedCourses = [] while len(courses) &gt; 0: selCourse = earliestFinishTime(courses) selectedCourses.append(selCourse) courses = removeConflictingCourses(selCourse,courses) return selectedCoursesdef earliestFinishTime(courses): earliestFinishTime = courses[0] for i in courses: if i[1] &lt; earliestFinishTime[1]: earliestFinishTime = i return earliestFinishTime# 排除已选课程中与当前选中的课程冲突的课程def removeConflictingCourses(selCourse,courses): noConflictingCourses = [] for s in courses: if s[1] &lt;= selCourse[0] or s[0] &gt;= selCourse[1]: noConflictingCourses.append(s) return noConflictingCourses 动态规划法也是将一个问题拆解成若干个子问题，但是跟分治法不一样的是它会将每一个子问题的答案存储起来，以供下次求解的时候使用，这样能够减少计算的时间 回溯一种可以找出所有解或者是一部分解的算法，一旦发现不正常的数据就不再继续，而是会回到上一层 递归分治应用：一堆真币中有一个是假的，假币的重于真的，找出假币 123456789101112131415161718192021222324252627282930313233coinslist=[1,1,4,1,1,1]def coinComparison(coinslist): counter=0 currlist=coinslist while len(currlist) &gt; 1: group1,group2,group3 = splitCoins(currlist) currlist = findFakeGroup(group1,group2,group3) counter+=1 fake=currlist[0]def findFakeGroup(group1,group2,group3): resultland2 = compare(group1,group2) if resultland2 == 'left': fakeGroup = group1 elif resultland2 == 'right' fakeGroup = group2 elif resultland2 == 'equal' fakeGroup = group3 return fakeGroupdef compare(groupA,groupB): if sum(groupA)&gt;sum(groupB): result = 'left' elif sum(groupB)&gt;sum(groupA): result = 'right' else: result = 'equal' return resultdef splitCoins(coinslist): length = len(coinslist) group1=coinslist[0:length//3] group2=coinslist[length//3:length//3*2] group3=coinslist[length//3*2:length] return group1,group2,group3 记忆递归应用：有以下的硬币，需要选择部分硬币使得他们的和最大化，并且不能选择相邻的硬币1 3 2 44 5 1234567891011121314151617def coins(row,memo): if len(row) == 0: memo[0] = 0 return 0,memo elif len(row) == 1: memo[1] = row[0] return row[0],memo try: retukrn (memo[len(row)],memo) except KeyError: # 对应选中第一枚硬币 pick = coins(row[2:],memo)[0]+row[0]) # 对应跳过第一枚硬币 skip = coins(row[1:],memo)[0] result = max(pick,skip) memo[len(row)] = result return (result,memo) 图的广度优先搜索应用：六度分隔，每个人与其他任何人都只需要经过六步以内的介绍，分隔度指的是每一个人之间的最大分隔度 12345678910111213141516171819202122232425262728small = &#123; &apos;A&apos;:[&apos;B&apos;,&apos;C&apos;], &apos;B&apos;:[&apos;A&apos;,&apos;C&apos;]&#125;def degreesOfSeparation(graph,start): if start not in graph: return -1 visited = set() frontier = set() degrees=0 visited.add(start) frontier.add(start) while len(frontier) &gt; 0: print(frontier,&apos;:&apos;,degrees) degrees += 1 newfront = set() for g in frontier: for next in graph[g]: if next not in visited: visited.add(next) newfront.add(next) # 将当前先锋设置为新的先锋 frontier = newfront return degrees -=1degreesOfSeparation(small,&apos;A&apos;)# &#123;&apos;A&apos;&#125;:0# &#123;&apos;C&apos;,&apos;B&apos;&#125;:1# ...","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/算法/"}]},{"title":"日常记录","slug":"记录","date":"2020-01-06T13:51:48.000Z","updated":"2023-04-16T09:13:30.906Z","comments":true,"path":"2020/01/06/记录/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2020/01/06/记录/","excerpt":"","text":"年前的空档期去了某厂搬砖，感慨生活的不易的同时深感靠知识赚钱是一件多么幸福的事情，突然极度渴望迅速提升自己的技术水平，渴望依靠技术而不是机械性的劳动赚钱。 过完年就 23 岁了，能享受年轻的日子已经不多了，三年之后开始衰老，不再是小鲜肉，可能不再有少年的激情，可能会安于现状，一心只想求稳，可能回首今天，会觉得这根本没什么大不了，因为我现在已经稳定下来了呀。。。想到这些，既觉得得到了安慰又觉得索然无味。 我到底想要过怎样的人生？想要走什么样的职业道路？其实现在的我也不明确，未来的日子，道阻且长，唯一的愿望是希望自己可以少留遗憾，能一路向前不要回头吧。。。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/生活/"}]},{"title":"面试中的编程题","slug":"面试中的编程题～不定期更新","date":"2019-12-24T09:46:29.000Z","updated":"2023-04-19T02:22:21.044Z","comments":true,"path":"2019/12/24/面试中的编程题～不定期更新/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/24/面试中的编程题～不定期更新/","excerpt":"","text":"求多个数组的交集 12345678function jiaojiArr(a,b)&#123; return new Set([...a].filter(item=&gt;b.includes(item)))&#125;function getJiaoji(...arrs)&#123;return arrs.reduce((jiaoji,arr)=&gt;&#123;return Array.from(jiaojiArr(jiaoji,arr))&#125;)&#125; 实现indexof 12345678910111213Array.prototype.indexOf=function (target,start=0)&#123; let str=this.slice(start).join(',') let strArr=str.split(`$&#123;target&#125;,`) if(strArr.length===1)&#123; return -1 &#125; return strArr[0].split(',').length - 1+start&#125;String.prototype.indexOf=function(target,start=0)&#123; let str=this.slice(start) let result=str.replace(new RegExp(`$&#123;target&#125;\\\\w+`,'g'),'').length+start return result===this.length? -1 : result&#125; 判断链表中是否存在环 思路：设置一个 slow 指针 slow = slow-&gt;next，一个 fast 指针 fast = fast-&gt;next-&gt;next。因为 fast 指针移动的比 slow 快，要是有环的话一定会相遇 12345678910111213141516171819202122232425262728293031function linknode(x)&#123;this.val=xthis.next=null&#125;class linklist()&#123;constructor(x)&#123; this.head=new linknode(x)&#125;append(x)&#123; const newnode=new linknode(x) let current=this.head while(current.next)&#123;current=current.next &#125; current.next=newnode&#125;judge()&#123; if(!this.head.next)&#123; return false &#125;let fast=this.head.next.nextlet low=this.head.nextwhile(fast.next)&#123; if(fast.next===low.next)&#123; return true &#125; fast=fast.next.next low=low.next&#125;&#125;&#125; 从数组中取得随机数不能有重复的 12345678910111213function getRandomNumFromArr(arr, count) &#123; if (count &gt;= arr.length) &#123; return arr &#125; let result = [] while (result.length &lt; count) &#123; let random = Math.floor(Math.random() * (arr.length-1)) if (!result.includes(arr[random])) &#123; result.push(arr[random]) &#125; &#125; return result&#125; 实现add函数 1234567891011121314151617function add(n) &#123; let fn = function(m) &#123; return add(n + m) &#125; // valueOf 在 算术运算时生效如 +add(2)(3) fn.valueOf = function() &#123; return n &#125; // toString 在 转换为字符串时调用 add(2)(3) fn.toString = function() &#123; return '' + n &#125; return fn&#125;add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 6 获得所有父级的ID 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const data = [ &#123; id: '1', name: 'test1', children: [ &#123; id: '11', name: 'test11', children: [ &#123; id: '111', name: 'test111' &#125; ] &#125;, &#123; id: '12', name: 'test12', children: [ &#123; id: '121', name: 'test121' &#125; ] &#125; ] &#125;]// 正则表达式版function getParentId(data) &#123; const str = JSON.stringify(data) const childReg = /\\&#123;[^&#123;&#125;]+\\&#125;/g const childCollects = str.match(chilReg) const idReg = /(?&lt;=id\\\":\\\")\\d+/g const childIdCollects = childCollects.map((child) =&gt; child.match(idReg)[0]) const totalIdCollects = str.match(idReg) return totalIdCollects.filter((item) =&gt; !childIdCollects.includes(item))&#125;// DFSfunction getParentId(data) &#123; let result = &#123;&#125; ;(function(data) &#123; const parents = data.filter((item) =&gt; 'children' in item) parents.reduce((obj, item) =&gt; &#123; obj[item.id] = Symbol() return obj &#125;, result) for (let k of parents) &#123; arguments.callee(k.children) &#125; &#125;)(data) return result&#125; 深度合并两个对象 1234567891011121314151617function mergeDeep(target, obj) &#123; let result = &#123; ...target&#125; ;(function merge(origin, obj) &#123; for (let k in obj) &#123; if ( typeof origin[k] !== 'object' || typeof obj[k] !== 'object' || Array.isArray(origin[k]) !== Array.isArray(obj[k]) ) &#123; origin[k] = obj[k] &#125; else &#123; merge(origin[k], obj[k]) &#125; &#125; &#125;)(result, obj) return result&#125;","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/面经/"}]},{"title":"面经css篇","slug":"面经css篇","date":"2019-12-18T13:58:19.000Z","updated":"2023-04-02T14:00:30.292Z","comments":true,"path":"2019/12/18/面经css篇/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/18/面经css篇/","excerpt":"","text":"水平垂直居中的各种姿势，补充 gird布局 1234567div.parent &#123; display: grid;&#125;div.child &#123; justify-self: center; align-self: center;&#125; flex 123456div.parent&#123; display:flex;&#125;div.child&#123; margin:auto;&#125; link vs @import当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。 line-height 2 与200% 父元素设置line-height: 200%;属性时 父元素设置这个属性后，其所有子元素的行高都是一个具体的值，即他们父元素字体大小的200%。下例可看出子元素的行高都一致，即父元素字体大小的2倍，32px。 父元素设置line-height: 2;属性时 父元素设置这个属性后，其所有子元素的行高都是自身字体大小的2倍。下例可看出子元素的行高都是不一致的","categories":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/面经/"},{"name":"css","slug":"面经/css","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/面经/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/css/"}]},{"title":"面经浏览器篇","slug":"面经计算机网络篇","date":"2019-12-12T03:37:37.000Z","updated":"2023-04-02T14:00:30.298Z","comments":true,"path":"2019/12/12/面经计算机网络篇/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/12/面经计算机网络篇/","excerpt":"","text":"Http请求中的keep-alive在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。 浏览器为什么要限制get请求的参数的长度是因为url的长度会被限制 HTTPS 握手过程中，客户端如何验证证书的合法性（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 get与post在缓存方面的区别get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 四种存储 cookie的生存时间如果不设置过期时间expires，则表示这个 cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。 如果设置了过期时间，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。 session session的本质：就是存储在服务器上的一个哈希表。 将sessionID（随机数） 通过 Cookie 发给客户端客户端访问服务器时，服务器读取 sessionID服务器有一块内存（哈希表）保存了所有 session通过sessionID 后台可以得到对应用户的隐私信息，如 id，email这块内存（哈希表）就是服务器上的所有 session 为什么会有 session? cookie能被用户截取 不安全之前的写法：直接将数据放到cookie里面：1response.setHeader('Set-Cookie', `login_email=$&#123;email&#125;`) 这样写一来会暴露用户的个人信息，二来用户可以直接通过浏览器修改cookie，极有可能获取到别人的用户信息，极不安全。因此出现了下面的使用session的操作： 12345let sessions = &#123;&#125;let sessionId = Math.random() * 10000 // 设置sessionId 为一个随机数sessions[sessionId] = &#123;login_email:email&#125; // 将email 存储在sessions这个对象中response.setHeader('Set-Cookie', `sessionId = $&#123;sessionId&#125;`) // cookie中存储的是 sessionId 这个随机数 首先来解释一下上面的代码：即设置cookie的中存储的值为一个随机数，当后台获取到cookie时，就可以获取到该随机数并在sessions这个对象中查找key为这个随机数的value，即可知道用户的邮箱是什么 。 不基于cookie能否实现session后端待用户登陆后设置他的sessionID，但不把它放在 cookie 里，而是将信息通过响应体传JSON给前端。前端拿到响应体中的JSON后将其转换成对象（JSON.parse）将从JSON中获取到的数据（如 sessionID）放在 localStorage 里面（localStorage里的数据目前暂时用不到）以后跳转到其他页面（如首页）时，将 sessionID 放在 URL 的查询参数里（如：window.location.href = ‘/?sessionId=object.sessionId’）那么进入首页后，该页面的 URL 的查询参数就带上了你的sessionID后端通过在用户访问首页时，传到服务器的 URL ，来获取到查询参数，从而获取到用户的 sessionID，然后在数据库中查到sessionID对应的信息就可以知道用户是谁。 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的1x1 像素的透明 gif 图片；why? 没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax）不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）在所有图片中，体积最小；（比较PNG/JPG） cookie 和 localStorage 的区别是什么答：cookie 每次请求会被带给服务器，而 localStorage不会；cookie的最大储存量一般只有4k，而localStorage 一般有5Mb sessionstorage跟localstorage的区别localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。 tcp的流量控制与拥塞控制 流量控制 （实现：主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。）如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。 流量控制与拥塞控制的区别拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的 域名解析1、浏览器中输入想要访问的网站的域名，操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。2、如果hosts里没有这个域名的映射，客户端会向本地DNS服务器发起查询。本地DNS服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。3、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。 递归查询 迭代查询 浏览器安全 CSRF 的防御 1、尽量使用 POST，限制 GETGET 接口太容易被拿来做 CSRF 攻击，看上面示例就知道，只要构造一个 img 标签，而 img 标签又是不能过滤的数据。接口最好限制为 POST 使用，GET 则无效，降低攻击风险。当然 POST 并不是万无一失，攻击者只要构造一个 form 就可以，但需要在第三方页面做，这样就增加暴露的可能性。2、将 cookie 设置为 HttpOnlyCRSF 攻击很大程度上是利用了浏览器的 cookie，为了防止站内的 XSS 漏洞盗取 cookie,需要在 cookie 中设置“HttpOnly”属性，这样通过程序（如 JavaScript 脚本、Applet 等）就无法读取到 cookie 信息，避免了攻击者伪造 cookie 的情况出现。在 Java 的 Servlet 的 API 中设置 cookie 为 HttpOnly 的代码如下：response.setHeader( “Set-Cookie”, “cookiename=cookievalue;HttpOnly”);3、增加 tokenCSRF 攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的 cookie 来通过安全验证。由此可知，抵御 CSRF 攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于 cookie 之中。鉴于此，系统开发人员可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求。假设请求通过 POST 方式提交，则可以在相应的表单中增加一个隐藏域：token 的值通过服务端生成，表单提交后 token 的值通过 POST 请求与参数一同带到服务端，每次会话可以使用相同的 token，会话过期，则 token 失效，攻击者因无法获取到 token，也就无法伪造请求。 note: 1、要确保同一页面中每个表单都含有自己唯一的令牌 2、验证后需要删除相应的随机数 3、Token 保存在 Session 中。假如 Token 保存在 Cookie 中，用户浏览器开了很多页面。在一些页面 Token 被使用消耗掉后新的Token 会被重新种入，但那些老的 Tab 页面对应的 HTML 里还是老 Token。这会让用户觉得为啥几分钟前打开的页面不能正常提交？在 session 中添加 token 的实现代码： 12345HttpSession session = request.getSession();Object token = session.getAttribute(\"_token\");if(token == null I I \"\".equals(token)) &#123; session.setAttribute(\"_token\", UUID.randomUUIDO .toString());&#125; 4、通过 Referer 识别根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的 URL（本例为 www.xxx. com/transfer.do）。如果攻击者要对银行网站实施 CSRF 攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的 Referer 的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值即可，如果是以 www.xx.om 域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果 Referer 是其他网站，就有可能是 CSRF 攻击，则拒绝该请求。取得 HTTP 请求 Referer：String referer = request.getHeader(“Referer”);5.使用验证码 xss攻击方式以及防御 中间人攻击中间人攻击过程如下： 服务器向客户端发送公钥。攻击者截获公钥，保留在自己手上。然后攻击者自己生成一个【伪造的】公钥，发给客户端。客户端收到伪造的公钥后，生成加密hash值发给服务器。攻击者获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。服务器用私钥解密获得假秘钥。服务器用加秘钥加密传输信息防范方法： 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性强制页面使用https 防御中间人攻击 123function requestHandler(req, res)&#123; res.setHeader('Strict-Transport-Security','max-age=31536000; includeSubDomains; preload');&#125; 深入了解浏览器缓存机制https://www.jianshu.com/p/54cc04190252补充：关于强缓存取资源的位置如果开启了Service Worker首先会从Service Worker中拿如果新开一个以前打开过的页面缓存会从Disk Cache中拿（前提是命中强缓存）刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是 从Disk Cache中拿(可以看到下图最后几个文件有时候是从 Memory Cache中拿有时候是从Disk Cache中拿) 303与302的区别303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。 websoket http之间的联系 都是一样基于TCP的，都是可靠性传输协议。 都是应用层协议。 WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。 WebSocket连接的过程是： 首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。 http keepaliveHttp keep-alive在 HTTP 1.0 时期，每个 TCP 连接只会被一个 HTTP Transaction（请求加响应）使用，请求时建立，请求完成释放连接。当网页内容越来越复杂，包含大量图片、CSS 等资源之后，这种模式效率就显得太低了。所以，在 HTTP 1.1 中，引入了 HTTP persistent connection 的概念，也称为 HTTP keep-alive，目的是复用TCP连接，在一个TCP连接上进行多次的HTTP请求从而提高性能。 tcp keepalive在使用TCP长连接（复用已建立TCP连接）的场景下，需要对TCP连接进行保活，避免被网关干掉连接。在应用层，可以通过定时发送心跳包的方式实现。 数字签名工作原理https://blog.51cto.com/winda/1968298 参考文章 浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等 安全|常见的Web攻击手段之CSRF攻击 前端 100 问：能搞懂80%的请把简历给我","categories":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/面经/"},{"name":"浏览器","slug":"面经/浏览器","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/面经/浏览器/"}],"tags":[]},{"title":"秋季前端面经记录","slug":"秋季前端面经记录","date":"2019-12-11T09:16:23.000Z","updated":"2023-04-02T14:00:30.297Z","comments":true,"path":"2019/12/11/秋季前端面经记录/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/11/秋季前端面经记录/","excerpt":"","text":"问到sessionstorage跟localstorage的区别 答前者只在当前窗口有效是对的 再问一遍又不确定了 说明基础不牢固容易被套路 存储大小： 都为 5MB 存储位置： 都在客户端，不予服务器进行交互通信 存储内容类型： 字符串，复杂的对象可以使用 ECMAScript 提供的 JSON stringify 和 parse 来处理 获取方式：window.localStorage, window.sessionStorage 应用场景： localStorage 用于长期登录 and 判断用户是否已登录sessionStorage 敏感账号一次性登录 页面卡顿 怎么监测到是哪一部分的代码出现了问题火焰图(可以看到每个函数占据的宽度，越宽表示执行的时间越长) 要是不用框架的话 怎么优化代码的结构？MVVM又称状态机制，View 和 ViewModel 是进行绑定的，改变 ViewModel 就会直接作用到 View 视图上，而 View 会把事件传递给 ViewModel,ViewModel 去对 Model 进行操作并接受更新。 View：UI 界面 ViewModel：它是 View 的抽象，负责 View 与 Model 之间信息转换，将 View 的 Command 传送到 Model；比起 MVP 中 View 需要自己提供 API，MVVM 在 VM 中构建一组状态数据（state data），作为 View 状态的抽象。然后通过双向数据绑定（data binding）使 VM 中的状态数据（state data）与 View 中的显示状态（screen state）保持一致。这样，VM 中的展示逻辑只需要修改对应的状态数据，就可以控制 View 的状态，从而避免在 View 上开发大量的接口 Model：数据访问层 ？不适合 SEO？ 例如，我们定义好一个 JavaScript 对象作为 Model，并且把这个 Model 的两个属性绑定到 DOM 节点上： MVCView 持有了 Controller，把事件传递给 Controller，Controller 由此去触发 Model 层的事件，Model 更新完数据（网络或者本地数据）之后触发 View 的更新事件 View 负责渲染用户界面，应该避免在 View 中涉及业务逻辑 Controller 负责接收用户输入，根据用户输入调用 Model 逻辑，将产生的结果交给 View 部分，让 View 渲染出必要的输出 Model 负责管理数据，大部分业务逻辑也应该放在 Model 缺点： 由于在实现的过程中，往往出现 View 与 Model 不经过 Controller 通信的现象，造成数据流混乱，难以维护和增加功能 mvc 与 mvvm 的区别MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变 拿典型的 MVVM 模式的代表，Vue，来举例html 部分相当于 View 层，可以看到这里的 View 通过通过模板语法来声明式的将数据渲染进 DOM 元素，当 ViewModel 对 Model 进行更新时，通过数据绑定更新到 View。 Vue 实例中的 data 相当于 Model 层，而 ViewModel 层的核心是 Vue 中的双向数据绑定，即 Model 变化时 VIew 可以实时更新，View 变化也能让 Model 发生变化。 跨域补充： cra 生成的项目支持在package.json字段设置proxy如：will proxy your request to http://localhost:4000/api/todos as a fallback 1\"proxy\": \"http://localhost:4000\", 本地测试用 配置 hosts 文件 如：’127.0.0.1 xx.com’或者是配置 switchyomega 比如输入 test.xxx.com 代理到 localhost 这样发请求的时候的 origin 是 test 就不会出现跨域错误 （midc 有些接口是能跨域的，所以 origin 是 localhost 的时候也不会报错） postmessage+iframe 性能优化 （不要一直说 react）虚拟 dom就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。 1234567891011121314151617&#123; tag: 'div', props: &#123; id: 'app' &#125;, chidren: [ &#123; tag: 'p', props: &#123; className: 'text' &#125;, chidren: [ 'hello world!!!' ] &#125; ]&#125; 主流的虚拟 DOM 库（snabbdom、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。 虚拟 dom 的优势减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI 深浅拷贝的区别 怎么深拷贝一个函数 浅拷贝—浅拷贝是指复制对象的时候，只对第一层键值对进行独立的复制，如果对象内还有对象，则只能复制嵌套对象的地址 12// 浅拷贝数组a.slice() || a.concat() 深拷贝—深拷贝是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部一 一进行复制即可。 note! JSON.parse(JSON.stringify(obj))的缺陷是不能够拷贝函数 因为 JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。 解决JSON.stringify不能拷贝函数的问题 123456789101112131415161718192021222324252627function deepClone(source, hash = new WeakMap()) &#123; let obj const Constructor = source.constructor switch (Constructor) &#123; case Date: obj = new Constructor(source.getTime()) break case RegExp: obj = new Constructor(source) break default: if (hash.has(source)) &#123; return hash.get(source) &#125; obj = new Constructor() hash.set(source, obj) break &#125; for (let key in source) &#123; obj[key] = isObject(source[key]) ? deepClone(source[key], hash) : source[key] &#125; return obj&#125; doctype 的作用声明了的话浏览器就会使用标准模式解析页面 这样所有浏览器显示的样式就是一样的 使用symbol会遇到哪些问题 symbol的特点1.Symbol(‘key’) !== Symbol(‘key’) //true,返回不同2.Symbol(“know”).name = 1; // TypeError,只读3.for…in 、 Object.keys(obj) 、Object.getOwnPropertyNames(obj)会忽略 Symbol,即自身不可枚举 4.不能用 obj.prop 的形式访问 symbol的使用场景第一个作用是作为属性名避免属性名冲突，第二个作用是替代代码中多次使用的字符串（例如：abc），多次使用的字符串在代码中不易维护，而这时候定义一个对象的属性（属性名用 Symbol 格式），值为 abc，就可以作为全局变量来使用了。第三个，由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。第四个，这个有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 生成一个唯一值 因为我们在使用它的时候属性值是多少都无所谓 1234567var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol()&#125;race.protoss !== race.terran // true 基本数据类型的判断 typeof Symbol() === ‘symbol’ redux的原理（要深入 中间件）关于使用hooks实现reduxdispatch 一个 action 的时候将 action 传入所有的 reducers,然后返回更新的 state 同时触发使用subscribe方法注册的所有 listener 函数(为什么在 hasChanged 为 true 的时候还要接着调用后面的 reducers 呢？) 为什么reducer要是一个纯函数 react 有一个 shouldcomponentupdate 事件作为优化，当我们重渲染时也希望订阅事件能差异化更新以优化性能，怎么实现？比对一次更新里的新老 state当 reducer 是纯函数时，生成一个新 state，新老对象地址引用不一，能实现若 reducer 是副作用，那么虽然对象内变化，新老对象地址一致，不能实现此外在combinereducers中判断haschanged也是通过nextStateForKey !== previousStateForKey 直接判断引用而不是深度遍历比较两个对象的值 更简洁 如果不是纯函数 返回的 state 就具有不确定性 那么 UI 拿到的数据也具有不确定性 redux 中的观察者模式 store 提供数据的 get 钩子（store.getState）,不直接提供数据的 set，所以必须通过 dispatch（action）来 set 数据。 利用观察者模式（sub/ pub）连接 model 和 view 的中间对象。view 层通过调用 store.dispatch 方法触发 reducer 改变 model。对应 pub。 model 层通过调用 store.subscribe 注册视图更新事件（setstate），该事件会在数据改变之后被调用。对应 sub。 观察者模式和发布订阅模式的区别 关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。关于函数组件跟类式组件的区别props是不可变数据，永远不会改变。但是，this却始终是可变的 。所以通过this拿到的永远都是最新的值 123456789101112131415161718192021222324class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert('Followed ' + this.props.user) &#125; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000) &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt; &#125;&#125;function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert('Followed ' + props.user) &#125; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000) &#125; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;&#125; 当点击 follow 之后再切换用户的名字，三秒之后函数组件弹出来的依旧是点击 follow 的时候的用户的名字而类组件弹出来的却是切换之后的名字，是因为函数组件能捕获某一时刻的 props 与 state（hooks 也是一样的） 算法红黑树本质是一种二叉查找树，也就是左边的子节点的值比根节点小，右边的比根节点大，在极端情况下，比如连续插入依次递增或递减的节点，查找树将退化成链表红黑树通过如下的性质定义实现自平衡： 节点是红色或黑色。根是黑色。所有叶子都是黑色（叶子是 NIL 节点）。每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高） 实现模糊搜索结果的关键词高亮显示考虑节流、缓存。其实还可以上列表diff+定时清理缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function debounce(fn, timeout = 300) &#123; let t; return (...args) =&gt; &#123; if (t) &#123; clearTimeout(t); &#125; t = setTimeout(() =&gt; &#123; fn.apply(fn, args); &#125;, timeout); &#125; &#125;// data应该是一个很大的数组 为了减小cache占的内存 缓存用户输入过的关键词 function memorize(fn) &#123; const cache = new Map(); return (name) =&gt; &#123; if (!name) &#123; container.innerHTML = ''; return; &#125; if (cache.get(name)) &#123; container.innerHTML = cache.get(name); return; &#125; const res = fn.call(fn, name).join(''); cache.set(name, res); container.innerHTML = res; &#125; &#125; function handleInput(value) &#123; const reg = new RegExp(`\\($&#123;value&#125;\\)`); const search = data.reduce((res, cur) =&gt; &#123; if (reg.test(cur)) &#123; const match = RegExp.$1; res.push(`&lt;li&gt;$&#123;cur.replace(match, '&lt;bdi&gt;$&amp;&lt;/bdi&gt;')&#125;&lt;/li&gt;`); &#125; return res; &#125;, []); return search; &#125; const data = [\"上海野生动物园\", \"上饶野生动物园\", \"北京巷子\", \"上海中心\", \"上海黄埔江\", \"迪士尼上海\", \"陆家嘴上海中心\"] const container = document.querySelector('.container'); const memorizeInput = memorize(handleInput); document.querySelector('.inp').addEventListener('input', debounce(e =&gt; &#123; memorizeInput(e.target.value); &#125;)) 参考文章 虚拟 DOM 到底是什么 MVC 和 MVVM 的区别 React 函数组件和类组件的差异 “深拷贝” 与 “浅拷贝” 的区别，JS 实现深浅拷贝的几种方法 「每日一题」JS 中的 Symbol 是什么？ 前端 100 问：能搞懂 80%的请把简历给我","categories":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/面经/"}],"tags":[]},{"title":"面经项目构建篇","slug":"面经项目构建篇","date":"2019-12-11T02:58:38.000Z","updated":"2023-04-02T14:00:30.286Z","comments":true,"path":"2019/12/11/面经项目构建篇/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/11/面经项目构建篇/","excerpt":"","text":"怎么约束代码规范？结合lint-staged与husky 实现在每次提交之前 自动修复本次修改的代码 123456789101112131415161718&#123; \"scripts\": &#123; \"precommit\": \"lint-staged\" //这个钩子是在安装husky之后才有的 package.json中原有的钩子:https://segmentfault.com/a/1190000008832423 &#125;, \"lint-staged\": &#123; \"src/**/*.js\": [\"eslint --fix\", \"git add\"] &#125;&#125;// 或者使用下面的配置，自动格式化代码（谨慎使用）：&#123; \"scripts\": &#123; \"precommit\": \"lint-staged\" &#125;, \"lint-staged\": &#123; \"src/**/*.js\": [\"prettier --write\", \"git add\"] &#125;&#125; webpack打包优化 定位体积大的模块 - webpack-bundle-analyzer 移除不必要的文件使用webpack自带的两个库 IgnorePlugin ContextReplacementPlugin 12345678910// 插件配置plugins: [ // 忽略moment.js中所有的locale文件 new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),],// 使用方式const moment = require('moment');// 引入zh-cn locale文件require('moment/locale/zh-cn');moment.locale('zh-cn'); 模块化引用 1234import &#123;chain, cloneDeep&#125; from 'lodash';// 可以改写为import chain from 'lodash/chain';import cloneDeep from 'lodash/cloneDeep'; 通过CDN引用 服务端开启Gzip压缩开启gzip压缩可以减少HTTP传输的数据量和时间，从而减少客户端请求的响应时间 splitChunks配置代码分割此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 webpack 热更新原理在 webpack 中，都是模块且有唯一标识。在 webpack 编译完成后，将修改的模块 hash 对应的模块重新执行。就达到了局部刷新的效果。 过程webpack-dev-middleware 是用来处理文件打包到哪里，到内存读取速度更快。devServer 在监听 compiler done 后，利用 socket 告诉 devServer/client 修改模块的 hashHMR.runtime 利用 HTTP 请求 hash.hot-update.json 获取更新模块列表 hotDownloadManifest{“h”:”11ba55af05df7c2d3d13”,”c”:{“index-wrap”:true}}再通过 HTTP (jsonp) 获取更新模块的 jsindex-wrap.7466b9e256c084c8463f.hot-update.js返回执行 123webpackHotUpdate(\"index-wrap\", &#123; // ....&#125;) webpackHotUpdate 做了三件事找到过期的模块和依赖并从缓存中删除 12delete installedModules[moduleId];delete outdatedDependencies[moduleId]; 遍历所有的 module.children，重新 installedModules 所有的子模块最后将自身模块的内容做替换修改 1modules[moduleId] = appliedUpdate[moduleId] 最后代码替换之后并没有重新执行，需要手动注册需要重新执行的模块方法 123456if (module.hot) &#123; module.hot.accept('./print.js', function() &#123; console.log('Accepting the updated printMe module!'); printMe(); &#125;) &#125; 国际化方案后端在cookie中设置applocal字段 前端再去拿。。。 参考文章 [用 husky 和 lint-staged 构建超溜的代码检查工作流](用 husky 和 lint-staged 构建超溜的代码检查工作流) Webpack打包优化 轻松理解webpack热更新原理","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/配置/"}]},{"title":"面经js篇","slug":"面经js篇","date":"2019-12-10T10:48:35.000Z","updated":"2023-04-19T02:22:09.880Z","comments":true,"path":"2019/12/10/面经js篇/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/10/面经js篇/","excerpt":"","text":"原生 jstypeof的原理js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 👉 000：对象010：浮点数100：字符串110：布尔1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。null：所有机器码均为 0undefined：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 instanceof的原理通过判断右边的变量的prototype是否在左边的变量的原型链上 123456789101112function myInstanceOf(leftVal, rightVal) &#123; let rightProto = rightVal.prototype let leftCopy = leftVal.__proto__ while (true) &#123; if (leftCopy === null) &#123; return false &#125; else if (leftCopy === rightProto) &#123; return true &#125; leftCopy = leftCopy.__proto__ &#125;&#125; 生成指定范围内的随机数1234function RandomNum (min, max) &#123; let range = max - min return Math.round(Math.random()*range) + min&#125; null undefined 的区别前者是一个特殊的对象 不会被垃圾回收机制回收 前者转换成数字是 0 后者是 NaN 函数参数是按值传递 为什么传一个对象进去 函数内部的修改会影响该对象传的是是栈内数据的拷贝简单数据类型传的是 值本身 （因为直接把值存在栈内）复杂数据类型传的是 对象在内存里面的地址 （因为复杂对象存在堆内，所以在栈里存对象所在的堆地址） 你觉得jQuery或zepto源码有哪些写的好的地方jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery;&#125;)( window ); 虚拟dom 为什么直接操作dom耗时v8 binding会将原生的dom对象（比如document.a)映射成包装的js对象，所以执行document.a=。。。很快但是document.title=。。。很慢是因为修改title的时候同时也修改了 DOM 对象的 attributes此外很多时候操作dom都会引起重绘与回流 并且很多dom api的读写都会设计页面布局的重新计算以确保返回值的准确 虚拟dom不快 为什么react快 React is fast because it only manipulates the DOM as much as it needs to,Updating changes is much faster than re-building the entire DOM tree from scratch. It’s able to do this because it keeps the virtual DOM representation from the last time we updated or rendered our component in memory. It then compares the two versions and updates the changes. React Virtual DOM is an object,when we create an webpage browser create dom in a tree manner. to find the changes in two different trees &gt;time complexity is O(n^3) but REACT DIFF algorithm can able to do it in O(n) time by using keys of each node.that is why react is faster 为什么虚拟dom性能更好 传统MVC框架,如backbone,它是将某个模板编译成模板函数,需要更新时,是自己手动将数据整体传入模板函数, 得到一个字符串,使用innerHTML刷新某个容器!注意,这里其实可以优化,但由于是手动,是体力活,都是使用很粗放型的innerhTML了事 (使用jQuery的html方法性能会更差,不过好处是它处理了IE下的innerHTML BUG及全平台的无法执行内部的script标签的BUG) 由于整体替换,一下子销毁这么多元素(有时还绑着事件,可能导致GC出问题),又要插入这么多元素,再重新绑定事件(这个可以使用事件代理缓解) 因此性能非常差 knockout那样, 使用时让用户痛苦一些,使用可同步视图的东西用函数(wrapper)包裹起来, 刷新视图,就只需要重新调用这个wrapper.现在所有新的MVVM都是从ko那里学到依赖收集. 这个wraper会通知其依赖的wrapper,通过极其痛苦晦涩的方式进入事件总线, 执行视图刷新函数. knockout是使用闭包用到极致的库,显然这样做性能也很差. 最后react, 首先使用编译手段(jsx的虚拟DOM转换), 将这部分消耗能提前释放出去, 不过将字符串(jsx模板)转换为一个个JS对象,也占不了多少内存. 然后是数据发生变动时, 由于数据变动都是需要用setState方法,因此兼容性很好, 少了Object.defineProperty或wrapper的消耗,然后对应数据通过render转换成字符串,字符串再转换虚拟DOM树 先后虚拟DOM进行比较, 更新视图. react是面向组件设计, 一个组件就是一个密封舱, 很少会对所有虚拟DOM进行比较, 由于强制使用单向流动, 减少每次变动需要的diff. 没有绑定对象与wrapper的内存占用高的问题. 实现函数柯里化123456789101112function curry(f) &#123; const context = this let args = [] return function(...arg) &#123; args = args.concat(arg) if (arg.length) &#123; return arguments.callee &#125; else &#123; return f.apply(context, arg) &#125; &#125;&#125; arguments.callee 与arguments.caller的区别1234567function f() &#123; // arguments.callee : [Function:f] // arguments.caller : [Function:g]&#125;function g() &#123; f()&#125; 类数组对象有哪些具有length属性的并且能使用索引访问的 比如arguments dom相关的数据结构 localstorage sesstionstorage.. 函数提升跟变量提升函数声明的优先级最高，会被提升至当前作用域最顶端 实现深拷贝循环递归实现12345678910111213141516171819202122232425262728293031var a = &#123; name: 'mary', age: 20, friend: &#123; name: '哈哈', age: 19, hobby: 'eat' &#125;&#125;function deep(obj) &#123; var newobj = &#123;&#125; for (var key in obj) &#123; // 此处遍历的key包括了实例对象和它原型的属性，所以要用hasOwnProperty进行筛选(node环境不会，浏览器环境会列举原型属性) if (obj.hasOwnProperty(key)) &#123; // 如果是基本类型则进行复制 if ( typeof obj[key] === 'number' || typeof obj[key] === 'string' || typeof obj[key] === 'boolean' || obj[key] === undefined || obj[key] === null ) &#123; newobj[key] = obj[key] // 如果不是则为array或者object,仍然需要深层次的递归复制 &#125; else &#123; newobj[key] = deep(obj[key]) &#125; &#125; &#125; return newobj&#125; load 事件与 DOMContentLoaded 事件,$(document).ready() 当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。 当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个，$(document).ready()可以同时编写多个，并且都可以得到执行,$(document).ready(function(){})可以简写成$(function(){}) 构造函数的返回值 构造函数不需要显示的返回值。使用 new 来创建对象(调用构造函数)时，如果 return 的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果 return 的是对象，则返回该对象(注：若 return null 也会忽略返回值）。 大数求和采用小时侯学加法时的手动计算的方法，从最低位依次相加，得到最后的结果因为对于较大的数js会自动采用科学记数法的方式表示，所以参与计算的参数用字符串表示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function getSum(d1, d2) &#123; // 如果第一个数较大则交换两个数 if (d1.length &lt; d2.length) &#123; [d1, d2] = [d2, d1]; &#125; // 将两个数转为数组形式 let [arr1, arr2] = [[...d1].reverse(), [...d2].reverse()]; // num用作当对应位数相加大于10时做进位 let num = 0; // 循环arr1.length次求和 for (let i = 0; i &lt; arr1.length; i++) &#123; if (arr2[i]) &#123; arr1[i] = Number.parseInt(arr1[i]) + Number.parseInt(arr2[i]) + num; &#125; else &#123; arr1[i] = Number.parseInt(arr1[i]) + num; &#125; if (arr1[i] &gt;= 10) &#123; [arr1[i], num] = [arr1[i] % 10, 1]; &#125; else &#123; num = 0; &#125; &#125; // 如果最后进位为1，则结果前应加1为 if (num === 1) &#123; arr1[arr1.length] = num; &#125; // 返回结果字符串 return arr1.reverse().join('');&#125;args=args.concat(arg)``` ### generator函数的使用场景* 多文件上传 上传完第一组文件之后暂停执行 做其他的事情 之后再继续上传 通过返回值done属性是否为真来判断能否继续执行* 生成具有index的enumerate结构 (返回的是iterator对象 能直接使用for in遍历，也能作为Array.from等的参数)### 深度比较两个对象1.通过json.parse(json.stringify)... 相等直接返回true2.object.keys.length不相等 返回false3.遍历 遇到为对象的属性递归### 实现 bind```js// 定义这个方法为myBindFunction.prototype.my_bind = function() &#123; var self = this, // 保存原函数 context = Array.prototype.shift.call(arguments), // 保存需要绑定的this上下文 // 上一行等价于 context = [].shift.call(arguments); args = Array.prototype.slice.call(arguments) // 剩余的参数转为数组 return function() &#123; // 返回一个新函数 self.apply( context, Array.prototype.concat.call(args, Array.prototype.slice.call(arguments)) ) &#125;&#125; promise的构造函数跟他的then方法是异步还是同步promise构造函数是同步执行的，then方法因为是微任务是异步执行的 模块化 为什么要模块化为了避免全局污染 思维导图https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map js类型转换 强制类型转换通过 Number()、parseInt()、parseFloat()、toString()、String()、Boolean(),进行强制类型转换。 隐式类型转换逻辑运算符(&amp;&amp;、 ||、 !)、运算符(+、-、*、/)、关系操作符(&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符(==)或者 if/while 的条件，可能会进行隐式类型转换。关于valueof tostring在数值运算里，会优先调用valueOf() 字符串运算优先调用后者 实现数组扁平化 方式一 1;[].concat.apply([], [[1], [2], [3]]) // [1, 2, 3] chrome 69 后数组自带 flat 方法 方式二 12345function flatten(arr) &#123; return arr.reduce(function(prev, item) &#123; return prev.concat(Array.isArray(item) ? flatten(item) : item) &#125;, [])&#125; 方式三 123456function flatten(arr)&#123; while(arr.some(item=&gt;Array.isArray(item))&#123; arr = [].concat(...arr); &#125; return arr;&#125; 实现[1,2].mutiple() = [1,2,1,4]1234Array.prototype.mutiple = function() &#123; const tail = this.map((item) =&gt; item ** 2) return [...this, ...tail]&#125; 实现compose函数1234567891011121314export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) // reduceright:将数组中每一项从右向左调用callback return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; var a3 = {name: “前端开发”}; var b3 = a3; a3 = null console.log(b3)?// {name: “前端开发”} 事件委托的优缺点 优点减少事件注册 减小内存 缺点有的事件不支持冒泡 0.1+0.2!=0.3十进制的 0.1 和 0.2 都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。JavaScript 代码:0.1 -&gt; 0.0001100110011001…(无限)0.2 -&gt; 0.0011001100110011…(无限)IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为：JavaScript 代码:0.0100110011001100110011001100110011001100110011001100因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差 怎么设置对象的属性不能被删除？definePropperty设置configurable falsewhy? https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete addeventListener的第三个参数是一个对象option,包括capture, passive,once选项 不支持这种写法的默认第三个参数是usecapture 几种判断数组类型的优缺点instanceof不能检测来自iframe的数组。就是window.frames[xx].Array构造出来的数组Array.isArray兼容性没那么好 为什么表单能跨域因为表单的请求一般都是提交数据 并且传统form表单提交浏览器会发生跳转 并且不需要返回响应数据 是安全的 为什么箭头函数不能使用new操作符因为它没有自己的this与prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto react 相关React 中 setState 什么时候是同步的，什么时候是异步的在 React 中，如果是由 React 引发的事件处理也就是合成事件（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数也就是原生事件，还有通过 setTimeout/setInterval 产生的异步调用。 原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 jsx 语法为什么 需要 import react 包JSX 语法只是一种语法糖，babel转译之后就会变成React.createElement react 生命周期变更的原因在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。 由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 componentWillMount、componentWillReceiveProps 和 componetWillUpdate 标记为 unsafe，并使用新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 进行替换。 组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。 两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些： componentWillReceivePropsshouldComponentUpdatecomponentWillUpdatecomponentWillMountrender getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。 reconciliation 阶段虚拟 dom 的数据对比 commit 阶段将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作 生命周期React16.3 开启异步渲染 新增的两个 getDerivedStateFromProps触发时间(v16.4 修正)：组件每次被 render 的时候，包括在组件构建之后(虚拟 dom 之后，实际 dom 挂载之前)，每次获取新的 props 或 state 之后。在 v16.3 版本时，组件 state 的更新不会触发该生命周期。每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state.配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法getDerivedStateFromProps 是一个静态函数，所以函数体内不能访问 this，输出完全由输入决定。 getSnapshotBeforeUpdate 触发时间: update 发生的时候，在 render 之后，在组件 dom 渲染之前。返回一个值，作为 componentDidUpdate 的第三个参数。配合 componentDidUpdate, 可以覆盖 componentWillUpdate 的所有用法 setState可以接受函数为参数吗？有什么作用？123this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); 关于componentDidCatch的触发时机componentDidCatch()componentDidCatch(err, info)任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。 错误边界不会捕获下面的错误： 事件处理 (Event handlers) （因为事件处理不发生在 React 渲染时，报错不影响渲染） 异步代码 (Asynchronous code) (e.g. setTimeout or requestAnimationFrame callbacks) 服务端渲染 (Server side rendering) 错误边界本身(而不是子组件)抛出的错误 补充：static getDerivedStateFromError此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state,可以在此生命周期中 更新 state 使下一次渲染可以显降级 UI。getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch() note: UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。 react-router 的原理react-router的实现原理 createBrowserHistory: 利用 HTML5 里面的 history createHashHistory: 通过 hash 来存储在不同状态下的 history 信息 createMemoryHistory: 在内存中进行历史记录的存储 link组件跟a标签的区别有onclick那就执行onclickclick的时候阻止a标签默认事件（这样子点击123就不会跳转和刷新页面）再取得跳转href（即是to），用history（前端路由两种方式之一，history &amp; hash）跳转，此时只是链接变了，并没有刷新页面 伪代码实现1234567891011121314151617181920212223242526272829303132333435// createBrowserHistory(HTML5)中的前进实现function finishTransition(location) &#123; ... const historyState = &#123; key &#125;; ... if (location.action === 'PUSH') ) &#123; window.history.pushState(historyState, null, path); &#125; else &#123; window.history.replaceState(historyState, null, path) &#125;&#125;// createHashHistory的内部实现function finishTransition(location) &#123; ... if (location.action === 'PUSH') ) &#123; window.location.hash = path; &#125; else &#123; window.location.replace( window.location.pathname + window.location.search + '#' + path ); &#125;&#125;// createMemoryHistory的内部实现entries = [];function finishTransition(location) &#123; ... switch (location.action) &#123; case 'PUSH': entries.push(location); break; case 'REPLACE': entries[current] = location; break; &#125;&#125; vue 相关 为什么组件的 data 必须是一个函数为了让每一个实例维护一份返回对象的独立的拷贝，这样各个组件的 data 变化的时候互不影响 node相关 node文件查找机制总体流程其余的 参考文章 浅谈 instanceof 和 typeof 的实现原理 两个大数求和 深入 setstate 机制 大话 react 生命周期 2019：react-v16.3 新生命周期总结 react-router 的实现原理 社招中级前端笔试面试题总结 Why is React’s virtual DOM so much faster than the real DOM? 前端 100 问：能搞懂80%的请把简历给我","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/面经/"}]},{"title":"2019年度总结","slug":"2019年度总结","date":"2019-12-10T01:45:37.000Z","updated":"2023-04-16T09:13:30.906Z","comments":true,"path":"2019/12/10/2019年度总结/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/10/2019年度总结/","excerpt":"","text":"写给自己的准则 不管改动的文件再多，都要一个个检查，看有没有误改的地方，自己的改动有没有影响其他的功能 写代码前，请三思，请三思，请三思，不要急于动手 不要相信测试，一定要在上线之前用各种设备，各种大小的屏幕，各种浏览器，测试一遍所有相关的功能，所有可能出现的情况 一个功能一个分支，时刻保持与线上同步 多研究研究各种应用，站在用户的角度去测试而不是自己的角度 不明白的，容易记混的知识点要自己归纳总结，多动手，不要今天看几篇文章明天又忘了 晚上要睡好，避免第二天打瞌睡 写给2020年的自己 多动手写代码，多点工作之外的输出，巩固js基础，希望我能在这条路越走越远吧。。。","categories":[{"name":"成长","slug":"成长","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/成长/"}],"tags":[]},{"title":"webpack常用配置速查","slug":"webpack常用配置速查","date":"2019-12-08T12:54:46.000Z","updated":"2023-04-16T09:13:30.604Z","comments":true,"path":"2019/12/08/webpack常用配置速查/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/12/08/webpack常用配置速查/","excerpt":"","text":"生产环境常用插件imagemin-webpack-plugin - 图片压缩插件123456789101112//引入插件var ImageminPlugin = require('imagemin-webpack-plugin').default;//配置plugins: [ new ImageminPlugin(&#123; disable: process.env.NODE_ENV !== 'production', // 开发时不启用 pngquant: &#123;//图片质量 quality: ... &#125; &#125;)] mini-css-extract-plugin - 依据每个entry生成单个css文件（将css从js中提取出来）12345678910111213// 将style-loader换成mini-css-extract.. use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, 'css-loader' ... ] ... new MiniCssExtractPlugin(&#123; filename: 'static/css/[name].[contenthash:8].css', chunkFilename: 'static/css/[name].[contenthash:8].chunk.css' // import() dynamically import &#125;) cleanwebpackplugin在webpack中打包的文件通常是通过hash生成的，如果文件改动，那么打包的文件就会越来越多,这个插件用来清除之前的文件 postcss-loader简介能够像less一样的自动补全浏览器前缀，需要与autoprefixer一起使用,PostCSS的一大特点是，允许使用最新的CSS特性，在你的CSS里提供统计数据，或者是允许你使用 Sass，Less或是Stylus等CSS预处理器。 postcss的生态圈提供了上百种插件Autoprefixer 根据用户的使用场景来解析CSS和添加vendor prefixes（前文注2）。 PostCSS Focus 一种利用键盘操作为每个:hover添加:focus选择器的PostCSS插件。 PreCSS 一个允许你在代码中使用类似Sass标记的插件。 Stylelint 一种强大的，先进的可以使你在CSS样式中保持一致性，避免错误的CSS linter工具。 PostCSS CSSnext 一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。 … 使用需要结合postcss.config.js 12345678910111213141516171819202122// postcss.config.jsmodule.exports = &#123; plugins: [ require('precss'), require('autoprefixer') ]&#125;// webpack.config.js test: /\\.scss$/,&#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-preset-env')(&#123; autoprefixer: &#123; flexbox: 'no-2009' &#125;, stage: 3 &#125;) ] terser-webpack-plugin - js压缩插件使用123456789101112131415optimization: &#123; ... minimize: true, minimizer: [ new TerserJSPlugin(&#123; terserOptions: &#123; output: &#123; comments: false &#125; &#125;, extractComments: false &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125; progress-bar-webpack-plugin简介显示build进度 123plugins: [ new ProgressBarPlugin()] optimize-css-assets-webpack-plugin - css压缩插件1234567891011plugins:[ ... new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.optimize\\.css$/g, cssProcessor: require('cssnano'), cssProcessorPluginOptions: &#123; preset: ['default', &#123; discardComments: &#123; removeAll: true &#125; &#125;], &#125;, canPrint: true &#125;)] webpack-bundle-analyzer简介可以看到打包之后各个文件的大小 之后可以做一些优化 1234567const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 开发环境常用插件HotModuleReplacementPlugin123plugins:...new webpack.HotModuleReplacementPlugin() friendly-errors-webpack-plugin - 友好的webpack错误提示123456789new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: ['You application is running here http://localhost:3000'], notes: ['Some additionnal notes to be displayed unpon successful compilation'] &#125;, onErrors: function (severity, errors) &#123; // You can listen to errors transformed and prioritized by the plugin // severity can be 'error' or 'warning' &#125; 基础配置htmlwebpackpluginhttps://juejin.im/post/5ce96ad7e51d455a2f2201e1 12345678910111213141516171819202122new HtmlWebpackPlugin(&#123; inject: true, excludeAssets: [...], chunks: [page.toLowerCase()].concat( isEnvProduction ? ['assets', 'vendors'...] : [] ), templateParameters: ..., minify: isEnvProduction &amp;&amp; &#123; removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;, filename: ... template: ... &#125;) 参考文章 关于 PostCSS 普及的一点微小的工作","categories":[{"name":"配置","slug":"配置","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/配置/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"webpack配置多页面国际化应用","slug":"配置多页面国际化应用","date":"2019-11-15T13:36:17.000Z","updated":"2023-04-16T03:13:51.195Z","comments":true,"path":"2019/11/15/配置多页面国际化应用/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/11/15/配置多页面国际化应用/","excerpt":"","text":"多入口配置通过读取文件结构来动态生成入口。务必使用对象写法，键名表示 chunkName 1234567891011121314151617181920module.exports = &#123; entry: collectEntries()&#125;function collectEntries() &#123; const pagesDir = path.resolve(__dirname, '../src/pages') return fs .readdirSync(pagesDir) .map((pageName) =&gt; (&#123; chunkName: pageName, entryFile: path.join(pagesDir, pageName, 'index.jsx') &#125;)) .reduce( (entries, item) =&gt; (&#123; ...entries, [item.chunkName]: item.entryFile &#125;), &#123;&#125; )&#125; 多 html 文件输出plugins 添加多个 HtmlWebpackPlugin 实例，添加 chunks 配置将只在页面注入当前页面的代码块，不设置 chunks 会注入所有页面代码块 1234567891011121314151617181920module.exports = &#123; plugins: [ ...collectHtmls() // ... ]&#125;function collectHtmls() &#123; const pagesDir = path.resolve(__dirname, '../src/pages') const templatesDir = path.resolve(__dirname, '../public/templates') const templateOutputsDir = path.resolve(__dirname, '../dist') return fs.readdirSync(pagesDir).map((pageName) =&gt; &#123; return new HtmlWebpackPlugin(&#123; inject: true, chunks: [pageName], filename: path.join(templateOutputsDir, `$&#123;pageName&#125;.html`), template: path.join(templatesDir, `$&#123;pageName&#125;.html`) &#125;) &#125;)&#125; devServer 配置多国家网站地址一般为 https://www.xxx.com/locale, 参考苹果官网 (opens new window)和 微软官网 (opens new window)。所以我们需要处理一下重定向，也就是 devServer 的 historyApiFallback 项，需提前配置支持的国家。 123456789101112131415161718module.exports = &#123; devServer: &#123; historyApiFallback: &#123; rewrites: collectRewrites() &#125; &#125;&#125;const avalibleLocales = '(cn|us|ru|id)'function collectRewrites() &#123; return fs .readdirSync(path.resolve(__dirname, '../src/pages')) .map((page) =&gt; (&#123; from: new RegExp(`^/$&#123;avalibleLocales&#125;/$&#123;page&#125;/?$`, 'i'), to: `/$&#123;page&#125;.html` &#125;))&#125; 使用 react-router 时 basename 需要配置为当前国家 123const App = () =&gt; &#123; return &lt;Router basename=&#123;`/$&#123;locale&#125;`&#125;&gt;&#123;/*...*/&#125;&lt;/Router&gt;&#125; 多语言配置使用 React-Intl配置多国语言包。为防止 bundle 体积过大，语言包用 code spliting 分割。注意语言包未加载时不要显示页面内容，否则页面会有闪烁。 123456789101112const Intl = (&#123; children &#125;) =&gt; &#123; const [messages, setMessages] = useState() const loadLocaleData = useCallback(() =&gt; &#123; import(`@/languages/$&#123;locale&#125;.json`).then(setMessages) &#125;, [language]) useEffect(loadLocaleData, []) return messages ? ( &lt;IntlProvider messages=&#123;messages&#125; locale=&#123;locale&#125;&gt; &#123;children&#125; &lt;/IntlProvider&gt; ) : null&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/webpack/"}]},{"title":"前端性能优化","slug":"前端性能优化","date":"2019-11-07T04:09:10.000Z","updated":"2023-04-02T14:00:30.290Z","comments":true,"path":"2019/11/07/前端性能优化/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/11/07/前端性能优化/","excerpt":"","text":"前端性能优化最佳实践针对 spa 的性能优化 优化首屏渲染 将所有用于首屏渲染的 css 文件整合成一个内嵌到 head 标签，由于 http 数据包的限制，文件大小不能超过 14kbhttp/2 能让 css 文件使用单个文件存储，通过服务器推送 css 文件的传输方式减少 html 文件数据量 骨架屏 预加载 异步路由 路由拆分,减少初始加载体积: 利用异步加载方式，仅在需要进入对应路由时，对应组件才会被加载进来。 1234route(&#123; Home: () =&gt; import('@/coms/home'), About: () =&gt; import('@/coms/about')&#125;) 服务端渲染（SSR） 简单的来讲，就是浏览器发送请求到服务器端，服务器端处理请求，填充数据，生成 html 返回给浏览器 ,服务端必须是 node.js 或者专门跑个 node.js 来支持优势：更好的 SEO； 首屏性能好，不需要先下载一堆 js 和 css 后才能看到页面劣势：不能实现部分更新。即使只有一部分变动，也需要后端重新返回整个页面给浏览器。 其他重绘 回流的概念 repaint，就是浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如我们改变了元素的颜色，加个下划线等。 reflow, 浏览器得知元素产生了对文档树排版有影响的样式变化，对所有受影响的dom节点进行重新排版工作* 减少回流 回流的发生：1、DOM 树的结构变化，如添加或删除元素。（当新增多个元素的时候使用文档碎片）包括设置 display:none 设置 visibility 只会触发重绘2、元素的几何属性的改变（如 margin、padding、width、height、border 等）。3、页面初始化渲染。4、获取某些属性，浏览器为取得准确的值也会触发回流（offsetTop、clientTop、scrollTop、getComputedSyle()等等）。5、浏览器窗口尺寸的改变 为什么获取某些属性会触发回流？由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。 怎么避免 对于复杂的动画效果，让其绝对定位 避免多次访问上述的属性 使用类名 使用 csstext 当添加插入大量的元素的时候 使用文档碎片或者是在父元素在被插入之前设置display:none让其脱离文档流 之后再带回文档流 硬件加速，使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能 常见的触发硬件加速的 css 属性：transform,opacity,filters,Will-change 使用控制台的performance监测页面的性能（原来的 timeline）使用指南：https://www.cnblogs.com/xiaohuochai/p/9182710.html 其他 复杂的计算使用web workers 事件委托 正则表达式不要过于复杂 使用 webpack 优化 优化图片 - 使用url-loader 设置limit 大的图转成base64 使用各种插件压缩代码 tree-shaking是什么？用于描述移除 JavaScript 上下文中的未引用代码怎么做？ 使用 ES2015 模块语法（即 import 和 export）。确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为 \\ 123456789101112// 配置 Babel 让其保留 ES6 模块化语句 // babelrc&#123; \"presets\": [ [ \"env\", &#123; \"modules\": false &#125; ] ]&#125; 在项目 package.json 文件中，添加一个 “sideEffects” 属性。比如polyfill等 只要引入 就会产生副作用 当该属性设置为false的时候会删除所有未引用的文件 所以polyfill需要声明sideeffects,true 是默认值，如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。 123456789101112131415// 所有文件都有副作用，全都不可 tree-shaking&#123; \"sideEffects\": true&#125;// 没有文件有副作用，全都可以 tree-shaking&#123; \"sideEffects\": false&#125;// 只有这些文件有副作用，所有其他文件都可以 tree-shaking，但会保留这些文件&#123; \"sideEffects\": [ \"./src/file1.js\", \"./src/file2.js\" ]&#125; 通过将 mode 选项设置为 production，启用 minification(代码压缩) 和 tree shaking。开启 optimization.usedExports,编译时可以分析出解构写法引入的esm模块，哪些export用到了，哪些模块没有用到。然后就需要分别进行标记,标记如下 并使用压缩插件压缩代码 webpack4 mode为production时候默认就有这两个设置 123/* harmony export (immutable) */ __webpack_exports__[\"xxx\"] = xxxx;/* unused harmony export xxx */ 标记为这个就是需要删掉的 以上述方式声明sideeffects会出现的问题：以import &#39;xxx.css直接导入到 JavaScript 文件中的样式表都将从输出中删除解决办法是：webpack的配置文件中 123456789module: &#123; rules: [ &#123; test: /...css.../, use: [loaders], sideEffects: true &#125; ]&#125; 引入的时候使用解构赋值 不用的依赖及时删除 external 把我们的依赖申明为一个外部依赖，外部依赖通过 &lt; script&gt; 外链脚本引入。 optimization 配置细节https://imweb.io/topic/5b66dd601402769b60847149 alias 和 noParse当需要将这个外部依赖打包进入到你的 bundle 的时候 1234567891011121314module.exports = function(webpackConfig) &#123; ...+ webpackConfig.resolve.alias = &#123;+ 'react': 'react/dist/react.min'+ &#125;+ webpackConfig.module.noParse.push(+ /react.min/+ ) ... return webpackConfig;&#125;; 其他 - 优化SEO重要的内容放在首页 因为爬虫会先从首页开始爬提交sitemap加快页面加载速度 提升搜索引擎排名… 参考文章 你真的了解回流和重绘吗 Webpack 构建性能优化探索","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/性能优化/"}],"tags":[]},{"title":"css中宽高的新值复习","slug":"css中宽高的新值复习","date":"2019-10-17T13:50:15.000Z","updated":"2023-04-16T09:13:30.603Z","comments":true,"path":"2019/10/17/css中宽高的新值复习/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/10/17/css中宽高的新值复习/","excerpt":"","text":"fill-available 出现fill-available关键字值的价值在于，可以让元素的100%自动填充特性不仅仅在block水平元素上，也可以应用在其他元素利用它实现等高布局 123456789101112131415&lt;style&gt;.inner&#123; width:100px; height:-webkit-fill-available; margin:0 10px; display: inline-block; vertical-align: middle; background-color: pink;&#125;&lt;/style&gt;&lt;div style=\"height: 100px;\"&gt; &lt;div class=\"inner\"&gt;HTML&lt;/div&gt; &lt;div class=\"inner\"&gt;CSS&lt;/div&gt; &lt;div class=\"inner\"&gt;JS&lt;br&gt;jQyery&lt;br&gt;Vue&lt;/div&gt;&lt;/div&gt; max-contentfit-content uses max-content, unless available &lt; max-content, then it uses available. Unless available &lt; min-content, then it uses min-content. 12345678910&lt;style&gt;.outer&#123; width:-webkit-max-content; border:1px solid black;&#125;&lt;/style&gt;&lt;div class=\"outer\"&gt; &lt;div style=\"height:10px;width:100px;background:lightgreen\"&gt;&lt;/div&gt; &lt;div style=\"background-color: pink;\"&gt;测试测试测试测试测试测 hi 是测试测试测试测你测试测试测试测试&lt;/div&gt;&lt;/div&gt; 每日小知识点 关于下载的文件的后缀你在网上下载一个很大的文件，下载过程中你怎么知道自己下载的对不对呢？所以MD5 就是为了这种情景而生的。即网上的文件除了有资源本身外，还会有一个MD5值，然后你下载到本地后的文件也可以算出一个MD5 值，然后二者对比，如果完全相同则说明下的文件是正确的。 参考文章 浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/css/"}]},{"title":"控制react的state为合法状态","slug":"控制react的state为合法状态","date":"2019-10-14T14:58:27.000Z","updated":"2023-04-16T09:13:30.602Z","comments":true,"path":"2019/10/14/控制react的state为合法状态/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/10/14/控制react的state为合法状态/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031const zipList = initialArray =&gt; &#123; const [initialActive, ...restOfTabs] = initialArray const zip = &#123; previous: [], current: initialActive, next: restOfTabs, &#125; const setActive = zip =&gt; newActive =&gt; &#123; // TODO: fill this in const newZip = zip return apiForZip(newZip) &#125; const apiForZip = zip =&gt; (&#123; asArray: () =&gt; [...zip.previous, zip.current, ...zip.next], isActive: tab =&gt; zip.current === tab, setActive: setActive(zip), activeTab: () =&gt; zip.current, &#125;) return apiForZip(zip)&#125;const [tabs, setTabs] = React.useState( zipList([ &#123; title: 'Tab One', content: 'This is tab one' &#125;, &#123; title: 'Tab Two', content: 'This is tab two' &#125;, &#123; title: 'Tab Three', content: 'This is tab three' &#125;, ])) 每日小知识点 字体的旋转将字体设置成display:block即可 run build文件夹（为了更接近线上的效果）使用http-server工具 执行命令: （原理是puputeer抓取build下的资源 然后。。 1http-server build/ project name 尽量不要使用push跳转路由 因为这种动态的方式不利于ssr git config -list 查看当前项目的git配置 请求被重定向 （network出现…html…很长的路径 并被canceled） 可能是后端正在部署到新的服务器 每日bug记录 请求返回500 发现是传的参数的格式不对 应该是form表单的形式 而不是application/json格式 虽然API文档中没有标出 但是也要注意 发现重新进入页面加载数据的时候没有出现loading 是因为数据存储在mobx中 没有刷新被清除 所以要在每次请求之前清除一次或者是不走mobx流程 父层叠上下文中的子层叠上下文 12345678...position:relative /* 父 */...position:absolutez-index:2 /*子*/...position:absolutez-index:1 /* 叔叔 */ 最后还是叔叔显示在子节点的上面 因为子层叠上下文属于父层叠上下文 table 设置flex布局 td元素不会自动填充满tbody node exec不执行回调函数 1234var exec = require('child_process').exec;exec(\"&#123;COMMAND&#125; &gt; results.log\", function (error, stdout, stderr) &#123; console.log('callback called!'); // this never gets called.&#125;); 是因为重定向到了另一个文件 *","categories":[],"tags":[]},{"title":"ts小知识点","slug":"ts小知识点","date":"2019-10-11T12:28:00.000Z","updated":"2023-04-16T09:13:30.625Z","comments":true,"path":"2019/10/11/ts小知识点/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/10/11/ts小知识点/","excerpt":"","text":"用 keyof 来约定方法的参数 123456789101112export type keys = &#123; name: string; appId: number; config: object;&#125;class Application &#123; // 参数和值约束范围 set&lt;T extends keyof keys&gt;(key: T, val: keys[T]) get&lt;T extends keyof keys&gt;(key: T): keys[T]&#125;---- interface vs type我们可以使用 in 来约束属性名必须为三家运营商之一： 123456789101112type ChinaMobilePhones = '10086' | '10010' | '10000'interface ChinaMobile &#123; name: string; website: string;&#125;// 只能 type 使用， interface 无法使用type ChinaMobileList = &#123; // 遍历属性 [phone in ChinaMobilePhones]: ChinaMobile&#125; 类型定义文件在 TypeScript 中，我们可以很简单的，在代码编写中定义类型： 123456interface IBaseModel &#123; say(keys: string[] | null): object&#125;class User implements IBaseModel &#123; name: string 但是主流的库都是 JavaScript 编写的，TypeScript 身为 JavaScript 的超集，自然需要考虑到如何让 JS 库也能定义静态类型。 TypeScript 经过了一系列的摸索，先后提出了 tsd(已废弃)、typings(已废弃)，最终在 TypeScript 2.0 的时候重新整理了类型定义，提出了 DefinitelyTyped。 DefinitelyTyped 就是让你把 “类型定义文件(*.d.ts)”，发布到 npm 中，配合编辑器(或插件)，就能够检测到 JS 库中的静态类型。 类型定义文件的以 .d.ts 结尾，里面主要用来定义类型。比如： 因为这几个库是 js 的，没有 ts 的类型声明也没有好的@types/对应的库 123declare module 'classnames';declare module 'htmr';declare module 'showdown-katex'; 内置类型定义就是把你的类型定义文件和 npm 包一起发布 123456789// pageage.json&#123; \"name\": \"demo\", \"author\": \"demo project\", \"version\": \"1.0.0\", \"main\": \"./lib/main.js\", // 定义主类型定义文件 \"types\": \"./lib/main.d.ts\"&#125; 定义数组的类型为第一项是函数 其余的是对象 12345678910interface Arglist &#123; [index: number]: object 0: Function&#125;const a1: Arglist = [func]const a2: Arglist = [22] // failsconst a3: Arglist = [func, 'foo']// 方式二type FAs = [Function, &#123;&#125;] 继承的时候排除父接口中的一部分属性 123export type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;export interface ICollapseProps extends Omit&lt;React.HTMLAttributes&lt;HTMLUListElement&gt;,\"title\"&gt; react.cloneElement的正确用法 123cloneElement(children as React.ReactElement&lt;any&gt;, &#123; ref, type: hasError ? 'error' : 'default', index signature 索引签名适用于无法确定属性名称的场景123interface NetCache &#123; [propName: string]: string;&#125; useImmperativeHandle 结合 需要定义静态属性的组件 组件的定义应该如下 123456export interface IMessage extends React.ForwardRefExoticComponent&lt;IMessageProps &amp; React.RefAttributes&lt;HTMLDivElement | refType&gt;&gt; &#123;// 使用 const ref = createRef&lt;refType &amp; HTMLDivElement&gt;() &lt;Message ref=&#123;ref&#125;/&gt; Using a forwardRef component with children in TypeScript 1234567891011121314import * as React from 'react'type ButtonProps = React.HTMLProps&lt;HTMLButtonElement&gt; or React.ComponentPropsWithoutRef&lt;'button'&gt;const FancyButton = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;((props, ref) =&gt; ( &lt;button type=\"button\" ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;))// You can now get a ref directly to the DOM button:const ref = React.createRef&lt;HTMLButtonElement&gt;()&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt; 结论当报错的时候一定要仔细看错误 然后多试一试","categories":[{"name":"ts","slug":"ts","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/ts/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/ts/"}]},{"title":"sass中的map和list","slug":"sass中的map","date":"2019-10-11T12:28:00.000Z","updated":"2023-04-16T09:13:30.603Z","comments":true,"path":"2019/10/11/sass中的map/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/10/11/sass中的map/","excerpt":"","text":"map简介类似于 js 中的 map 数据结构 主要函数 函数 功能 示例 map-keys(map) 返回 map 里面所有的 key(list) map-keys((“foo”: 1, “bar”: 2)) =&gt; “foo”, “bar” map-values(map) 返回 map 里面所有的 value(list) map-values((“foo”: 1, “bar”: 2)) =&gt; 1, 2 map-get(map,key) 返回 map 里面指定可以的 value map-get((“foo”: 1, “bar”: 2), “foo”) =&gt; 1 map-has-key(map,key) 返回 map 里面是否含有指定的 key map-has-key((“foo”: 1, “bar”: 2), “foo”) =&gt; true map-merge(map1,map2) 合并 map(map) map-merge((“foo”: 1), (“bar”: 2)) =&gt; (“foo”: 1, “bar”: 2) map-remove(map,keys) 删除指定 map 中的指定 key(map) map-remove((“foo”: 1, “bar”: 2), “bar”) =&gt; (“foo”: 1) keywords(args) 返回一个函数参数组成的 map(map) @mixin foo(args…){@debug keywords($args); //=&gt; (arg1: val, arg2: val)} list简介类似js中的数组 12345$list: ( (\"item-1.1\", \"item-1.2\", \"item-1.3\"), (\"item-2.1\", \"item-2.2\", \"item-2.3\"), (\"item-3.1\", \"item-3.2\", \"item-3.3\") ); 方法 length 检测其长度： 1length($a) =&gt; 1 nth 获取第n项： 1nth($a,1) =&gt; test index($list,$value)：返回$value在$list中的位置 append($list,$value[,$separator])：使用$separator分隔符将$value列表项添加到$list最后（如果没有显式指定 $separator分隔符，会以当前分隔符分隔） join($list-1,$list-2[,$separator]):使用$separator分隔符将$list-2附加到$list-1（如果没有显式指定分隔符，将对* $list-1中的分隔符） zip($lists):将多个$list组合在一起成为一个多维列表。如果列表源长度并不是所有都相同，结果列表长度将以最短的一个为准 reject($list,$value)：这是Compass中的一个函数，将$value值从$list中删除 compact(*$args)：Compass函数，返回一个删除非真值的新列表 list应用 扩展选择器 如:1234.home .nav-home,.about .nav-about,.products .nav-products,.contact .nav-contact 12345678$pages: home,about,products,contact;$selector:();@each $item in $pages &#123; //我们创建$selector&#125;#&#123;$selector&#125;&#123; //样式写在这里&#125; 自定义函数123456789//定义first()函数，获取列表中的第一个列表项@function first($list)&#123; @return nth($list,1);&#125;//定义last()函数，获取列表中的最后一个列表项@function last($list)&#123; @return nth($list,length($list));&#125; 每日小知识点 unquote 用来去除字符串中的引号 quote 给字符串增加引号 传递内容块到 mixin: @content 12345678910@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; target 伪类可以在不新增类名的时候直接实现标签页的效果原理： 也就是给一个元素 A 设定 id，另一个元素 B 指定跳转到这个 id，然后就向 a:hover 那样，在 css 中设定 “元素：target”并改变样式，那么点击 B 元素，就会根据你的设定改变 A 的样式。 123456789101112&lt;div class=\"swiper-box\"&gt; &lt;div class=\"swiper-cont\"&gt; &lt;div class=\"swiper1\" id=\"swiper1\"&gt;&lt;/div&gt; &lt;div class=\"swiper2\" id=\"swiper2\"&gt;&lt;/div&gt; &lt;div class=\"swiper3\" id=\"swiper3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-num\"&gt; &lt;a href=\"#swiper1\"&gt;1&lt;/a&gt; &lt;a href=\"#swiper2\"&gt;2&lt;/a&gt; &lt;a href=\"#swiper3\"&gt;3&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; focus:within 伪类 应用于当子元素中出现获得焦点的元素时候 123&lt;div&gt; &lt;input /&gt;&lt;/div&gt; 12div:focus:within &#123;&#125; css 伪类与伪元素css 伪类css 伪类用于向某些选择器添加特殊的效果。:link, :visited, :hover, :focus, :active, :first-child, :langcss3 新增的伪类：:last-child, :only-child, :first-of-type, :last-of-type, :only-of-type, :nth-child(n), :nth-last-child(n), :nth-of-type(n), :nth-last-of-type(n), :root, :empty, :target, :enabled, :disabled, :checked, :not(selector), css 伪元素css 伪元素用于向某些选择器设置特殊效果。::first-letter, ::first-line, ::before, ::aftercss3 新增的伪元素::selection 通过 first-letter text-transform: uppercase text-transform: lowercase控制大小写 每日 bug 记录 max-height 设置 transition 的时候不生效 是因为 max-height 设置了一个很大的范围 比如从 0 到 1000 而实际的内容高度只有 100 那么剩下的时间大都是在滚动这 900 使用 js 设置元素的行内样式可以应用样式表中的 transition git 冲突的理解只有当同时修改了某个文件的时候才会出现冲突 要是本地的状态是 nothing commit git pull 的时候会直接覆盖掉本地的文件 git merge 的理解从父分支切出子分支 子分支 pull 父分支 子分支上的代码会与父分支保持一致 但是父分支 merge 子分支 父分支的内容不一定要与子分支保持一致 在一个hooks里面维护一份state 然后在另一个组件中setState 一个组件中获取state 两个组件的state并不会同步","categories":[{"name":"sass","slug":"sass","permalink":"https://earnest1997.github.io/ashley271017.github.io/categories/sass/"}],"tags":[{"name":"sass css","slug":"sass-css","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/sass-css/"}]},{"title":"vue组件通信方式","slug":"vue组件通信方式","date":"2019-09-17T13:59:58.000Z","updated":"2023-04-19T02:20:16.890Z","comments":true,"path":"2019/09/17/vue组件通信方式/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/09/17/vue组件通信方式/","excerpt":"","text":"父子组件通信props传递数据 $emit 触发自定义事件适用场景：子组件传递数据给父组件子组件通过触发自定义事件，emit触发自定义事件，emit第二个参数为传递的数值父组件绑定监听器获取到子组件传递过来的参数 1234// childthis.$emit('add', good) // father&lt;Children @add=\"cartAdd($event)\" /&gt; ref父组件在使用子组件的时候设置ref,父组件通过设置子组件ref来获取数据 123&lt;Children ref=\"foo\" /&gt; this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据 兄弟组件 EventBus 1234567// Children1.vuethis.$bus.$emit('foo') // Children2.vuethis.$bus.$on('foo', this.handle) 通过共同祖辈或者parent或者root搭建通信侨联 123this.$parent.on('add',this.add)this.$parent.emit('add') 祖先、后代组件 provide 与 inject 1234567provide()&#123; return &#123; foo:'foo' &#125; &#125; inject:['foo'] // 获取到祖先组件传递过来的值 vuex vuex的缺点是啥？Vuex 的 state 可以直接修改，这将让 state 的改变不可预测，且状态管理不够坚固。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue/"}]},{"title":"2019春招回顾","slug":"面试题回顾春招","date":"2019-08-14T14:38:11.000Z","updated":"2023-04-16T09:13:30.906Z","comments":true,"path":"2019/08/14/面试题回顾春招/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/08/14/面试题回顾春招/","excerpt":"","text":"使用 Linux 命令模拟发起一个请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、get请求： 1、使用curl命令：// 在终端敲下该命令之后回车会出现响应内容 curl “http://www.baidu.com” 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地 curl -i “http://www.baidu.com” 显示全部信息 curl -l “http://www.baidu.com” 只显示头部信息 curl -v “http://www.baidu.com” 显示get请求全过程解析 2、使用wget命令： wget “http://www.baidu.com”也可以二、post请求 1、使用curl命令（通过-d参数，把访问参数放在里面）： curl -d “param1=value1¶m2=value2” “http://www.baidu.com” 2、使用wget命令：（--post-data参数来实现） wget --post-data ‘user=foo&amp;password=bar’ http://www.baidu.com 以上就是Linux模拟Http的get或post请求的方法了，这样一来Linux系统也能向远程服务器发送消息了。## 防抖节流# Throttle and debounce## Throttle （函数节流）### Throttle 定义就是指连续触发事件后在 n 秒内函数只能执行一次如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期```js/** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay &#123;number&#125; 延迟时间，单位毫秒 * @param action &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */var throttle = function(delay, action) &#123; var last = 0; return function() &#123; var curr = +new Date(); if (curr - last &gt; delay) &#123; action.apply(this, arguments); last = curr; &#125; &#125;;&#125;; 版本二： 1234567891011121314151617181920function throttle(fun, delay) &#123; let last, deferTimer; return function(args) &#123; let that = this; let _args = arguments; let now = +new Date(); if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer); // 保证一定会执行一次 这就是跟防抖不一样的地方 deferTimer = setTimeout(function() &#123; last = now; fun.apply(that, _args); &#125;, delay); &#125; else &#123; // 第一次或者当时间间隔达到要求的时候会执行函数 last = now; fun.apply(that, _args); &#125; &#125;;&#125; 比如搜索框 当用户输入频繁的时候 Debounce (函数去抖)Debounce 定义就是指触发事件后在 n 秒内函数只能执行一次（最后一次），如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间 123456789101112131415161718/** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle &#123;number&#125; 空闲时间，单位毫秒 * @param action &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */var debounce = function(idle, action) &#123; var last; return function() &#123; var ctx = this, args = arguments; clearTimeout(last); last = setTimeout(function() &#123; action.apply(ctx, args); &#125;, idle); &#125;;&#125;; 区别 debouncesearch 搜索联想，用户在不断输入值时，用防抖来节约请求资源。window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断 vue 的路由如何实现，最后提到了服务器端渲染，解释其过程 前端路由实现的就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容 hash 模式。hash 值变化，浏览器不发出请求，但是会触发 hashchange 这个事件， 通过这个事件我们就可以知道 hash 值发生了哪些变化，来更新页面内容 1234function matchAndUpdate() &#123; // todo 匹配 hash 做 dom 更新操作&#125;window.addEventListener(\"hashchange\", matchAndUpdate); history 模式. pushState 和 replaceState 分别可以添加和修改历史记录条目,通过这两个 API 可以改变 url 地址且不会发送请求,当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。当处于激活状态的历史记录条目发生变化时,popstate 事件就会在对应 window 对象上触发 animation transition的区别 transition 动画可以通过事件监听启动和完成transitionstart、transitionrun、transitionend,transition 动画有几个局限： 需要通过用户的行为（如点击，悬浮等）触发，所以没法在网页加载时自动发生 是一次性的，不能重复发生 只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 keyframes: 关键帧 keyframe 自定义动画,能够自定义任意阶段的动画动作。 animation 在不需要触发事件的情况下，也可以随时间变化来改变元素 CSS 属性。 可以指定动画具体播放的次数 可以指定各个阶段的状态，而不是只有开始和结尾。 介绍 requestAnimateFrame，与 setInterval 或 setTimeout 的区别 setTimeout: seTimeout 实现的动画容易出现卡顿、抖动的现象，有两个原因可能会导致丢帧： setTimeout 的执行时间并不是确定的, setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。 刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。 requestAnimateFrame：请求浏览器在下一次重绘之前调用指定的函数来更新动画,回调的次数通常是每秒 60 次,返回一个 long 整数，请求 ID，可以传这个值给 window.cancelAnimationFrame() 以取消回调函数. 最大的优势是rAF 的执行步伐跟着浏览器的绘制频率走，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 js 为什么要单线程的 在多线程操作的情况下可以实现应用的并行处理，而提高整个应用程序的性能和吞吐量，更大粒度的榨取本机的 CPU 利用率，特别是现代很多语言都支持了多核并行处理技术。JavaScript 是单线程执行，因为如果 JavaScript 是多线程的方式来操作 UI，则可能出现 UI 操作的冲突, 如果引入一些锁的机制来解决这些冲突，则容易引入更大的复杂性，所以 JavaScript 从开始就选择了单线程执行。 ## 同步与非同步 阻塞非阻塞 并发并行的区别用普通的水壶烧，人在边上看着，水开了再去看球。（同步，阻塞）这个是常规做法，但是我看球不爽了。用普通水壶烧，人去看球，隔几分钟去厨房看看。（同步，非阻塞）这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。用会叫的水壶，人在边上看着。（异步，阻塞）这个没有问题，但是我太傻了。用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这个应该是最好的。等着看球的我：阻塞 看着电视的我：非阻塞 普通水壶：同步 会叫的水壶：异步 (内核会通知) 同步过程中进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否完成。异步过程中进程触发 IO 操作以后，直接返回，做自己的事情，IO 交给内核来处理，完成后内核通知进程 IO 完成。 阻塞 阻塞的概念往往伴随着线程。阻塞一般是指：在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会被唤醒执行后续的操作。 非阻塞 那么非阻塞，毫无疑问是阻塞的反向操作。非阻塞式的调用指：在结果没有返回之前，该调用不会阻塞住当前线程。 并发：当有多个线程在操作时，如果系统只有一个 CPU，操作系统只能把 CPU 运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的快速的切换不同的线程代码运行。 并行：当系统有多个 CPU 时，可以存在当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。 nodejs 中的阻塞非阻塞阻塞，读取文件同步 I/O 操作，等待文件读取完再进行其他操作。 非阻塞，读取文件是异步回调，在等待文件读取时可以进行其他操作，这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 react 的 filber （16.3之后开启异步渲染) 在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。 由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 componentWillMount、componentWillReceiveProps 和 componetWillUpdate 标记为 unsafe，并使用新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 进行替换。 组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。 两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些： componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentWillMount render getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。 reconciliation 阶段虚拟 dom 的数据对比 commit 阶段将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作 linux常见命令 创建符号链接（类似windows的快捷方式) ln -s source_file symbolic_link 打开文件跳到第一个匹配的行 $ vim +/search-term filename.txt grep相关 1.在文件中查找字符串不区分大小写 $ grep -i “the” demo_file2.在一个文件夹中递归查询包含指定字符串的文件$ grep -r “ramesh” * 查找指定文件名的文件(不区分大小写) find -iname ‘..’ 登录到远程主机 $ ssh -l jsmith remotehost.example.com ps 1.查看当前正在运行的所有进程 $ ps -ef | more2.以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构$ ps -efH | more 显示当前系统中占用资源最多的一些进程top 查看所有网络接口及其状态 $ ifconfig -a 使用up和down命令启动或停止某个接口 $ ifconfig eth0 up $ ifconfig eth0 down 查找某个命令的位置 $ whereis cmd 不加载整个文件的前提下显示文件内容 (查看大型日志文件的时候) $ less 设置环境变量 $ export … cat追加a内容到文件b的末尾 $ cat a &gt; b cat覆盖原有文件的内容 $ cat a &gt;&gt; b curl命令相关 1.模仿浏览器 $ curl -A “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)” http://www.linux.com2.伪造referer（盗链）$ curl -e “www.linux.com&quot; http://mail.linux.com3.利用curl下载文件使用内置option：-o(小写)$ curl -o dodo1.jpg http:www.linux.com/dodo1.JPG4.使用curl发送POST请求$ curl -d “user=admin&amp;passwd=12345678” http://127.0.0.1:8080/login 前端模块化CommonJs用在服务器端，AMD和CMD用在浏览器环境AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 移动端相关移动端点击 300ms 延迟是什么？怎样消除？为了双击缩放，页面点击会有 300ms 延迟解决方法，禁用缩放，更改默认的视口宽度&lt;meta name=”viewport” content=”user-scalable=no, initial-scale=1,maximum-scale=1, width=device-width”&gt;","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/面经/"}]},{"title":"前端文件上传","slug":"前端文件上传","date":"2019-06-14T13:28:11.000Z","updated":"2023-04-02T14:00:30.293Z","comments":true,"path":"2019/06/14/前端文件上传/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/06/14/前端文件上传/","excerpt":"","text":"上传文件的几种方式 普通表单上传使用 PHP 来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为 enctype=”multipart/form-data”，表明表单需要上传二进制数据。 1234&lt;form action=\"/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"myfile\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 文件编码上传第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成 base64 进行传递var imgURL = URL.createObjectURL(file);ctx.drawImage(imgURL, 0, 0);// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递var data = canvas.toDataURL(“image/jpeg”, 0.5); 除了进行 base64 编码，还可以在前端直接读取文件内容后以二进制格式上传 12345678910111213141516// 读取二进制文件function readBinary(text) &#123; var data = new ArrayBuffer(text.length) var ui8a = new Uint8Array(data, 0) for (var i = 0; i &lt; text.length; i++) &#123; ui8a[i] = text.charCodeAt(i) &amp; 0xff &#125; console.log(ui8a)&#125;var reader = new FileReader()reader.onload = function() &#123; readBinary(this.result) // 读取result或直接上传&#125;// 把从input里读取的文件内容，放到fileReader的result字段里reader.readAsBinaryString(file) 文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445function uploadAndSubmit() &#123;var form = document.forms[\"demoForm\"];if (form[\"file\"].files.length &gt; 0) &#123;// 寻找表单域中的 &lt;input type=\"file\" ... /&gt; 标签var file = form[\"file\"].files[0];// try sendingvar reader = new FileReader();reader.onloadstart = function() &#123;// 这个事件在读取开始时触发console.log(\"onloadstart\");document.getElementById(\"bytesTotal\").textContent = file.size;&#125;reader.onprogress = function(p) &#123;// 这个事件在读取进行中定时触发console.log(\"onprogress\");document.getElementById(\"bytesRead\").textContent = p.loaded;&#125;reader.onload = function() &#123; // 这个事件在读取成功结束后触发console.log(\"load complete\");&#125;reader.onloadend = function() &#123; // 这个事件在读取结束后，无论成功或者失败都会触发if (reader.error) &#123;console.log(reader.error);&#125; else &#123;document.getElementById(\"bytesRead\").textContent = file.size;// 构造 XMLHttpRequest 对象，发送文件 Binary 数据var xhr = new XMLHttpRequest();xhr.open(/* method */ \"POST\",/* target url */ \"upload.jsp?fileName=\" + file.name/*, async, default to true */);// 二进制流// 指定一个MIME类型用于替代服务器指定的类型，使服务端响应信息中传输的数据按照该指定MIME类型处理xhr.overrideMimeType(\"application/octet-stream\");xhr.sendAsBinary(reader.result);xhr.onreadystatechange = function() &#123;if (xhr.readyState == 4) &#123;if (xhr.status == 200) &#123;console.log(\"upload complete\");console.log(\"response: \" + xhr.responseText); formData 异步上传FormData 对象主要用来组装一组用 XMLHttpRequest 发送请求的键/值对，可以更加灵活地发送 Ajax 请求。可以使用 FormData 来模拟表单提交。 1234let files = e.target.files // 获取 input 的 file 对象let formData = new FormData()formData.append('file', file)axios.post(url, formData) 大文件上传大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？ 文件切片参考： 大文件切割上传编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。在 JavaScript 中，文件 FIle 对象是 Blob 对象的子类，Blob 对象包含一个重要的方法 slice，通过这个方法，我们就可以对二进制文件进行拆分。下面是一个拆分文件的示例 123456789101112131415161718192021222324252627function slice(file, piece = 1024 * 1024 * 5) &#123; let totalSize = file.size; // 文件总大小 let start = 0; // 每次上传的开始字节 let end = start + piece; // 每次上传的结尾字节 let chunks = [] while (start &lt; totalSize) &#123; // 根据长度截取每次需要上传的数据 // File对象继承自Blob对象，因此包含slice方法 let blob = file.slice(start, end); chunks.push(blob) start = end; end = start + piece; &#125; return chunks&#125;将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可let file = document.querySelector(\"[name=file]\").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH); // 首先拆分切片chunks.forEach(chunk=&gt;&#123; let fd = new FormData(); fd.append(\"file\", chunk); post('/mkblk.php', fd)&#125;) 断点续传即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过断点续传来进行处理。断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。由于整个上传过程是按切片维度进行的，且 mkfile 接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单： 在切片上传成功后，保存已上传的切片信息当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传所有切片上传完毕后，再调用 mkfile 接口通知服务端进行文件合并 因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略 可以通过 locaStorage 等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件 context 查询已上传切片的接口，在上传文件前调用该文件的历史上传记录下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能 12345678910111213141516171819202122232425262728293031323334353637383940 // 获取已上传切片记录function getUploadSliceRecord(context)&#123; let record = localStorage.getItem(context) if(!record)&#123; return [] &#125;else &#123; try&#123; return JSON.parse(record) &#125;catch(e)&#123;&#125; &#125;&#125;// 保存已上传切片function saveUploadSliceRecord(context, sliceIndex)&#123; let list = getUploadSliceRecord(context) list.push(sliceIndex) localStorage.setItem(context, JSON.stringify(list))&#125;// 然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑let context = createContext(file);// 获取上传记录let record = getUploadSliceRecord(context);let tasks = [];chunks.forEach((chunk, index) =&gt; &#123; // 已上传的切片则不再重新上传 if(record.includes(index))&#123; return &#125; let fd = new FormData(); fd.append(\"file\", chunk); fd.append(\"context\", context); fd.append(\"chunk\", index + 1); let task = post(\"/mkblk.php\", fd).then(res=&gt;&#123; // 上传成功后保存已上传切片记录 saveUploadSliceRecord(context, index) record.push(index) &#125;) tasks.push(task);&#125;); 此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。服务端实现断点续传的逻辑基本相似，只要在 getUploadSliceRecord 内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。此外断点续传还需要考虑切片过期的情况：如果调用了 mkfile 接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用 mkfile 的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。 上传进度和暂停通过 xhr.upload 中的 progress 方法可以实现监控每一个切片上传进度。上传暂停的实现也比较简单，通过 xhr.abort 可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。 123456xhr.upload.onprogress = function(event) &#123; if (event.lengthComputable) &#123; var percentComplete = (event.loaded / event.total) * 100 // 对进度进行处理 &#125;&#125; 其中事件的 lengthComputable 属性代表文件总大小是否可知。如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。 如果是现代浏览器，可以直接配合 HTML5 提供的 图片预览12345678910111213141516function handleImageFile(file) &#123; var previewArea = document.getElementById('previewArea') var img = document.createElement('img') var fileInput = document.getElementById('myFile') var file = fileInput.files[0] img.file = file previewArea.appendChild(img) var reader = new FileReader() reader.onload = (function(aImg) &#123; return function(e) &#123; aImg.src = e.target.result &#125; &#125;)(img) reader.readAsDataURL(file)&#125; 这里我们使用 FileReader 来处理图片的异步加载。在创建新的 FileReader 对象之后，我们建立了 onload 函数，然后调用 readAsDataURL()开始在后台进行读取操作。当图像文件加载后，转换成一个 data: URL，并传递到 onload 回调函数中设置给 img 的 src。该函数可以帮助实现预览以及压缩图片的功能 123456789另外我们还可以通过使用对象URL来实现预览var img = document.createElement('img')img.src = window.URL.createObjectURL(file)img.onload = function() &#123; // 明确地通过调用释放 window.URL.revokeObjectURL(this.src)&#125;previewArea.appendChild(img) 多文件支持12345678910&lt;input id=\"myFile\" type=\"file\" multiple&gt;// 我们就能在打开的文件选择对话框中选中多个文件了。然后你在代码里拿到的FileUpload对象的files属性就是一个选中的多文件的数组了。var fileInput = document.getElementById(\"myFile\");var files = fileInput.files;var formData = new FormData();for(var i = 0; i &lt; files.length; i++) &#123;var file = files[i];formData.append('files[]', file, file.name);&#125; FormData的append方法提供第三个可选参数用于指定文件名，这样就可以使用同一个表单项名，然后用文件名区分上传的多个文件。这样也方便前后台的循环操作。 图片压缩使用filereader读取到图片之后使用canvas压缩图片的尺寸 12345678910111213141516171819202122232425262728293031323334compress (data, callback) &#123; /** * 压缩图片 * @param data file文件 数据会一直向下传递 * @param callback 下一步回调 */ const &#123;compressionRatio&#125; = this.props; const imgFile = data.file; const img = new window.Image(); img.src = data.dataUrl; img.onload = function () &#123; const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0, canvas.width, canvas.height); let compressedDataUrl; if(data.compress)&#123; compressedDataUrl = canvas.toDataURL(imgFile.type, (compressionRatio / 100)); &#125; else &#123; compressedDataUrl = canvas.toDataURL(imgFile.type, 1); &#125; data.compressedDataUrl = compressedDataUrl; callback(data); &#125; &#125; 结合 xhr 的 progress 事件实现上传进度条12345678910111213141516171819202122uploadImg (data, formData) &#123; // 开始发送请求上传 const _this = this; const xhr = new XMLHttpRequest(); const &#123;uploadUrl&#125; = this.props; // 进度监听 xhr.upload.addEventListener('progress', _this.handleProgress.bind(_this, data.uuid), false);... xhr.open('POST', uploadUrl , true); xhr.send(formData); &#125; handleProgress (id, e) &#123; // 监听上传进度 操作DOM 显示进度 const number = Number.parseInt((e.loaded / e.total) * 100) + \"%\"; const text = document.querySelector('#text-'+id); const progress = document.querySelector('#progress-'+id); text.innerHTML = number; progress.style.width = number; &#125; 上传多个文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273*uploadGenerator (uploadQueue) &#123; /** * 多张图片并发上传控制规则 * 上传1-max数量的图片 * 设置一个最大上传数量 * 保证最大只有这个数量的上传请求 * */ // 最多只有三个请求在上传 const maxUploadSize = 3; if(uploadQueue.length &gt; maxUploadSize)&#123; const result = []; for(let i = 0; i &lt; uploadQueue.length; i++)&#123; // 第一次return maxUploadSize数量的图片 if(i &lt; maxUploadSize)&#123; result.push(uploadQueue[i]); if(i === maxUploadSize - 1)&#123; yield result; &#125; &#125; else &#123; yield [uploadQueue[i]]; &#125; &#125; &#125; else &#123; yield uploadQueue.map((item)=&gt;(item)); &#125; &#125;// 调用// 通过该函数获取每次要上传的数组 this.uploadGen = this.uploadGenerator(uploadQueue); // 第一次要上传的数量 const firstUpload = this.uploadGen.next(); // 真正开始上传流程 firstUpload.value.map((item)=&gt;&#123; /** * 图片上传分成5步 * 图片转dataUrl * 压缩 * 处理数据格式 * 准备数据上传 * 上传 * * 前两步是回调的形式 后面是同步的形式 */ this.transformFileToDataUrl(item, this.compress, this.processData); &#125;);// 上传下一个 function uploadImgxhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 201) &#123; // 上传成功 _this.handleUploadEnd(data, 2); &#125; else &#123; // 上传失败 _this.handleUploadEnd(data, 3); &#125; &#125; &#125;;// function handleuploadend const nextUpload = this.uploadGen.next(); if(!nextUpload.done)&#123; nextUpload.value.map((item)=&gt;&#123; _this.transformFileToDataUrl(item, _this.compress, _this.processData); &#125;); &#125; 移动端上传文件的兼容性问题部分安卓微信浏览器无法触发 onchange 事件（第一步就特么遇到问题）这其实安卓微信的一个遗留问题。 查看讨论 解决办法也很简单：input 标签 &lt;input type=“file” name=”image” accept=”image/gif, image/jpeg, image/png”&gt;要写成就没问题了。部分安卓微信不支持 Blob 对象部分 Blob 对象 append 进 FormData 中出现问题iOS 8 不支持 new File Constructor，但是支持 input 里的 file 对象。iOS 上经过压缩后的图片可以上传成功 但是 size 是 0 无法打开。部分手机出现图片上传转换问题，请移步。安卓手机不支持多选，原因在于 multiple 属性根本就不支持。多张图片转 base64 时候卡顿，因为调用了 cpu 进行了计算。上传图片可以使用 base64 上传或者 formData 上传 解决对策 参考文章 移动端 H5 实现图片上传 每日小知识点 选取第一个到倒数第二个元素 aaa.slice(0,-1)","categories":[],"tags":[{"name":"基础技能","slug":"基础技能","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/基础技能/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2019-05-18T06:47:36.000Z","updated":"2023-04-19T02:19:44.129Z","comments":true,"path":"2019/05/18/防抖与节流/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/05/18/防抖与节流/","excerpt":"","text":"防抖在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 如何理解防抖就是要延迟执行，你一直操作触发事件一直不执行，当你停止操作等待多少秒后才执行。它的作用也是防止抖动。试想当你频繁触发一个事件时，就会引起不必要的性能损失，那么让该事件在停止触发后再触发，以此减少部分性能 如何实现防抖函数分为非立即执行版和立即执行版。 非立即执行版： 1234567891011 function debounce(func, wait) &#123; let timeout; return function () &#123; const context = this; const args = [...arguments]; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, wait); &#125;&#125; 立即执行版： 12345678910111213function debounce(func,wait) &#123; let timeout; return function () &#123; const context = this; const args = [...arguments]; if (timeout) clearTimeout(timeout); const callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125;&#125; 节流连续触发事件但是在 n 秒中只执行一次函数 1234567891011121314151617181920212223242526272829// 非定时器版 记录一下上次触发的时间 与当前时间比较function throttle(func, wait) &#123; var previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125;// 定时器版function throttle(func, wait) &#123; let timeout; return function() &#123; let context = this; let args = arguments; // 如果没有正在执行的 就再设置一个定时器让他一段时间之后触发 if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 防抖与节流的区别节流防抖就好比乘电梯，比如delay是10秒，name防抖就是电梯每进来一个人就要等10秒再运行，而节流就是电梯保证每10秒可以运行一次 如何在小于规定的时间间隔内连续触发防抖函数 定时器总是被清空，因此只会在最后一次，停止抖动的时候才执行，而函数节流是间隔时间执行。 应用场景防抖 search搜索联想，用户在不断输入值时，用防抖来节约请求资源 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求节流 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 浏览器播放事件，每个一秒计算一次进度信息","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/性能优化/"}]},{"title":"你不知道的vue（上）","slug":"你不知道的vue","date":"2019-05-17T14:12:58.000Z","updated":"2023-04-23T07:51:49.942Z","comments":true,"path":"2019/05/17/你不知道的vue/","link":"","permalink":"https://earnest1997.github.io/ashley271017.github.io/2019/05/17/你不知道的vue/","excerpt":"","text":"nextTick有啥用？原理是啥？有啥用？可以用于获取更新后的 DOM 元素 原理是啥？nextTick 的实现原理也是利用事件循环来进行异步操作，然后等 vue 的事件循环结束之后，再执行回调函数。首先大多数情况下，nextTick 会通过 Promise.then()来将回调函数添加入微任务队列。同时，nextTick 还设置了状态锁pedding，通过pedding来判断当前队列当中是否已经存在一个nextTick的任务。这样就可以避免多次执行nextTick的任务，降低系统资源的使用。 假如我们的浏览器不支持 Promise 的话，我们就无法使用 Promise 了。这种情况，我们会选择将 nextTick 加入到宏任务队列。另外，当 nextTick 的回调执行的时候，下一次事件循环还没有执行，这时候我们是获取不到更新渲染之后的数据的，因此，这时候我们会将 nextTick 的回调函数添加到宏任务队列当中 为什么可以获取到最新的dom？先来看看vue更新之后重新渲染的流程： 123456789101112131415// watcher.js// 当依赖发生变化时，触发更新update() &#123; if(this.lazy) &#123; // 懒执行会走这里, 比如computed this.dirty = true &#125;else if(this.sync) &#123; // 同步执行会走这里，比如this.$watch() 或watch选项，传递一个sync配置&#123;sync: true&#125; this.run() &#125;else &#123; // 将当前watcher放入watcher队列， 一般都是走这里 queueWatcher(this) &#125;​&#125; 从这里我们可以发现vue默认就是走的异步更新机制，它会实现一个队列进行缓存当前需要更新的watcher 1234567891011121314151617181920212223242526272829// scheduler.js/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/export function queueWatcher (watcher: Watcher) &#123; /*获取watcher的id*/ const id = watcher.id /*检验id是否存在，已经存在则直接跳过，不存在则标记在has中，用于下次检验*/ if (has[id] == null) &#123; has[id] = true // 如果flushing为false， 表示当前watcher队列没有在被刷新，则watcher直接进入队列 if (!flushing) &#123; queue.push(watcher) &#125; else &#123; // 如果watcher队列已经在被刷新了，这时候想要插入新的watcher就需要特殊处理 // 保证新入队的watcher刷新仍然是有序的 let i = queue.length - 1 while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(Math.max(i, index) + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; // wating为false，表示当前浏览器的异步任务队列中没有flushSchedulerQueue函数 waiting = true // 这就是我们常见的this.$nextTick 😈😈 nextTick(flushSchedulerQueue) &#125; &#125;&#125; 从这里我们就能发现vue并不是跟随数据变化立即更新视图的，它而是维护了一个watcher队列，并且id重复的watcher只会推进队列一次，因为我们关心的只是最终的数据，而不是它更新多少次。等到下一个tick时，这些watcher才会从队列中取出，更新视图。 Vue出于性能考虑，Vue会将用户同步修改的多次数据缓存起来，等同步代码执行完，说明这一次的数据修改就结束了，然后才会去更新对应DOM，一方面可以省去不必要的DOM操作，比如同时修改一个数据多次，只需要关心最后一次就好了，另一方面可以将DOM操作聚集，提升render性能。 为什么优先使用微任务？因为微任务一定比宏任务优先执行，如果nextTick是微任务，它会在当前同步任务执行完立即执行所有的微任务，也就是修改DOM的操作也会在当前tick内执行，等本轮tick任务全部执行完成，才是开始执行UI rendering。所以为了能够尽快更新DOM，Vue中优先采用的是微任务，并且在Vue3中，它没有了兼容判断，直接使用的是promise.then微任务，不再考虑宏任务了。 keep-alive的实现原理什么是？keep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。 它提供了include与exclude两个属性，允许组件有条件地进行缓存。将缓存name为a的组件。 123&lt;keep-alive include=\"a\"&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt; 生命钩子keep-alive提供了两个生命钩子，分别是activated与deactivated。 因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用activated与deactivated这两个生命钩子来得知当前组件是否处于活动状态 原理123456789101112131415161718192021222324252627282930313233343536373839404142434445// created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点😈created () &#123; /* 缓存对象 */ this.cache = Object.create(null)&#125;,/* destroyed钩子中销毁所有cache中的组件实例😈 */destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache[key]) &#125;&#125;,render () &#123; /* 得到slot插槽中的第一个组件 */ const vnode: VNode = getFirstComponentChild(this.$slots.default) const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; // check pattern /* 获取组件名称，优先获取组件的name字段，否则是组件的tag */ const name: ?string = getComponentName(componentOptions) /* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */ if (name &amp;&amp; ( (this.include &amp;&amp; !matches(this.include, name)) || (this.exclude &amp;&amp; matches(this.exclude, name)) )) &#123; return vnode &#125; const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : '') : vnode.key /* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存😈😈 */ if (this.cache[key]) &#123; vnode.componentInstance = this.cache[key].componentInstance &#125; else &#123; this.cache[key] = vnode &#125; /* keepAlive标记位 */ vnode.data.keepAlive = true &#125; return vnode&#125; render做的事情：首先通过getFirstComponentChild获取第一个子组件，获取该组件的name（存在组件名则直接使用组件名，否则会使用tag）。接下来会将这个name通过include与exclude属性进行匹配，匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回vnode，vnode是一个VNode类型的对象 Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。 当同时使用include和exclude的时候，exclude的优先级会更高，include就不生效 keep-alive如何做动态缓存？比如详情页返回列表页，列表需要缓存，首页直接进入列表页不需要 123456789&lt;!-- 动态定义include --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;keep-alive :include=\"include\"&gt; &lt;router-view v-if=\"$route.meta.keepAlive\" /&gt; &lt;/keep-alive&gt; &lt;router-view v-if=\"!$route.meta.keepAlive\" /&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920212223&lt;!-- 实时监听路由 修改include --&gt;export default &#123; data() &#123; return &#123; include: [] &#125;; &#125;, watch: &#123; $route(to, from) &#123; // 如果要to(进入)的页面是需要keepAlive缓存的，把name push进include数组中 if (to.meta.keepAlive) &#123; !this.include.includes(to.name) &amp;&amp; this.include.push(to.name); &#125; // 如果 要 form(离开) 的页面是 keepAlive缓存的， // 再根据 deepth 来判断是前进还是后退 // 如果是后退： if (from.meta.keepAlive &amp;&amp; to.meta.deepth &lt; from.meta.deepth) &#123; const index = this.include.indexOf(from.name); index !== -1 &amp;&amp; this.include.splice(index, 1); &#125; &#125; &#125;&#125;; 可以根据from信息得知是从哪一个页面跳转过来的，同时更新include vue复用方式mixin 普通mixin当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。 比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125; &#125;&#125;) 同名钩子函数将合并为一个数组，因此都将被调用。另外，mixin的钩子将在组件自身钩子之前调用。值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 全局mixin一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑123456789101112Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;) mixin原理123456789101112131415161718192021222324252627282930// init.jsVue.prototype._init = function(options) &#123; const vm = this; // vm.constructor === Vue ~ vm实例的构造函数是Vue vm.$options = mergeOptions(vm.constructor.options, options); // 后面会对options进行扩展操作 // 对数据进行初始化 watch computed props data ... initState(vm); // vm.$options.data 数据劫持 if (vm.$options.el) &#123; // 将数据挂载到这个模板上 vm.$mount(vm.$options.el); &#125;&#125; // global-api/mixin.jsimport &#123; mergeOptions &#125; from '../util/index'export function initMixin (Vue) &#123; // 创建一个严格空对象，可以理解为&#123;&#125;// 你需要一个非常干净且高度可定制的对象当作数据字典的时候；// 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候 Vue.options = Object.create(null); // 用来存所有vue子类的初始构造函数大Vue Vue.options._base = Vue; Vue.mixin = function (mixinOptions) &#123; // 将属性合并到Vue.options上 // 这里的this是，谁调用它就指向谁，那么往上看两个例子，Vue.mixin(xxx)，所以这里指向的是大Vue this.options = mergeOptions(this.options, mixinOptions) return this; &#125;&#125; this.$set是干嘛的？如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 1234567891011data () &#123; return &#123; student: &#123; name: '', sex: '' &#125; &#125;&#125;mounted () &#123; // ——钩子函数，实例挂载之后 this.student.age = 24 // 无用&#125; 为什么？Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。 怎么解决？ 123mounted () &#123; this.$set(this.student,\"age\", 24)&#125; vue.setVue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性 1234567891011var vm=new Vue(&#123; el:'#test', data:&#123; //data中已经存在info根属性 info:&#123; name:'小明'; &#125; &#125;&#125;);//给info添加一个性别属性Vue.set(vm.info,'sex','男'); set方法的实现123456$set(target,key,value)&#123; //新增的属性也变成响应式的 defineReactive(target,key,value) //执行 target.__ob__.dep.notify() &#125; vue生命周期 beforeCreate 这个时候初始化了vue实例， created:在这个阶段会完成数据观测、方法与属性的计算以及watch、event事件回调的配置el,template选项的优先级？当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数： 123render (h) &#123; return h('div', &#123;&#125;, this.text)&#125; render(h)中的h?render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。 使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。 beforeMount:beforeMount在有了render function(vue-loader会将template变成render function)的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。在这个阶段可以拿到vm.el mounted: vm.el已经完成dom的挂载与渲染 后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。 beforeDestroy: 被销毁前调用，此时实例属性与方法可访问 destroyed: 完全销毁一个实例，可清理它与实例的连接，解除它的全部指令以及事件监听器 数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成，虽然都能拿到实例对象的属性和方法，但是放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况，建议：放在create生命周期当中 为什么不能放在beforeupdate updated里面？要是setData了又会重新走这个钩子 setData一定会触发更新钩子吗不一定，只有视图变化的时候才会触发 视图层数据变化一定会触发更新吗？不一定 为什么v-if v-for不能一起用？v-if指令跟v-for一起用的时候：v-for的优先级更高（vue3中是v-if的优先级更高），不能一起用是因为每次都会先渲染再进行条件判断，如何解决？ 12&lt;template v-if='xxx'&gt; &lt;v-for=...&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://earnest1997.github.io/ashley271017.github.io/tags/vue/"}]}]}